# Bazaar merge directive format 2 (Bazaar 0.90)
# revision_id: berdario@gmail.com-20130131211913-5yf4fq5oz3txchrk
# target_branch: file:///home/dario/Projects/twisted/
# testament_sha1: aef8a7b9a51c00f710b03e05fc441634834d2eb9
# timestamp: 2013-01-31 22:54:53 +0100
# base_revision_id: svn-v4:bbbe8e31-12d6-0310-92fd-\
#   ac37d47ddeeb:trunk:37018
# 
# Begin patch
=== added file '.bzrignore'
--- .bzrignore	1970-01-01 00:00:00 +0000
+++ .bzrignore	2013-01-28 20:16:24 +0000
@@ -0,0 +1,46 @@
+_trial_temp
+env
+admin/__pycache__
+twisted/__pycache__
+twisted/application/__pycache__
+twisted/conch/__pycache__
+twisted/cred/__pycache__
+twisted/internet/__pycache__
+twisted/lore/__pycache__
+twisted/mail/__pycache__
+twisted/mail/_trial_temp
+twisted/manhole/__pycache__
+twisted/names/__pycache__
+twisted/news/__pycache__
+twisted/pair/__pycache__
+twisted/persisted/__pycache__
+twisted/plugins/dropin.cache
+twisted/protocols/__pycache__
+twisted/python/__pycache__
+twisted/runner/__pycache__
+twisted/scripts/__pycache__
+twisted/spread/__pycache__
+twisted/test/__pycache__
+twisted/trial/__pycache__
+twisted/web/__pycache__
+twisted/words/__pycache__
+twisted/application/test/__pycache__
+twisted/conch/insults/__pycache__
+twisted/conch/ssh/__pycache__
+twisted/conch/test/__pycache__
+twisted/internet/test/__pycache__
+twisted/lore/test/__pycache__
+twisted/mail/test/__pycache__
+twisted/manhole/test/__pycache__
+twisted/manhole/ui/__pycache__
+twisted/manhole/ui/test/__pycache__
+twisted/names/test/__pycache__
+twisted/news/test/__pycache__
+twisted/pair/test/__pycache__
+twisted/persisted/test/__pycache__
+twisted/protocols/test/__pycache__
+twisted/python/test/__pycache__
+twisted/runner/test/__pycache__
+twisted/trial/test/__pycache__
+twisted/web/test/__pycache__
+twisted/words/test/__pycache__

=== modified file 'admin/_twistedpython3.py'
--- admin/_twistedpython3.py	2013-01-02 01:05:08 +0000
+++ admin/_twistedpython3.py	2013-01-31 20:08:05 +0000
@@ -53,6 +53,7 @@
     "twisted.internet.threads",
     "twisted.internet.udp",
     "twisted.internet._utilspy3",
+    "twisted.mail.imap4"
     "twisted.names",
     "twisted.names.cache",
     "twisted.names.client",
@@ -141,6 +142,7 @@
     "twisted.internet.test.test_udp",
     "twisted.internet.test.test_udp_internals",
     "twisted.internet.test.test_utilspy3",
+    "twisted.mail.test.test_imap"
     "twisted.names.test.test_cache",
     "twisted.names.test.test_client",
     "twisted.names.test.test_common",

=== modified file 'twisted/cred/checkers.py'
--- twisted/cred/checkers.py	2011-02-14 04:45:15 +0000
+++ twisted/cred/checkers.py	2013-01-31 20:08:05 +0000
@@ -4,7 +4,7 @@
 
 import os
 
-from zope.interface import implements, Interface, Attribute
+from zope.interface import implementer, Interface, Attribute
 
 from twisted.internet import defer
 from twisted.python import failure, log
@@ -48,15 +48,15 @@
 
 ANONYMOUS = ()
 
-
+@implementer(ICredentialsChecker)
 class AllowAnonymousAccess:
-    implements(ICredentialsChecker)
     credentialInterfaces = credentials.IAnonymous,
 
     def requestAvatarId(self, credentials):
         return defer.succeed(ANONYMOUS)
 
 
+@implementer(ICredentialsChecker)
 class InMemoryUsernamePasswordDatabaseDontUse:
     """
     An extremely simple credentials checker.
@@ -69,8 +69,6 @@
     see L{FilePasswordDB}.
     """
 
-    implements(ICredentialsChecker)
-
     credentialInterfaces = (credentials.IUsernamePassword,
                             credentials.IUsernameHashedPassword)
 
@@ -96,6 +94,7 @@
             return defer.fail(error.UnauthorizedLogin())
 
 
+@implementer(ICredentialsChecker)
 class FilePasswordDB:
     """A file-based, text-based username/password database.
 
@@ -109,8 +108,6 @@
     IUsernameHashedPassword credentials will be checkable as well.
     """
 
-    implements(ICredentialsChecker)
-
     cache = False
     _credCache = None
     _cacheTimestamp = 0
@@ -245,8 +242,8 @@
 
 
 
+@implementer(ICredentialsChecker)
 class PluggableAuthenticationModulesChecker:
-    implements(ICredentialsChecker)
     credentialInterfaces = credentials.IPluggableAuthenticationModules,
     service = 'Twisted'
 

=== modified file 'twisted/cred/credentials.py'
--- twisted/cred/credentials.py	2011-02-14 04:45:15 +0000
+++ twisted/cred/credentials.py	2013-01-31 20:08:05 +0000
@@ -4,7 +4,7 @@
 # See LICENSE for details.
 
 
-from zope.interface import implements, Interface
+from zope.interface import implementer, Interface
 
 import hmac, time, random
 from twisted.python.hashlib import md5
@@ -107,12 +107,11 @@
     """
 
 
-
+@implementer(IUsernameHashedPassword, IUsernameDigestHash)
 class DigestedCredentials(object):
     """
     Yet Another Simple HTTP Digest authentication scheme.
     """
-    implements(IUsernameHashedPassword, IUsernameDigestHash)
 
     def __init__(self, username, method, realm, fields):
         self.username = username
@@ -364,8 +363,8 @@
 
 
 
+@implementer(IUsernameHashedPassword)
 class CramMD5Credentials:
-    implements(IUsernameHashedPassword)
 
     challenge = ''
     response = ''
@@ -398,8 +397,8 @@
         return verify == self.response
 
 
+@implementer(IUsernameHashedPassword)
 class UsernameHashedPassword:
-    implements(IUsernameHashedPassword)
 
     def __init__(self, username, hashed):
         self.username = username
@@ -409,8 +408,8 @@
         return self.hashed == password
 
 
+@implementer(IUsernamePassword)
 class UsernamePassword:
-    implements(IUsernamePassword)
 
     def __init__(self, username, password):
         self.username = username
@@ -420,8 +419,9 @@
         return self.password == password
 
 
+@implementer(IAnonymous)
 class Anonymous:
-    implements(IAnonymous)
+    pass
 
 
 
@@ -448,9 +448,8 @@
     """
 
 
-
+@implementer(ISSHPrivateKey)
 class SSHPrivateKey:
-    implements(ISSHPrivateKey)
     def __init__(self, username, algName, blob, sigData, signature):
         self.username = username
         self.algName = algName
@@ -474,9 +473,8 @@
     currently unused, but is required by the PAM library.
     """
 
+@implementer(IPluggableAuthenticationModules)
 class PluggableAuthenticationModules:
-    implements(IPluggableAuthenticationModules)
-
     def __init__(self, username, pamConversion):
         self.username = username
         self.pamConversion = pamConversion

=== modified file 'twisted/cred/portal.py'
--- twisted/cred/portal.py	2011-02-14 04:45:15 +0000
+++ twisted/cred/portal.py	2013-01-31 20:08:05 +0000
@@ -10,7 +10,7 @@
 
 from twisted.internet import defer
 from twisted.internet.defer import maybeDeferred
-from twisted.python import failure, reflect
+from twisted.python import failure, _reflectpy3 as reflect
 from twisted.cred import error
 from zope.interface import providedBy, Interface
 

=== modified file 'twisted/mail/imap4.py'
--- twisted/mail/imap4.py	2013-01-25 22:30:32 +0000
+++ twisted/mail/imap4.py	2013-01-31 21:19:13 +0000
@@ -15,7 +15,6 @@
   Make APPEND recognize (again) non-existent mailboxes before accepting the literal
 """
 
-import rfc822
 import base64
 import binascii
 import hmac
@@ -27,14 +26,12 @@
 import random
 import types
 
-import email.Utils
-
-try:
-    import cStringIO as StringIO
-except:
-    import StringIO
-
-from zope.interface import implements, Interface
+import email.utils
+
+from io import StringIO, BytesIO
+from itertools import chain
+
+from zope.interface import implementer, Interface
 
 from twisted.protocols import basic
 from twisted.protocols import policies
@@ -42,6 +39,7 @@
 from twisted.internet import error
 from twisted.internet.defer import maybeDeferred
 from twisted.python import log, text
+from twisted.python.compat import unicode, intTypes
 from twisted.internet import interfaces
 
 from twisted import cred
@@ -50,9 +48,8 @@
 
 
 # locale-independent month names to use instead of strftime's
-_MONTH_NAMES = dict(zip(
-        range(1, 13),
-        "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split()))
+_MONTH_NAMES = dict(enumerate(
+        "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(), 1))
 
 
 class MessageSet(object):
@@ -89,7 +86,7 @@
         if start is self._empty:
             return
 
-        if isinstance(start, types.ListType):
+        if isinstance(start, list):
             self.ranges = start[:]
             self.clean()
         else:
@@ -198,7 +195,7 @@
 
             oldl, oldh = l, h
 
-        self.ranges = filter(None, self.ranges)
+        self.ranges = [v for v in self.ranges if v]
 
 
     def __contains__(self, value):
@@ -301,7 +298,7 @@
         if size > self._memoryFileLimit:
             self.data = tempfile.TemporaryFile()
         else:
-            self.data = StringIO.StringIO()
+            self.data = BytesIO()
 
     def write(self, data):
         self.size -= len(data)
@@ -374,7 +371,7 @@
             N = len(names)
             if (N >= 1 and names[0] in self._1_RESPONSES or
                 N >= 2 and names[1] in self._2_RESPONSES or
-                N >= 2 and names[0] == 'OK' and isinstance(names[1], types.ListType) and names[1][0] in self._OK_RESPONSES):
+                N >= 2 and names[0] == 'OK' and isinstance(names[1], list) and names[1][0] in self._OK_RESPONSES):
                 send.append(names)
             else:
                 unuse.append(names)
@@ -462,7 +459,7 @@
 # Some definitions (SP, CTL, DQUOTE) are also from the ABNF RFC -
 # <https://tools.ietf.org/html/rfc2234>.
 _SP = ' '
-_CTL = ''.join(chr(ch) for ch in range(0x21) + range(0x80, 0x100))
+_CTL = ''.join(chr(ch) for ch in chain(range(0x21), range(0x80, 0x100)))
 
 # It is easier to define ATOM-CHAR in terms of what it does not match than in
 # terms of what it does match.
@@ -471,6 +468,7 @@
 # This is all the bytes that match the ATOM-CHAR from the grammar in the RFC.
 _atomChars = ''.join(chr(ch) for ch in range(0x100) if chr(ch) not in _nonAtomChars)
 
+@implementer(IMailboxListener)
 class IMAP4Server(basic.LineReceiver, policies.TimeoutMixin):
     """
     Protocol implementation for an IMAP4rev1 server.
@@ -481,7 +479,6 @@
         - Selected
         - Logout
     """
-    implements(IMailboxListener)
 
     # Identifier for this server software
     IDENT = 'Twisted IMAP4rev1 Ready'
@@ -541,7 +538,7 @@
         self._queuedAsync = []
 
     def capabilities(self):
-        cap = {'AUTH': self.challengers.keys()}
+        cap = {'AUTH': list(self.challengers.keys())}
         if self.ctx and self.canStartTLS:
             if not self.startedTLS and interfaces.ISSLTransport(self.transport, None) is None:
                 cap['LOGINDISABLED'] = None
@@ -601,7 +598,7 @@
         f = getattr(self, 'parse_' + self.parseState)
         try:
             f(line)
-        except Exception, e:
+        except Exception as e:
             self.sendUntaggedResponse('BAD Server error: ' + str(e))
             log.err()
 
@@ -623,11 +620,11 @@
         cmd = cmd.upper()
         try:
             return self.dispatchCommand(tag, cmd, rest)
-        except IllegalClientResponse, e:
+        except IllegalClientResponse as e:
             self.sendBadResponse(tag, 'Illegal syntax: ' + str(e))
-        except IllegalOperation, e:
+        except IllegalOperation as e:
             self.sendNegativeResponse(tag, 'Illegal operation: ' + str(e))
-        except IllegalMailboxEncoding, e:
+        except IllegalMailboxEncoding as e:
             self.sendNegativeResponse(tag, 'Illegal mailbox name: ' + str(e))
 
     def parse_pending(self, line):
@@ -668,7 +665,8 @@
         else:
             handler(*args)
 
-    def __cbDispatch(self, (arg, rest), tag, fn, args, parseargs, uid):
+    def __cbDispatch(self, arguments, tag, fn, args, parseargs, uid):
+        arg, rest = arguments
         args.append(arg)
         self.__doCommand(tag, fn, args, parseargs, rest, uid)
 
@@ -811,7 +809,7 @@
 
         try:
             return (parseIdList(arg), rest)
-        except IllegalIdentifierError, e:
+        except IllegalIdentifierError as e:
             raise IllegalClientResponse("Bad message number " + str(e))
 
     def arg_fetchatt(self, line):
@@ -929,7 +927,7 @@
 
     def listCapabilities(self):
         caps = ['IMAP4rev1']
-        for c, v in self.capabilities().iteritems():
+        for c, v in self.capabilities().items():
             if v is None:
                 caps.append(c)
             elif len(v):
@@ -982,7 +980,7 @@
     def _setupChallenge(self, chal, tag):
         try:
             challenge = chal.getChallenge()
-        except Exception, e:
+        except Exception as e:
             self.sendBadResponse(tag, 'Server error: ' + str(e))
         else:
             coded = base64.encodestring(challenge)[:-1]
@@ -1008,7 +1006,8 @@
                 (tag,), None, (tag,), None
             )
 
-    def __cbAuthResp(self, (iface, avatar, logout), tag):
+    def __cbAuthResp(self, account, tag):
+        iface, avatar, logout = account
         assert iface is IAccount, "IAccount is the only supported interface"
         self.account = avatar
         self.state = 'auth'
@@ -1078,7 +1077,8 @@
             )
         raise cred.error.UnauthorizedLogin()
 
-    def __cbLogin(self, (iface, avatar, logout), tag):
+    def __cbLogin(self, account, tag):
+        iface, avatar, logout = account
         if iface is not IAccount:
             self.sendBadResponse(tag, 'Server error: login returned unexpected value')
             log.err("__cbLogin called with %r, IAccount expected" % (iface,))
@@ -1184,7 +1184,7 @@
         name = self._parseMbox(name)
         try:
             result = self.account.create(name)
-        except MailboxException, c:
+        except MailboxException as c:
             self.sendNegativeResponse(tag, str(c))
         except:
             self.sendBadResponse(tag, "Server error encountered while creating mailbox")
@@ -1205,7 +1205,7 @@
             return
         try:
             self.account.delete(name)
-        except MailboxException, m:
+        except MailboxException as m:
             self.sendNegativeResponse(tag, str(m))
         except:
             self.sendBadResponse(tag, "Server error encountered while deleting mailbox")
@@ -1217,7 +1217,7 @@
     select_DELETE = auth_DELETE
 
     def do_RENAME(self, tag, oldname, newname):
-        oldname, newname = [self._parseMbox(n) for n in oldname, newname]
+        oldname, newname = [self._parseMbox(n) for n in (oldname, newname)]
         if oldname.lower() == 'inbox' or newname.lower() == 'inbox':
             self.sendNegativeResponse(tag, 'You cannot rename the inbox, or rename another mailbox to inbox.')
             return
@@ -1225,7 +1225,7 @@
             self.account.rename(oldname, newname)
         except TypeError:
             self.sendBadResponse(tag, 'Invalid command syntax')
-        except MailboxException, m:
+        except MailboxException as m:
             self.sendNegativeResponse(tag, str(m))
         except:
             self.sendBadResponse(tag, "Server error encountered while renaming mailbox")
@@ -1240,7 +1240,7 @@
         name = self._parseMbox(name)
         try:
             self.account.subscribe(name)
-        except MailboxException, m:
+        except MailboxException as m:
             self.sendNegativeResponse(tag, str(m))
         except:
             self.sendBadResponse(tag, "Server error encountered while subscribing to mailbox")
@@ -1255,7 +1255,7 @@
         name = self._parseMbox(name)
         try:
             self.account.unsubscribe(name)
-        except MailboxException, m:
+        except MailboxException as m:
             self.sendNegativeResponse(tag, str(m))
         except:
             self.sendBadResponse(tag, "Server error encountered while unsubscribing from mailbox")
@@ -1316,9 +1316,9 @@
     select_STATUS = auth_STATUS
 
     def __cbStatus(self, status, tag, box):
-        line = ' '.join(['%s %s' % x for x in status.iteritems()])
-        self.sendUntaggedResponse('STATUS %s (%s)' % (box, line))
-        self.sendPositiveResponse(tag, 'STATUS complete')
+        line = ' '.join(['%s %s' % x for x in status.items()])
+        self.sendUntaggedResponse(('STATUS %s (%s)' % (box, line)).encode("imap4-utf-7"))
+        self.sendPositiveResponse(tag, b'STATUS complete')
 
     def __ebStatus(self, failure, tag, box):
         self.sendBadResponse(tag, 'STATUS %s failed: %s' % (box, str(failure.value)))
@@ -1449,9 +1449,9 @@
     def __cbSearch(self, result, tag, mbox, uid):
         if uid:
             result = map(mbox.getUID, result)
-        ids = ' '.join([str(i) for i in result])
-        self.sendUntaggedResponse('SEARCH ' + ids)
-        self.sendPositiveResponse(tag, 'SEARCH completed')
+        ids = ' '.join([unicode(i) for i in result]).encode()
+        self.sendUntaggedResponse(b'SEARCH ' + ids)
+        self.sendPositiveResponse(tag, b'SEARCH completed')
 
 
     def __cbManualSearch(self, result, tag, mbox, query, uid,
@@ -1489,7 +1489,7 @@
         lastSequenceId = result and result[-1][0]
         lastMessageId = result and result[-1][1].getUID()
 
-        for (i, (id, msg)) in zip(range(5), result):
+        for (i, (id, msg)) in enumerate(result[:5]):
             # searchFilter and singleSearchStep will mutate the query.  Dang.
             # Copy it here or else things will go poorly for subsequent
             # messages.
@@ -1632,7 +1632,7 @@
 
     def search_BEFORE(self, query, id, msg):
         date = parseTime(query.pop(0))
-        return rfc822.parsedate(msg.getInternalDate()) < date
+        return email.utils.parsedate(msg.getInternalDate()) < date
 
     def search_BODY(self, query, id, msg):
         body = query.pop(0).lower()
@@ -1670,7 +1670,7 @@
     def search_NEW(self, query, id, msg):
         return '\\Recent' in msg.getFlags() and '\\Seen' not in msg.getFlags()
 
-    def search_NOT(self, query, id, msg, (lastSequenceId, lastMessageId)):
+    def search_NOT(self, query, id, msg, lastData):
         """
         Returns C{True} if the message does not match the query.
 
@@ -1683,13 +1683,11 @@
         @type msg: Provider of L{imap4.IMessage}
         @param msg: The message being checked.
 
-        @type lastSequenceId: C{int}
-        @param lastSequenceId: The highest sequence number of a message in the
-            mailbox.
-
-        @type lastMessageId: C{int}
-        @param lastMessageId: The highest UID of a message in the mailbox.
+        @type lastData:SequenceId: C{tuple} of 2 C{int}
+        @param lastData: (SequenceId and MessageId) The highest sequence number of a message in the
+            mailbox and The highest UID of a message in the mailbox.
         """
+        lastSequenceId, lastMessageId = lastData
         return not self._singleSearchStep(query, id, msg,
                                           lastSequenceId, lastMessageId)
 
@@ -1698,9 +1696,9 @@
 
     def search_ON(self, query, id, msg):
         date = parseTime(query.pop(0))
-        return rfc822.parsedate(msg.getInternalDate()) == date
+        return email.utils.parsedate(msg.getInternalDate()) == date
 
-    def search_OR(self, query, id, msg, (lastSequenceId, lastMessageId)):
+    def search_OR(self, query, id, msg, lastData):
         """
         Returns C{True} if the message matches any of the first two query
         items.
@@ -1714,13 +1712,12 @@
         @type msg: Provider of L{imap4.IMessage}
         @param msg: The message being checked.
 
-        @type lastSequenceId: C{int}
-        @param lastSequenceId: The highest sequence number of a message in the
-                               mailbox.
-
-        @type lastMessageId: C{int}
-        @param lastMessageId: The highest UID of a message in the mailbox.
+        @type lastData:SequenceId: C{tuple} of 2 C{int}
+        @param lastData: (SequenceId and MessageId) The highest sequence number of a message in the
+            mailbox and The highest UID of a message in the mailbox.
+        
         """
+        lastSequenceId, lastMessageId = lastData
         a = self._singleSearchStep(query, id, msg,
                                    lastSequenceId, lastMessageId)
         b = self._singleSearchStep(query, id, msg,
@@ -1748,7 +1745,7 @@
         @type msg: Provider of L{imap4.IMessage}
         """
         date = msg.getHeaders(False, 'date').get('date', '')
-        date = rfc822.parsedate(date)
+        date = email.utils.parsedate(date)
         return date < parseTime(query.pop(0))
 
     def search_SENTON(self, query, id, msg):
@@ -1763,7 +1760,7 @@
         @type msg: Provider of L{imap4.IMessage}
         """
         date = msg.getHeaders(False, 'date').get('date', '')
-        date = rfc822.parsedate(date)
+        date = email.utils.parsedate(date)
         return date[:3] == parseTime(query.pop(0))[:3]
 
     def search_SENTSINCE(self, query, id, msg):
@@ -1778,12 +1775,12 @@
         @type msg: Provider of L{imap4.IMessage}
         """
         date = msg.getHeaders(False, 'date').get('date', '')
-        date = rfc822.parsedate(date)
+        date = email.utils.parsedate(date)
         return date > parseTime(query.pop(0))
 
     def search_SINCE(self, query, id, msg):
         date = parseTime(query.pop(0))
-        return rfc822.parsedate(msg.getInternalDate()) > date
+        return email.utils.parsedate(msg.getInternalDate()) > date
 
     def search_SMALLER(self, query, id, msg):
         return int(query.pop(0)) > msg.getSize()
@@ -1801,7 +1798,7 @@
         to = msg.getHeaders(False, 'to').get('to', '')
         return to.lower().find(query.pop(0).lower()) != -1
 
-    def search_UID(self, query, id, msg, (lastSequenceId, lastMessageId)):
+    def search_UID(self, query, id, msg, lastData):
         """
         Returns C{True} if the message UID is in the range defined by the
         search query.
@@ -1817,13 +1814,12 @@
         @type msg: Provider of L{imap4.IMessage}
         @param msg: The message being checked.
 
-        @type lastSequenceId: C{int}
-        @param lastSequenceId: The highest sequence number of a message in the
-            mailbox.
-
-        @type lastMessageId: C{int}
-        @param lastMessageId: The highest UID of a message in the mailbox.
+        @type lastData:SequenceId: C{tuple} of 2 C{int}
+        @param lastData: (SequenceId and MessageId) The highest sequence number of a message in the
+            mailbox and The highest UID of a message in the mailbox.
+        
         """
+        _, lastMessageId = lastData
         c = query.pop(0)
         m = parseIdList(c, lastMessageId)
         return msg.getUID() in m
@@ -1868,7 +1864,7 @@
         if self.blocked is None:
             self.blocked = []
         try:
-            id, msg = results.next()
+            id, msg = next(results)
         except StopIteration:
             # The idle timeout was suspended while we delivered results,
             # restore it now.
@@ -1921,7 +1917,7 @@
         if _w is None:
             _w = self.transport.write
         idate = msg.getInternalDate()
-        ttup = rfc822.parsedate_tz(idate)
+        ttup = email.utils.parsedate_tz(idate)
         if ttup is None:
             log.msg("%d:%r: unpareseable internaldate: %r" % (id, msg, idate))
             raise IMAP4Exception("Internal failure generating INTERNALDATE")
@@ -2076,7 +2072,7 @@
 
     def __cbStore(self, result, tag, mbox, uid, silent):
         if result and not silent:
-              for (k, v) in result.iteritems():
+              for (k, v) in result.items():
                   if uid:
                       uidstr = ' UID %d' % mbox.getUID(k)
                   else:
@@ -2180,7 +2176,7 @@
             self.sendUntaggedResponse(message='[READ-ONLY]', async=True)
 
     def flagsChanged(self, newFlags):
-        for (mId, flags) in newFlags.iteritems():
+        for (mId, flags) in newFlags.items():
             msg = '%d FETCH (FLAGS (%s))' % (mId, ' '.join(flags))
             self.sendUntaggedResponse(msg, async=True)
 
@@ -2210,13 +2206,13 @@
 
 TIMEOUT_ERROR = error.TimeoutError()
 
+@implementer(IMailboxListener)
 class IMAP4Client(basic.LineReceiver, policies.TimeoutMixin):
     """IMAP4 client protocol implementation
 
     @ivar state: A string representing the state the connection is currently
     in.
     """
-    implements(IMailboxListener)
 
     tags = None
     waiting = None
@@ -2320,7 +2316,7 @@
         if self.tags is not None:
             tags = self.tags
             self.tags = None
-            for cmd in tags.itervalues():
+            for cmd in tags.values():
                 if cmd is not None and cmd.defer is not None:
                     cmd.defer.errback(reason)
 
@@ -2400,7 +2396,7 @@
         if octets > self._memoryFileLimit:
             return tempfile.TemporaryFile()
         else:
-            return StringIO.StringIO()
+            return BytesIO()
 
     def makeTag(self):
         tag = '%0.4X' % self.tagID
@@ -2548,7 +2544,8 @@
         d.addCallback(self.__cbCapabilities)
         return d
 
-    def __cbCapabilities(self, (lines, tagline)):
+    def __cbCapabilities(self, linesData):
+        lines, _ = linesData
         caps = {}
         for rest in lines:
             for cap in rest[1:]:
@@ -2581,7 +2578,7 @@
         d.addCallback(self.__cbLogout)
         return d
 
-    def __cbLogout(self, (lines, tagline)):
+    def __cbLogout(self, linesData):
         self.transport.loseConnection()
         # We don't particularly care what the server said
         return None
@@ -2600,9 +2597,10 @@
         d.addCallback(self.__cbNoop)
         return d
 
-    def __cbNoop(self, (lines, tagline)):
+    def __cbNoop(self, linesData):
         # Conceivable, this is elidable.
         # It is, afterall, a no-op.
+        lines, _ = linesData
         return lines
 
     def startTLS(self, contextFactory=None):
@@ -2675,13 +2673,13 @@
 
         if self.startedTLS:
             return defer.fail(NoSupportedAuthentication(
-                auths, self.authenticators.keys()))
+                auths, list(self.authenticators.keys())))
         else:
             def ebStartTLS(err):
                 err.trap(IMAP4Exception)
                 # We couldn't negotiate TLS for some reason
                 return defer.fail(NoSupportedAuthentication(
-                    auths, self.authenticators.keys()))
+                    auths, list(self.authenticators.keys())))
 
             d = self.startTLS()
             d.addErrback(ebStartTLS)
@@ -2709,7 +2707,7 @@
                               self.__cbContinueAuth, scheme,
                               secret)
                 return self.sendCommand(cmd)
-        raise NoSupportedAuthentication(auths, self.authenticators.keys())
+        raise NoSupportedAuthentication(auths, list(self.authenticators.keys()))
 
 
     def login(self, username, password):
@@ -2814,7 +2812,8 @@
         d.addCallback(self.__cbNamespace)
         return d
 
-    def __cbNamespace(self, (lines, last)):
+    def __cbNamespace(self, response_lines):
+        lines, _ = response_lines
         for parts in lines:
             if len(parts) == 4 and parts[0] == 'NAMESPACE':
                 return [e or [] for e in parts[1:]]
@@ -2913,7 +2912,7 @@
             raise IllegalServerResponse(phrase)
 
 
-    def __cbSelect(self, (lines, tagline), rw):
+    def __cbSelect(self, linesData, rw):
         """
         Handle lines received in response to a SELECT or EXAMINE command.
 
@@ -2921,6 +2920,7 @@
         """
         # In the absense of specification, we are free to assume:
         #   READ-WRITE access
+        lines, tagline = linesData
         datum = {'READ-WRITE': rw}
         lines.append(parseNestedParens(tagline))
         for split in lines:
@@ -3084,7 +3084,8 @@
         d.addCallback(self.__cbList, 'LSUB')
         return d
 
-    def __cbList(self, (lines, last), command):
+    def __cbList(self, response_lines, command):
+        lines, _ = response_lines
         results = []
         for parts in lines:
             if len(parts) == 4 and parts[0] == command:
@@ -3120,7 +3121,8 @@
         d.addCallback(self.__cbStatus)
         return d
 
-    def __cbStatus(self, (lines, last)):
+    def __cbStatus(self, response_lines):
+        lines, _ = response_lines
         status = {}
         for parts in lines:
             if parts[0] == 'STATUS':
@@ -3132,7 +3134,7 @@
             if t:
                 try:
                     status[k] = t(status[k])
-                except Exception, e:
+                except Exception as e:
                     raise IllegalServerResponse('(%s %s): %s' % (k, status[k], str(e)))
         return status
 
@@ -3232,7 +3234,8 @@
         return d
 
 
-    def __cbExpunge(self, (lines, last)):
+    def __cbExpunge(self, response_lines):
+        lines, _ = response_lines
         ids = []
         for parts in lines:
             if len(parts) == 2 and parts[1] == 'EXPUNGE':
@@ -3267,7 +3270,8 @@
         return d
 
 
-    def __cbSearch(self, (lines, end)):
+    def __cbSearch(self, response_lines):
+        lines, _ = response_lines
         ids = []
         for parts in lines:
             if len(parts) > 0 and parts[0] == 'SEARCH':
@@ -3604,12 +3608,12 @@
         responseParts = iter(fetchResponseList)
         while True:
             try:
-                key = responseParts.next()
+                key = next(responseParts)
             except StopIteration:
                 break
 
             try:
-                value = responseParts.next()
+                value = next(responseParts)
             except StopIteration:
                 raise IllegalServerResponse(
                     "Not enough arguments", fetchResponseList)
@@ -3664,7 +3668,7 @@
                 else:
                     key = (key, (value[0], tuple(value[1])))
                 try:
-                    value = responseParts.next()
+                    value = next(responseParts)
                 except StopIteration:
                     raise IllegalServerResponse(
                         "Not enough arguments", fetchResponseList)
@@ -3679,7 +3683,7 @@
                     else:
                         key = key + (value,)
                         try:
-                            value = responseParts.next()
+                            value = next(responseParts)
                         except StopIteration:
                             raise IllegalServerResponse(
                                 "Not enough arguments", fetchResponseList)
@@ -3688,7 +3692,8 @@
         return values
 
 
-    def _cbFetch(self, (lines, last), requestedParts, structured):
+    def _cbFetch(self, response_lines, requestedParts, structured):
+        lines, _ = response_lines
         info = {}
         for parts in lines:
             if len(parts) == 3 and parts[1] == 'FETCH':
@@ -3699,7 +3704,7 @@
                     info[id][0].extend(parts[2])
 
         results = {}
-        for (messageId, values) in info.iteritems():
+        for (messageId, values) in info.items():
             mapping = self._parseFetchPairs(values[0])
             results.setdefault(messageId, {}).update(mapping)
 
@@ -3818,9 +3823,10 @@
             del terms['rfc822header']
             terms['rfc822.header'] = True
 
-        cmd = '%s (%s)' % (messages, ' '.join([s.upper() for s in terms.keys()]))
+        parts = [s.upper() for s in terms.keys()]
+        cmd = '%s (%s)' % (messages, ' '.join(parts))
         d = self.sendCommand(Command(fetch, cmd, wantResponse=('FETCH',)))
-        d.addCallback(self._cbFetch, map(str.upper, terms.keys()), True)
+        d.addCallback(self._cbFetch, parts, True)
         return d
 
     def setFlags(self, messages, flags, silent=1, uid=0):
@@ -3981,11 +3987,11 @@
                 if low == '*':
                     low = None
                 else:
-                    low = long(low)
+                    low = int(low)
                 if high == '*':
                     high = None
                 else:
-                    high = long(high)
+                    high = int(high)
                 if low is high is None:
                     # *:* does not make sense
                     raise IllegalIdentifierError(p)
@@ -4008,7 +4014,7 @@
                 if p == '*':
                     p = None
                 else:
-                    p = long(p)
+                    p = int(p)
                 if p is not None and p <= 0:
                     raise IllegalIdentifierError(p)
             except ValueError:
@@ -4138,7 +4144,7 @@
     @return: The formatted query string
     """
     cmd = []
-    keys = kwarg.keys()
+    keys = list(kwarg.keys())
     if sorted:
         keys.sort()
     for k in keys:
@@ -4166,7 +4172,7 @@
 def Or(*args):
     """The disjunction of two or more queries"""
     if len(args) < 2:
-        raise IllegalQueryError, args
+        raise IllegalQueryError(args)
     elif len(args) == 2:
         return '(OR %s %s)' % args
     else:
@@ -4277,14 +4283,14 @@
     """
     copy = []
     begun = None
-    listsList = [isinstance(s, types.ListType) for s in results]
+    listsList = [isinstance(s, list) for s in results]
 
-    pred = lambda e: isinstance(e, types.TupleType)
+    pred = lambda e: isinstance(e, tuple)
     tran = {
         0: lambda e: splitQuoted(''.join(e)),
         1: lambda e: [''.join([i[0] for i in e])]
     }
-    for (i, c, isList) in zip(range(len(results)), results, listsList):
+    for i, (c, isList) in enumerate(zip(results, listsList)):
         if isList:
             if begun is not None:
                 copy.extend(splitOn(results[begun:i], pred, tran))
@@ -4334,7 +4340,7 @@
                 elif handleLiteral and c == '{':
                     end = s.find('}', i)
                     if end == -1:
-                        raise ValueError, "Malformed literal"
+                        raise ValueError("Malformed literal")
                     literalSize = int(s[i+1:end])
                     contentStack[-1].append((s[end+3:end+3+literalSize],))
                     i = end + 3 + literalSize
@@ -4412,9 +4418,9 @@
     for i in items:
         if i is None:
             pieces.extend([' ', 'NIL'])
-        elif isinstance(i, (DontQuoteMe, int, long)):
+        elif isinstance(i, (DontQuoteMe, intTypes)):
             pieces.extend([' ', str(i)])
-        elif isinstance(i, types.StringTypes):
+        elif isinstance(i, (bytes, unicode)):
             if _needsLiteral(i):
                 pieces.extend([' ', '{', str(len(i)), '}', IMAP4Server.delimiter, i])
             else:
@@ -4439,9 +4445,8 @@
 
 
 
+@implementer(IClientAuthentication)
 class CramMD5ClientAuthenticator:
-    implements(IClientAuthentication)
-
     def __init__(self, user):
         self.user = user
 
@@ -4453,10 +4458,8 @@
         return '%s %s' % (self.user, response)
 
 
-
+@implementer(IClientAuthentication)
 class LOGINAuthenticator:
-    implements(IClientAuthentication)
-
     def __init__(self, user):
         self.user = user
         self.challengeResponse = self.challengeUsername
@@ -4473,9 +4476,8 @@
         # Respond to something like "Password:"
         return secret
 
+@implementer(IClientAuthentication)
 class PLAINAuthenticator:
-    implements(IClientAuthentication)
-
     def __init__(self, user):
         self.user = user
 
@@ -4693,8 +4695,8 @@
         """
 
 
+@implementer(IAccount, INamespacePresenter)
 class MemoryAccount(object):
-    implements(IAccount, INamespacePresenter)
 
     mailboxes = None
     subscriptions = None
@@ -4716,14 +4718,14 @@
     def addMailbox(self, name, mbox = None):
         name = name.upper()
         if name in self.mailboxes:
-            raise MailboxCollision, name
+            raise MailboxCollision(name)
         if mbox is None:
             mbox = self._emptyMailbox(name, self.allocateID())
         self.mailboxes[name] = mbox
         return 1
 
     def create(self, pathspec):
-        paths = filter(None, pathspec.split('/'))
+        paths = [p for p in pathspec.split('/') if p]
         for accum in range(1, len(paths)):
             try:
                 self.addMailbox('/'.join(paths[:accum]))
@@ -4754,7 +4756,7 @@
             # as part of their root.
             for others in self.mailboxes.keys():
                 if others != name and others.startswith(name):
-                    raise MailboxException, "Hierarchically inferior mailboxes exist and \\Noselect is set"
+                    raise MailboxException("Hierarchically inferior mailboxes exist and \\Noselect is set")
         mbox.destroy()
 
         # iff there are no hierarchically inferior names, we will
@@ -4766,14 +4768,14 @@
         oldname = oldname.upper()
         newname = newname.upper()
         if oldname not in self.mailboxes:
-            raise NoSuchMailbox, oldname
+            raise NoSuchMailbox(oldname)
 
         inferiors = self._inferiorNames(oldname)
         inferiors = [(o, o.replace(oldname, newname, 1)) for o in inferiors]
 
         for (old, new) in inferiors:
             if new in self.mailboxes:
-                raise MailboxCollision, new
+                raise MailboxCollision(new)
 
         for (old, new) in inferiors:
             self.mailboxes[new] = self.mailboxes[old]
@@ -4797,7 +4799,7 @@
     def unsubscribe(self, name):
         name = name.upper()
         if name not in self.subscriptions:
-            raise MailboxException, "Not currently subscribed to " + name
+            raise MailboxException("Not currently subscribed to " + name)
         self.subscriptions.remove(name)
 
     def listMailboxes(self, ref, wildcard):
@@ -4968,7 +4970,7 @@
             the corresponding parameter value.
         """
         if self.attrs:
-            unquoted = [(k, unquote(v)) for (k, v) in self.attrs.iteritems()]
+            unquoted = [(k, unquote(v)) for (k, v) in self.attrs.items()]
             return [y for x in sorted(unquoted) for y in x]
         return None
 
@@ -5639,7 +5641,7 @@
 
 def _formatHeaders(headers):
     hdrs = [': '.join((k.title(), '\r\n'.join(v.splitlines()))) for (k, v)
-            in headers.iteritems()]
+            in headers.items()]
     hdrs = '\r\n'.join(hdrs) + '\r\n'
     return hdrs
 
@@ -5667,7 +5669,7 @@
     d = defer.Deferred()
     def go(last):
         try:
-            r = i.next()
+            r = next(i)
         except StopIteration:
             d.callback(last)
         except:
@@ -6042,7 +6044,7 @@
             raise Exception("Header list must end with )")
 
         headers = s[1:end].split()
-        self.pending_body.header.fields = map(str.upper, headers)
+        self.pending_body.header.fields = [h.upper() for h in headers]
         return end + 1
 
     def state_maybe_partial(self, s):
@@ -6120,26 +6122,32 @@
     }
     m = re.match('%(day)s-%(mon)s-%(year)s' % expr, s)
     if not m:
-        raise ValueError, "Cannot parse time string %r" % (s,)
+        raise ValueError("Cannot parse time string %r" % (s,))
     d = m.groupdict()
     try:
         d['mon'] = 1 + (months.index(d['mon'].lower()) % 12)
         d['year'] = int(d['year'])
         d['day'] = int(d['day'])
     except ValueError:
-        raise ValueError, "Cannot parse time string %r" % (s,)
+        raise ValueError("Cannot parse time string %r" % (s,))
     else:
         return time.struct_time(
             (d['year'], d['mon'], d['day'], 0, 0, 0, -1, -1, -1)
         )
 
 import codecs
+
+# we need to cast Python >=3.3 memoryview to chars (from unsigned bytes), but
+# cast is absent in previous versions: thus, the lambda returns the 
+# memoryview instance while ignoring the format
+memory_cast = getattr(memoryview, "cast", lambda *x: x[0])
+
 def modified_base64(s):
     s_utf7 = s.encode('utf-7')
-    return s_utf7[1:-1].replace('/', ',')
+    return s_utf7[1:-1].replace(b'/', b',')
 
 def modified_unbase64(s):
-    s_utf7 = '+' + s.replace(',', '/') + '-'
+    s_utf7 = b'+' + s.replace(b',', b'/') + b'-'
     return s_utf7.decode('utf-7')
 
 def encoder(s, errors=None):
@@ -6152,33 +6160,35 @@
 
     @param errors: Policy for handling encoding errors.  Currently ignored.
 
-    @return: C{tuple} of a C{str} giving the encoded bytes and an C{int}
+    @return: C{tuple} of a C{bytes} giving the encoded bytes and an C{int}
         giving the number of code units consumed from the input.
     """
-    r = []
+    r = bytearray()
     _in = []
+    valid_chars = set(map(chr, range(0x20,0x7f))) - {u"&"}
     for c in s:
-        if ord(c) in (range(0x20, 0x26) + range(0x27, 0x7f)):
-            if _in:
-                r.extend(['&', modified_base64(''.join(_in)), '-'])
-                del _in[:]
-            r.append(str(c))
-        elif c == '&':
-            if _in:
-                r.extend(['&', modified_base64(''.join(_in)), '-'])
-                del _in[:]
-            r.append('&-')
+        if c in valid_chars:
+            if _in:
+                r += b'&' + modified_base64(''.join(_in)) + b'-'
+                del _in[:]
+            r.append(ord(c))
+        elif c == u'&':
+            if _in:
+                r += b'&' + modified_base64(''.join(_in)) + b'-'
+                del _in[:]
+            r += b'&-'
         else:
             _in.append(c)
     if _in:
-        r.extend(['&', modified_base64(''.join(_in)), '-'])
-    return (''.join(r), len(s))
+        r.extend(b'&' + modified_base64(''.join(_in)) + b'-')
+    return (bytes(r), len(s))
+
 
 def decoder(s, errors=None):
     """
-    Decode the given C{str} using the IMAP4 specific variation of UTF-7.
+    Decode the given C{bytes} using the IMAP4 specific variation of UTF-7.
 
-    @type s: C{str}
+    @type s: C{bytes}
     @param s: The bytes to decode.
 
     @param errors: Policy for handling decoding errors.  Currently ignored.
@@ -6189,21 +6199,22 @@
     """
     r = []
     decode = []
+    s = memory_cast(memoryview(s), 'c')
     for c in s:
-        if c == '&' and not decode:
-            decode.append('&')
-        elif c == '-' and decode:
+        if c == b'&' and not decode:
+            decode.append(u'&')
+        elif c == b'-' and decode:
             if len(decode) == 1:
-                r.append('&')
+                r.append(u'&')
             else:
-                r.append(modified_unbase64(''.join(decode[1:])))
+                r.append(modified_unbase64(b''.join(decode[1:])))
             decode = []
         elif decode:
             decode.append(c)
         else:
-            r.append(c)
+            r.append(c.decode())
     if decode:
-        r.append(modified_unbase64(''.join(decode[1:])))
+        r.append(modified_unbase64(b''.join(decode[1:])))
     return (''.join(r), len(s))
 
 class StreamReader(codecs.StreamReader):

=== modified file 'twisted/mail/test/test_imap.py'
--- twisted/mail/test/test_imap.py	2013-01-25 22:30:32 +0000
+++ twisted/mail/test/test_imap.py	2013-01-31 20:50:06 +0000
@@ -7,17 +7,16 @@
 Test case for twisted.mail.imap4
 """
 
-try:
-    from cStringIO import StringIO
-except ImportError:
-    from StringIO import StringIO
+
+from io import StringIO, BytesIO
 
 import codecs
 import locale
 import os
 import types
+from itertools import chain
 
-from zope.interface import implements
+from zope.interface import implementer
 
 from twisted.mail.imap4 import MessageSet
 from twisted.mail import imap4
@@ -51,20 +50,20 @@
     l = l[:]
     l.sort()
     for i in range(len(l)):
-        if isinstance(l[i], types.ListType):
+        if isinstance(l[i], list):
             l[i] = sortNest(l[i])
-        elif isinstance(l[i], types.TupleType):
+        elif isinstance(l[i], tuple):
             l[i] = tuple(sortNest(list(l[i])))
     return l
 
 class IMAP4UTF7TestCase(unittest.TestCase):
     tests = [
-        [u'Hello world', 'Hello world'],
-        [u'Hello & world', 'Hello &- world'],
-        [u'Hello\xffworld', 'Hello&AP8-world'],
-        [u'\xff\xfe\xfd\xfc', '&AP8A,gD9APw-'],
+        [u'Hello world', b'Hello world'],
+        [u'Hello & world', b'Hello &- world'],
+        [u'Hello\xffworld', b'Hello&AP8-world'],
+        [u'\xff\xfe\xfd\xfc', b'&AP8A,gD9APw-'],
         [u'~peter/mail/\u65e5\u672c\u8a9e/\u53f0\u5317',
-         '~peter/mail/&ZeVnLIqe-/&U,BTFw-'], # example from RFC 2060
+         b'~peter/mail/&ZeVnLIqe-/&U,BTFw-'], # example from RFC 2060
     ]
 
     def test_encodeWithErrors(self):
@@ -81,9 +80,9 @@
 
     def test_decodeWithErrors(self):
         """
-        Similar to L{test_encodeWithErrors}, but for C{str.decode}.
+        Similar to L{test_encodeWithErrors}, but for C{bytes.decode}.
         """
-        bytes = 'Hello world'
+        bytes = b'Hello world'
         self.assertEqual(
             bytes.decode('imap4-utf-7', 'strict'),
             bytes.decode('imap4-utf-7'))
@@ -94,7 +93,7 @@
         C{codecs.getreader('imap4-utf-7')} returns the I{imap4-utf-7} stream
         reader class.
         """
-        reader = codecs.getreader('imap4-utf-7')(StringIO('Hello&AP8-world'))
+        reader = codecs.getreader('imap4-utf-7')(BytesIO(b'Hello&AP8-world'))
         self.assertEqual(reader.read(), u'Hello\xffworld')
 
 
@@ -103,10 +102,10 @@
         C{codecs.getwriter('imap4-utf-7')} returns the I{imap4-utf-7} stream
         writer class.
         """
-        output = StringIO()
+        output = BytesIO()
         writer = codecs.getwriter('imap4-utf-7')(output)
         writer.write(u'Hello\xffworld')
-        self.assertEqual(output.getvalue(), 'Hello&AP8-world')
+        self.assertEqual(output.getvalue(), b'Hello&AP8-world')
 
 
     def test_encode(self):
@@ -133,11 +132,12 @@
         characters which are in ASCII using the corresponding ASCII byte.
         """
         # All printables represent themselves
-        for o in range(0x20, 0x26) + range(0x27, 0x7f):
-            self.assertEqual(chr(o), chr(o).encode('imap4-utf-7'))
-            self.assertEqual(chr(o), chr(o).decode('imap4-utf-7'))
-        self.assertEqual('&'.encode('imap4-utf-7'), '&-')
-        self.assertEqual('&-'.decode('imap4-utf-7'), '&')
+        for o in chain(range(0x20, 0x26), range(0x27, 0x7f)):
+            charbyte = chr(o).encode()
+            self.assertEqual(charbyte, chr(o).encode('imap4-utf-7'))
+            self.assertEqual(chr(o), charbyte.decode('imap4-utf-7'))
+        self.assertEqual(u'&'.encode('imap4-utf-7'), b'&-')
+        self.assertEqual(b'&-'.decode('imap4-utf-7'), u'&')
 
 
 
@@ -290,7 +290,7 @@
     """
 
     def test_fileProducer(self):
-        b = (('x' * 1) + ('y' * 1) + ('z' * 1)) * 10
+        b = ((u'x' * 1) + (u'y' * 1) + (u'z' * 1)) * 10
         c = BufferingConsumer()
         f = StringIO(b)
         p = imap4.FileProducer(f)
@@ -727,7 +727,7 @@
 
     def test_files(self):
         inputStructure = [
-            'foo', 'bar', 'baz', StringIO('this is a file\r\n'), 'buz'
+            u'foo', u'bar', u'baz', StringIO(u'this is a file\r\n'), u'buz'
         ]
 
         output = '"foo" "bar" "baz" {16}\r\nthis is a file\r\n "buz"'
@@ -737,7 +737,7 @@
 
     def test_quoteAvoider(self):
         input = [
-            'foo', imap4.DontQuoteMe('bar'), "baz", StringIO('this is a file\r\n'),
+            'foo', imap4.DontQuoteMe('bar'), "baz", StringIO(u'this is a file\r\n'),
             imap4.DontQuoteMe('buz'), ""
         ]
 
@@ -969,8 +969,8 @@
                 self.assertEqual(L, expected,
                                   "len(%r) = %r != %r" % (input, L, expected))
 
+@implementer(imap4.IMailboxInfo, imap4.IMailbox, imap4.ICloseableMailbox)
 class SimpleMailbox:
-    implements(imap4.IMailboxInfo, imap4.IMailbox, imap4.ICloseableMailbox)
 
     flags = ('\\Flag1', 'Flag2', '\\AnotherSysFlag', 'LastFlag')
     messages = []
@@ -1351,9 +1351,7 @@
         self.assertEqual(self.result, [1] * len(succeed) + [0] * len(fail))
         mbox = SimpleServer.theAccount.mailboxes.keys()
         answers = ['inbox', 'testbox', 'test/box', 'test', 'test/box/box']
-        mbox.sort()
-        answers.sort()
-        self.assertEqual(mbox, [a.upper() for a in answers])
+        self.assertEqual(set(mbox), set(a.upper() for a in answers))
 
     def testDelete(self):
         SimpleServer.theAccount.addMailbox('delete/me')
@@ -1368,7 +1366,7 @@
         d2 = self.loopback()
         d = defer.gatherResults([d1, d2])
         d.addCallback(lambda _:
-                      self.assertEqual(SimpleServer.theAccount.mailboxes.keys(), []))
+                      self.assertFalse(SimpleServer.theAccount.mailboxes.keys()))
         return d
 
     def testIllegalInboxDelete(self):
@@ -1447,8 +1445,8 @@
         d2 = self.loopback()
         d = defer.gatherResults([d1, d2])
         d.addCallback(lambda _:
-                      self.assertEqual(SimpleServer.theAccount.mailboxes.keys(),
-                                        ['NEWNAME']))
+                      list(self.assertEqual(SimpleServer.theAccount.mailboxes.keys(),
+                                        ['NEWNAME'])))
         return d
 
     def testIllegalInboxRename(self):
@@ -1488,8 +1486,7 @@
     def _cbTestHierarchicalRename(self, ignored):
         mboxes = SimpleServer.theAccount.mailboxes.keys()
         expected = ['newname', 'newname/m1', 'newname/m2']
-        mboxes.sort()
-        self.assertEqual(mboxes, [s.upper() for s in expected])
+        self.assertEqual(set(mboxes), set(s.upper() for s in expected))
 
     def testSubscribe(self):
         def login():
@@ -3388,8 +3385,8 @@
     def sendServerGreeting(self):
         pass
 
+@implementer(imap4.IMessage)
 class FakeyMessage(util.FancyStrMixin):
-    implements(imap4.IMessage)
 
     showAttributes = ('headers', 'flags', 'date', 'body', 'uid')
 
@@ -3413,7 +3410,7 @@
         return self.date
 
     def getBodyFile(self):
-        return StringIO(self._body)
+        return BytesIO(self._body)
 
     def getSize(self):
         return self.size
@@ -3717,11 +3714,11 @@
     def fetch(self, messages, uid):
         self.received_messages = messages
         self.received_uid = uid
-        return iter(zip(range(len(self.msgObjs)), self.msgObjs))
+        return enumerate(self.msgObjs)
 
     def _fetchWork(self, uid):
         if uid:
-            for (i, msg) in zip(range(len(self.msgObjs)), self.msgObjs):
+            for (i, msg) in enumerate(self.msgObjs):
                 self.expected[i]['UID'] = str(msg.getUID())
 
         def result(R):
@@ -4248,7 +4245,7 @@
         """
         Pretend to be a mailbox and let C{self.server} lookup messages on me.
         """
-        return zip(range(1, len(self.msgObjs) + 1), self.msgObjs)
+        return list(enumerate(self.msgObjs, 1))
 
 
     def _messageSetSearchTest(self, queryTerms, expectedMessages):
@@ -4414,8 +4411,8 @@
 
 
 
+@implementer(imap4.ISearchableMailbox)
 class FetchSearchStoreTestCase(unittest.TestCase, IMAP4HelperMixin):
-    implements(imap4.ISearchableMailbox)
 
     def setUp(self):
         self.expected = self.result = None
@@ -4575,8 +4572,8 @@
         self.args.append((body, flags, date))
         return defer.succeed(None)
 
+@implementer(imap4.IMessageFile)
 class FeaturefulMessage:
-    implements(imap4.IMessageFile)
 
     def getFlags(self):
         return 'flags'
@@ -4585,10 +4582,10 @@
         return 'internaldate'
 
     def open(self):
-        return StringIO("open")
+        return StringIO(u"open")
 
+@implementer(imap4.IMessageCopier)
 class MessageCopierMailbox:
-    implements(imap4.IMessageCopier)
 
     def __init__(self):
         self.msgs = []
@@ -4635,7 +4632,7 @@
 
         m = FakeMailbox()
         msgs = [FakeyMessage({'Header-Counter': str(i)}, (), 'Date', 'Body %d' % (i,), i + 10, None) for i in range(1, 11)]
-        d = f([im for im in zip(range(1, 11), msgs)], 'tag', m)
+        d = f(list(enumerate(msgs, 1)), 'tag', m)
 
         def cbCopy(results):
             seen = []
@@ -4663,10 +4660,10 @@
 
         m = MessageCopierMailbox()
         msgs = [object() for i in range(1, 11)]
-        d = f([im for im in zip(range(1, 11), msgs)], 'tag', m)
+        d = f(enumerate(msgs, 1), 'tag', m)
 
         def cbCopy(results):
-            self.assertEqual(results, zip([1] * 10, range(1, 11)))
+            self.assertEqual(results, list(zip([1] * 10, range(1, 11))))
             for (orig, new) in zip(msgs, m.msgs):
                 self.assertIdentical(orig, new)
 
@@ -4702,7 +4699,8 @@
         self.client.requireTransportSecurity = True
 
         methods = [login, list, status, examine, logout]
-        map(self.connected.addCallback, map(strip, methods))
+        for meth in map(strip, methods):
+            self.connected.addCallback(meth)
         self.connected.addCallbacks(self._cbStopClient, self._ebGeneral)
         def check(ignored):
             self.assertEqual(self.server.startedTLS, True)
@@ -4833,7 +4831,7 @@
             self.assertNotEquals(self.server.state, 'timeout')
 
         def cbAdvance(ignored):
-            for i in xrange(4):
+            for i in range(4):
                 c.advance(.5)
 
         SlowMailbox.fetchDeferred.addCallback(cbAdvance)

=== modified file 'twisted/python/compat.py'
--- twisted/python/compat.py	2012-10-16 16:13:22 +0000
+++ twisted/python/compat.py	2013-01-31 13:19:13 +0000
@@ -256,6 +256,10 @@
     return klass
 
 
+if _PY3:
+    intTypes = int
+else:
+    intTypes = (int, long)
 
 if _PY3:
     unicode = str

=== modified file 'twisted/web/http.py'
--- twisted/web/http.py	2013-01-02 04:21:46 +0000
+++ twisted/web/http.py	2013-01-31 13:19:13 +0000
@@ -94,6 +94,7 @@
 from twisted.internet.defer import Deferred
 from twisted.protocols import policies, basic
 from twisted.python import log
+from twisted.python.compat import intTypes
 
 from twisted.web.http_headers import _DictHeaders, Headers
 
@@ -118,10 +119,6 @@
 
     RESPONSES)
 
-if _PY3:
-    _intTypes = int
-else:
-    _intTypes = (int, long)
 
 protocol_version = "HTTP/1.1"
 
@@ -1011,7 +1008,7 @@
         @type code: C{int}
         @type message: C{bytes}
         """
-        if not isinstance(code, _intTypes):
+        if not isinstance(code, intTypes):
             raise TypeError("HTTP response code must be int or long")
         self.code = code
         if message:

# Begin bundle
IyBCYXphYXIgcmV2aXNpb24gYnVuZGxlIHY0CiMKQlpoOTFBWSZTWdjgvvgAABJfgAAQQGFxUBIA
AACv794QIABkRTaajamQyGjTaRiFGgBMBBkwQhDmaVnH5r9hMFQyJ7EUzThiw4Ixc/mQVpexbPS2
9yLLTxaFbWvXcN2zcydOQxpD652acQC4g4Z96jI5BipgKAAiM5Zz45Kd/4u5IpwoSGxwX3wA
