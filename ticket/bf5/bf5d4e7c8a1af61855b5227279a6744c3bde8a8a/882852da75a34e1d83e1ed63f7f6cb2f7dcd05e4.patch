Index: twisted/python/filepath.py
===================================================================
--- twisted/python/filepath.py	(revision 25339)
+++ twisted/python/filepath.py	(working copy)
@@ -9,7 +9,10 @@
 import os
 import errno
 import random
-import sha
+try:
+    from hashlib import sha1 as sha
+except ImportError:
+    from sha import sha
 import base64
 
 from os.path import isabs, exists, normpath, abspath, splitext
@@ -120,7 +123,7 @@
     """
     Create a pseudorandom, 16-character string for use in secure filenames.
     """
-    return armor(sha.new(randomBytes(64)).digest())[:16]
+    return armor(sha(randomBytes(64)).digest())[:16]
 
 
 
Index: twisted/python/otp.py
===================================================================
--- twisted/python/otp.py	(revision 25339)
+++ twisted/python/otp.py	(working copy)
@@ -48,7 +48,11 @@
         l = l / 256L
     return result
         
-import md5, sha
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 hashid = {md5: 'md5', sha: 'sha1'}
 
 INITIALSEQUENCE = 1000
@@ -120,7 +124,7 @@
 
     def hashUpdate(self, digest):
         "Run through the hash and fold to 64 bit"
-        h = self.hash.new(digest)
+        h = self.hash(digest)
         return self.foldDigest(h.digest())
     
     def generateOTP(self, seed, passwd, sequence):
Index: twisted/python/test/test_zipstream.py
===================================================================
--- twisted/python/test/test_zipstream.py	(revision 25339)
+++ twisted/python/test/test_zipstream.py	(working copy)
@@ -6,7 +6,10 @@
 """
 import sys
 import random
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import zipfile
 
 from twisted.python import zipstream, filepath
@@ -347,7 +350,7 @@
         unzipIterChunky should unzip the given number of bytes per iteration.
         """
         junk = ' '.join([str(random.random()) for n in xrange(1000)])
-        junkmd5 = md5.new(junk).hexdigest()
+        junkmd5 = md5(junk).hexdigest()
 
         tempdir = filepath.FilePath(self.mktemp())
         tempdir.makedirs()
@@ -364,7 +367,7 @@
         for r in uziter:
             pass
         self.assertEqual(r, 0)
-        newmd5 = md5.new(
+        newmd5 = md5(
             tempdir.child("zipstreamjunk").open().read()).hexdigest()
         self.assertEqual(newmd5, junkmd5)
 
Index: twisted/protocols/sip.py
===================================================================
--- twisted/protocols/sip.py	(revision 25339)
+++ twisted/protocols/sip.py	(working copy)
@@ -14,7 +14,10 @@
 import socket
 import random
 import time
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import sys
 from zope.interface import implements, Interface
 
@@ -132,7 +135,7 @@
     pszNonce,
     pszCNonce,
 ):
-    m = md5.md5()
+    m = md5()
     m.update(pszUserName)
     m.update(":")
     m.update(pszRealm)
@@ -140,7 +143,7 @@
     m.update(pszPassword)
     HA1 = m.digest()
     if pszAlg == "md5-sess":
-        m = md5.md5()
+        m = md5()
         m.update(HA1)
         m.update(":")
         m.update(pszNonce)
@@ -159,7 +162,7 @@
     pszDigestUri,
     pszHEntity,
 ):
-    m = md5.md5()
+    m = md5()
     m.update(pszMethod)
     m.update(":")
     m.update(pszDigestUri)
@@ -168,7 +171,7 @@
         m.update(pszHEntity)
     HA2 = m.digest().encode('hex')
     
-    m = md5.md5()
+    m = md5()
     m.update(HA1)
     m.update(":")
     m.update(pszNonce)
Index: twisted/conch/test/test_transport.py
===================================================================
--- twisted/conch/test/test_transport.py	(revision 25339)
+++ twisted/conch/test/test_transport.py	(working copy)
@@ -5,7 +5,11 @@
 Tests for ssh/transport.py and the classes therein.
 """
 
-import md5, sha
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 
 try:
     import Crypto.Cipher.DES3
@@ -856,9 +860,9 @@
         """
         self.proto.sessionID = 'EF'
 
-        k1 = sha.new('AB' + 'CD'
+        k1 = sha('AB' + 'CD'
                      + 'K' + self.proto.sessionID).digest()
-        k2 = sha.new('ABCD' + k1).digest()
+        k2 = sha('ABCD' + k1).digest()
         self.assertEquals(self.proto._getKey('K', 'AB', 'CD'), k1 + k2)
 
 
@@ -1109,7 +1113,7 @@
         f = common._MPpow(transport.DH_GENERATOR, y, transport.DH_PRIME)
         sharedSecret = common._MPpow(e, y, transport.DH_PRIME)
 
-        h = sha.new()
+        h = sha()
         h.update(common.NS(self.proto.ourVersionString) * 2)
         h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.proto.factory.publicKeys['ssh-rsa'].blob()))
@@ -1190,7 +1194,7 @@
         y = common.getMP('\x00\x00\x00\x80' + '\x99' * 128)[0]
         f = common._MPpow(self.proto.g, y, self.proto.p)
         sharedSecret = common._MPpow(e, y, self.proto.p)
-        h = sha.new()
+        h = sha()
         h.update(common.NS(self.proto.ourVersionString) * 2)
         h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.proto.factory.publicKeys['ssh-rsa'].blob()))
@@ -1221,7 +1225,7 @@
         y = common.getMP('\x00\x00\x00\x80' + '\x99' * 128)[0]
         f = common._MPpow(self.proto.g, y, self.proto.p)
         sharedSecret = common._MPpow(e, y, self.proto.p)
-        h = sha.new()
+        h = sha()
         h.update(common.NS(self.proto.ourVersionString) * 2)
         h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.proto.factory.publicKeys['ssh-rsa'].blob()))
@@ -1360,7 +1364,7 @@
         self.calledVerifyHostKey = True
         self.assertEquals(pubKey, self.blob)
         self.assertEquals(fingerprint.replace(':', ''),
-                          md5.new(pubKey).hexdigest())
+                          md5(pubKey).hexdigest())
         return defer.succeed(True)
 
 
@@ -1427,7 +1431,7 @@
 
         sharedSecret = common._MPpow(transport.DH_GENERATOR,
                                      self.proto.x, transport.DH_PRIME)
-        h = sha.new()
+        h = sha()
         h.update(common.NS(self.proto.ourVersionString) * 2)
         h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.blob))
@@ -1476,7 +1480,7 @@
 
         self.test_KEX_DH_GEX_GROUP()
         sharedSecret = common._MPpow(3, self.proto.x, self.proto.p)
-        h = sha.new()
+        h = sha()
         h.update(common.NS(self.proto.ourVersionString) * 2)
         h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.blob))
Index: twisted/conch/test/test_keys.py
===================================================================
--- twisted/conch/test/test_keys.py	(revision 25339)
+++ twisted/conch/test/test_keys.py	(working copy)
@@ -12,7 +12,11 @@
 from twisted.conch.test import keydata
 from twisted.python import randbytes
 from twisted.trial import unittest
-import sha, os, base64
+import os, base64
+try:
+    from hashlib import sha1 as sha
+except ImportError:
+    from sha import sha
 
 class SSHKeysHandlingTestCase(unittest.TestCase):
     """
@@ -316,7 +320,7 @@
         messageSize = 6
         self.assertEquals(keys.pkcs1Pad(data, messageSize),
                 '\x01\xff\x00ABC')
-        hash = sha.new().digest()
+        hash = sha().digest()
         messageSize = 40
         self.assertEquals(keys.pkcs1Digest('', messageSize),
                 '\x01\xff\xff\xff\x00' + keys.ID_SHA1 + hash)
@@ -348,7 +352,7 @@
         """
         data = 'data'
         key, sig = self._signDSA(data)
-        sigData = sha.new(data).digest()
+        sigData = sha(data).digest()
         v = key.sign(sigData, '\x55' * 19)
         self.assertEquals(sig, common.NS('ssh-dss') + common.NS(
             Crypto.Util.number.long_to_bytes(v[0], 20) +
Index: twisted/conch/scripts/ckeygen.py
===================================================================
--- twisted/conch/scripts/ckeygen.py	(revision 25339)
+++ twisted/conch/scripts/ckeygen.py	(working copy)
@@ -10,7 +10,11 @@
 from twisted.conch.ssh import keys
 from twisted.python import log, usage, randbytes
 
-import sys, os, getpass, md5, socket
+import sys, os, getpass, socket
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 if getpass.getpass == getpass.unix_getpass:
     try:
         import termios # hack around broken termios
@@ -99,7 +103,7 @@
         obj = keys.getPublicKeyObject(string)
         print '%s %s %s' % (
             obj.size()+1,
-            ':'.join(['%02x' % ord(x) for x in md5.new(string).digest()]),
+            ':'.join(['%02x' % ord(x) for x in md5(string).digest()]),
             os.path.basename(options['filename']))
     except:
         sys.exit('bad key')
@@ -173,7 +177,7 @@
     print 'Your identification has been saved in %s' % options['filename']
     print 'Your public key has been saved in %s.pub' % options['filename']
     print 'The key fingerprint is:'
-    print ':'.join(['%02x' % ord(x) for x in md5.new(pubKey).digest()])
+    print ':'.join(['%02x' % ord(x) for x in md5(pubKey).digest()])
 
 if __name__ == '__main__':
     run()
Index: twisted/conch/ssh/transport.py
===================================================================
--- twisted/conch/ssh/transport.py	(revision 25339)
+++ twisted/conch/ssh/transport.py	(working copy)
@@ -13,8 +13,11 @@
 
 # base library imports
 import struct
-import md5
-import sha
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 import zlib
 import array
 
@@ -532,9 +535,9 @@
         @type sharedSecret: C{str}
         @type exchangeHash: C{str}
         """
-        k1 = sha.new(sharedSecret + exchangeHash + c + self.sessionID)
+        k1 = sha(sharedSecret + exchangeHash + c + self.sessionID)
         k1 = k1.digest()
-        k2 = sha.new(sharedSecret + exchangeHash + k1).digest()
+        k2 = sha(sharedSecret + exchangeHash + k1).digest()
         return k1 + k2
 
 
@@ -723,7 +726,7 @@
             y = Util.number.getRandomNumber(512, randbytes.secureRandom)
             serverDHpublicKey = _MPpow(DH_GENERATOR, y, DH_PRIME)
             sharedSecret = _MPpow(clientDHpublicKey, y, DH_PRIME)
-            h = sha.new()
+            h = sha()
             h.update(NS(self.otherVersionString))
             h.update(NS(self.ourVersionString))
             h.update(NS(self.otherKexInitPayload))
@@ -792,7 +795,7 @@
 
         serverDHpublicKey = _MPpow(self.g, y, self.p)
         sharedSecret = _MPpow(clientDHpublicKey, y, self.p)
-        h = sha.new()
+        h = sha()
         h.update(NS(self.otherVersionString))
         h.update(NS(self.ourVersionString))
         h.update(NS(self.otherKexInitPayload))
@@ -933,7 +936,7 @@
             f, packet = getMP(packet)
             signature, packet = getNS(packet)
             fingerprint = ':'.join([ch.encode('hex') for ch in
-                                    md5.new(pubKey).digest()])
+                                    md5(pubKey).digest()])
             d = self.verifyHostKey(pubKey, fingerprint)
             d.addCallback(self._continueKEXDH_REPLY, pubKey, f, signature)
             d.addErrback(
@@ -962,7 +965,7 @@
         """
         serverKey = keys.Key.fromString(pubKey)
         sharedSecret = _MPpow(f, self.x, DH_PRIME)
-        h = sha.new()
+        h = sha()
         h.update(NS(self.ourVersionString))
         h.update(NS(self.otherVersionString))
         h.update(NS(self.ourKexInitPayload))
@@ -992,7 +995,7 @@
         f, packet = getMP(packet)
         signature, packet = getNS(packet)
         fingerprint = ':'.join(map(lambda c: '%02x'%ord(c),
-            md5.new(pubKey).digest()))
+            md5(pubKey).digest()))
         d = self.verifyHostKey(pubKey, fingerprint)
         d.addCallback(self._continueGEX_REPLY, pubKey, f, signature)
         d.addErrback(
@@ -1015,7 +1018,7 @@
         """
         serverKey = keys.Key.fromString(pubKey)
         sharedSecret = _MPpow(f, self.x, self.p)
-        h = sha.new()
+        h = sha()
         h.update(NS(self.ourVersionString))
         h.update(NS(self.otherVersionString))
         h.update(NS(self.ourKexInitPayload))
@@ -1223,10 +1226,10 @@
             return _DummyCipher()
         mod = __import__('Crypto.Cipher.%s'%modName, {}, {}, 'x')
         if counterMode:
-            return mod.new(key[:keySize], mod.MODE_CTR, iv[:mod.block_size],
-                           counter=_Counter(iv, mod.block_size))
+            return mod(key[:keySize], mod.MODE_CTR, iv[:mod.block_size],
+                       counter=_Counter(iv, mod.block_size))
         else:
-            return mod.new(key[:keySize], mod.MODE_CBC, iv[:mod.block_size])
+            return mod(key[:keySize], mod.MODE_CBC, iv[:mod.block_size])
 
 
     def _getMAC(self, mac, key):
@@ -1244,9 +1247,9 @@
         if not mod:
             return (None, '', '', 0)
         #if not hasattr(mod, 'digest_size'):
-        #     ds = len(mod.new().digest())
+        #     ds = len(mod().digest())
         #else:
-        ds = mod.digest_size
+        ds = mod().digest_size
         key = key[:ds] + '\x00' * (64 - ds)
         i = XOR.new('\x36').encrypt(key)
         o = XOR.new('\x5c').encrypt(key)
@@ -1287,8 +1290,8 @@
             return ''
         data = struct.pack('>L', seqid) + data
         mod, i, o, ds = self.outMAC
-        inner = mod.new(i + data)
-        outer = mod.new(o + inner.digest())
+        inner = mod(i + data)
+        outer = mod(o + inner.digest())
         return outer.digest()
 
 
@@ -1309,8 +1312,8 @@
             return mac == ''
         data = struct.pack('>L', seqid) + data
         mod, i, o, ds = self.inMAC
-        inner = mod.new(i + data)
-        outer = mod.new(o + inner.digest())
+        inner = mod(i + data)
+        outer = mod(o + inner.digest())
         return mac == outer.digest()
 
 
Index: twisted/conch/ssh/keys.py
===================================================================
--- twisted/conch/ssh/keys.py	(revision 25339)
+++ twisted/conch/ssh/keys.py	(working copy)
@@ -12,7 +12,11 @@
 
 # base library imports
 import base64
-import sha, md5
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 import warnings
 
 # external library imports
@@ -207,8 +211,8 @@
                 len(ivdata), 2)])
             if not passphrase:
                 raise EncryptedKeyError('encrypted key with no passphrase')
-            ba = md5.new(passphrase + iv).digest()
-            bb = md5.new(ba + passphrase + iv).digest()
+            ba = md5(passphrase + iv).digest()
+            bb = md5(ba + passphrase + iv).digest()
             decKey = (ba + bb)[:24]
             b64Data = base64.decodestring(''.join(lines[3:-1]))
             keyData = DES3.new(decKey, DES3.MODE_CBC, iv).decrypt(b64Data)
@@ -575,8 +579,8 @@
                 hexiv = ''.join(['%02X' % ord(x) for x in iv])
                 lines.append('Proc-Type: 4,ENCRYPTED')
                 lines.append('DEK-Info: DES-EDE3-CBC,%s\n' % hexiv)
-                ba = md5.new(extra + iv).digest()
-                bb = md5.new(ba + extra + iv).digest()
+                ba = md5(extra + iv).digest()
+                bb = md5(ba + extra + iv).digest()
                 encKey = (ba + bb)[:24]
             asn1Data = asn1.pack([objData])
             if extra:
@@ -659,7 +663,7 @@
             signature = self.keyObject.sign(digest, '')[0]
             ret = common.NS(Util.number.long_to_bytes(signature))
         elif self.type() == 'DSA':
-            digest = sha.new(data).digest()
+            digest = sha(data).digest()
             randomBytes = randbytes.secureRandom(19)
             sig = self.keyObject.sign(digest, randomBytes)
             # SSH insists that the DSS signature blob be two 160-bit integers
@@ -688,7 +692,7 @@
             signature = common.getNS(signature)[0]
             numbers = [Util.number.bytes_to_long(n) for n in signature[:20],
                     signature[20:]]
-            digest = sha.new(data).digest()
+            digest = sha(data).digest()
         return self.keyObject.verify(digest, numbers)
 
 def getPublicKeyString(filename=None, line=0, data=''):
@@ -841,7 +845,7 @@
     @type data: C{str}
     @type messageLength: C{str}
     """
-    digest = sha.new(data).digest()
+    digest = sha(data).digest()
     return pkcs1Pad(ID_SHA1+digest, messageLength)
 
 def lenSig(obj):
Index: twisted/words/test/test_jabbercomponent.py
===================================================================
--- twisted/words/test/test_jabbercomponent.py	(revision 25339)
+++ twisted/words/test/test_jabbercomponent.py	(working copy)
@@ -5,7 +5,10 @@
 Tests for L{twisted.words.protocols.jabber.component}
 """
 
-import sha
+try:
+    from hashlib import sha1 as sha
+except ImportError:
+    from sha import sha
 
 from twisted.python import failure
 from twisted.trial import unittest
@@ -50,7 +53,7 @@
         handshake = self.output[-1]
         self.assertEquals('handshake', handshake.name)
         self.assertEquals('test:component', handshake.uri)
-        self.assertEquals(sha.new("%s%s" % ('12345', 'secret')).hexdigest(),
+        self.assertEquals(sha("%s%s" % ('12345', 'secret')).hexdigest(),
                           unicode(handshake))
 
         # successful authentication
@@ -80,7 +83,7 @@
         xs.dataReceived("<stream:stream xmlns='jabber:component:accept' xmlns:stream='http://etherx.jabber.org/streams' from='cjid' id='12345'>")
 
         # Calculate what we expect the handshake value to be
-        hv = sha.new("%s%s" % ("12345", "secret")).hexdigest()
+        hv = sha("%s%s" % ("12345", "secret")).hexdigest()
 
         self.assertEquals(outlist[1], "<handshake>%s</handshake>" % (hv))
 
Index: twisted/words/test/test_jabberclient.py
===================================================================
--- twisted/words/test/test_jabberclient.py	(revision 25339)
+++ twisted/words/test/test_jabberclient.py	(working copy)
@@ -5,7 +5,10 @@
 Tests for L{twisted.words.protocols.jabber.client}
 """
 
-import sha
+try:
+    from hashlib import sha1 as sha
+except ImportError:
+    from sha import sha
 from twisted.trial import unittest
 from twisted.words.protocols.jabber import client, error, jid, xmlstream
 from twisted.words.protocols.jabber.sasl import SASLInitiatingInitializer
@@ -117,7 +120,7 @@
         self.assertEquals(('jabber:iq:auth', 'query'),
                           (iq.children[0].uri, iq.children[0].name))
         self.assertEquals('user', unicode(iq.query.username))
-        self.assertEquals(sha.new('12345secret').hexdigest(),
+        self.assertEquals(sha('12345secret').hexdigest(),
                           unicode(iq.query.digest))
         self.assertEquals('resource', unicode(iq.query.resource))
 
Index: twisted/words/protocols/msn.py
===================================================================
--- twisted/words/protocols/msn.py	(revision 25339)
+++ twisted/words/protocols/msn.py	(working copy)
@@ -73,7 +73,11 @@
 @author: Sam Jordan
 """
 
-import types, operator, os, md5
+import types, operator, os
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 from random import randint
 from urllib import quote, unquote
 
@@ -856,7 +860,7 @@
     def handle_CHL(self, params):
         checkParamLen(len(params), 2, 'CHL')
         self.sendLine("QRY %s msmsgs@msnmsgr.com 32" % self._nextTransactionID())
-        self.transport.write(md5.md5(params[1] + MSN_CHALLENGE_STR).hexdigest())
+        self.transport.write(md5(params[1] + MSN_CHALLENGE_STR).hexdigest())
 
     def handle_QRY(self, params):
         pass
Index: twisted/words/protocols/jabber/sasl_mechanisms.py
===================================================================
--- twisted/words/protocols/jabber/sasl_mechanisms.py	(revision 25339)
+++ twisted/words/protocols/jabber/sasl_mechanisms.py	(working copy)
@@ -7,7 +7,11 @@
 Protocol agnostic implementations of SASL authentication mechanisms.
 """
 
-import md5, binascii, random, time, os
+import binascii, random, time, os
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 
 from zope.interface import Interface, Attribute, implements
 
@@ -178,7 +182,7 @@
         """
 
         def H(s):
-            return md5.new(s).digest()
+            return md5(s).digest()
 
         def HEX(n):
             return binascii.b2a_hex(n)
@@ -221,4 +225,4 @@
 
 
     def _gen_nonce(self):
-        return md5.new("%s:%s:%s" % (str(random.random()) , str(time.gmtime()),str(os.getpid()))).hexdigest()
+        return md5("%s:%s:%s" % (str(random.random()) , str(time.gmtime()),str(os.getpid()))).hexdigest()
Index: twisted/words/protocols/jabber/xmlstream.py
===================================================================
--- twisted/words/protocols/jabber/xmlstream.py	(revision 25339)
+++ twisted/words/protocols/jabber/xmlstream.py	(working copy)
@@ -42,8 +42,11 @@
     """
     Create a SHA1-digest string of a session identifier and password.
     """
-    import sha
-    return sha.new("%s%s" % (sid, password)).hexdigest()
+    try:
+        from hashlib import sha1 as sha
+    except ImportError:
+        from sha import sha
+    return sha("%s%s" % (sid, password)).hexdigest()
 
 
 
Index: twisted/words/protocols/oscar.py
===================================================================
--- twisted/words/protocols/oscar.py	(revision 25339)
+++ twisted/words/protocols/oscar.py	(working copy)
@@ -15,7 +15,10 @@
 from twisted.python import log
 
 import struct
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import string
 import socket
 import random
@@ -62,9 +65,9 @@
     return dict,data
 
 def encryptPasswordMD5(password,key):
-    m=md5.new()
+    m=md5()
     m.update(key)
-    m.update(md5.new(password).digest())
+    m.update(md5(password).digest())
     m.update("AOL Instant Messenger (SM)")
     return m.digest()
 
Index: twisted/web2/test/test_httpauth.py
===================================================================
--- twisted/web2/test/test_httpauth.py	(revision 25339)
+++ twisted/web2/test/test_httpauth.py	(working copy)
@@ -1,4 +1,7 @@
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 from twisted.internet import address
 from twisted.trial import unittest
 from twisted.cred import error
@@ -263,10 +266,10 @@
         creds = self.credentialFactory.decode(clientResponse, _trivial_GET)
 
         self.failUnless(creds.checkHash(
-                md5.md5('username:test realm:password').hexdigest()))
+                md5('username:test realm:password').hexdigest()))
 
         self.failIf(creds.checkHash(
-                md5.md5('username:test realm:bogus').hexdigest()))
+                md5('username:test realm:bogus').hexdigest()))
 
     def test_invalidOpaque(self):
         """
@@ -364,7 +367,7 @@
         key = '%s,%s,%s' % (challenge['nonce'],
                             clientAddress.host,
                             '-137876876')
-        digest = md5.new(key + credentialFactory.privateKey).hexdigest()
+        digest = md5(key + credentialFactory.privateKey).hexdigest()
         ekey = key.encode('base64')
 
         oldNonceOpaque = '%s-%s' % (digest, ekey.strip('\n'))
@@ -390,7 +393,7 @@
                             clientAddress.host,
                             '0')
 
-        digest = md5.new(key + 'this is not the right pkey').hexdigest()
+        digest = md5(key + 'this is not the right pkey').hexdigest()
 
         badChecksum = '%s-%s' % (digest,
                                  key.encode('base64').strip('\n'))
Index: twisted/web2/server.py
===================================================================
--- twisted/web2/server.py	(revision 25339)
+++ twisted/web2/server.py	(working copy)
@@ -522,7 +522,7 @@
     def _cbFinishRender(self, result):
         def filterit(response, f):
             if (hasattr(f, 'handleErrors') or
-                (response.code >= 200 and response.code < 300 and response.code != 204)):
+                (response.code >= 200 and response.code < 300)):
                 return f(self, response)
             else:
                 return response
Index: twisted/web2/auth/digest.py
===================================================================
--- twisted/web2/auth/digest.py	(revision 25339)
+++ twisted/web2/auth/digest.py	(working copy)
@@ -12,15 +12,19 @@
 
 from twisted.web2.auth.interfaces import ICredentialFactory
 
-import md5, sha
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 import random, sys
 
 # The digest math
 
 algorithms = {
-    'md5': md5.new,
-    'md5-sess': md5.new,
-    'sha': sha.new,
+    'md5': md5,
+    'md5-sess': md5,
+    'sha': sha,
 }
 
 # DigestCalcHA1
@@ -228,7 +232,7 @@
         # Now, what we do is encode the nonce, client ip and a timestamp
         # in the opaque value with a suitable digest
         key = "%s,%s,%s" % (nonce, clientip, str(int(self._getTime())))
-        digest = md5.new(key + self.privateKey).hexdigest()
+        digest = md5(key + self.privateKey).hexdigest()
         ekey = key.encode('base64')
         return "%s-%s" % (digest, ekey.strip('\n'))
 
@@ -275,7 +279,7 @@
                 'Invalid response, incompatible opaque/nonce too old')
 
         # Verify the digest
-        digest = md5.new(key + self.privateKey).hexdigest()
+        digest = md5(key + self.privateKey).hexdigest()
         if digest != opaqueParts[0]:
             raise error.LoginFailed('Invalid response, invalid opaque value')
 
Index: twisted/web2/static.py
===================================================================
--- twisted/web2/static.py	(revision 25339)
+++ twisted/web2/static.py	(working copy)
@@ -9,7 +9,6 @@
 # System Imports
 import os, time, stat
 import tempfile
-import md5
 
 # Sibling Imports
 from twisted.web2 import http_headers, resource
Index: twisted/persisted/sob.py
===================================================================
--- twisted/persisted/sob.py	(revision 25339)
+++ twisted/persisted/sob.py	(working copy)
@@ -9,8 +9,12 @@
 Maintainer: Moshe Zadka
 """
 
-import os, md5, sys
+import os, sys
 try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
+try:
     import cPickle as pickle
 except ImportError:
     import pickle
@@ -31,11 +35,11 @@
     leftover = len(data) % cipher.block_size
     if leftover:
         data += ' '*(cipher.block_size - leftover)
-    return cipher.new(md5.new(passphrase).digest()[:16]).encrypt(data)
+    return cipher.new(md5(passphrase).digest()[:16]).encrypt(data)
 
 def _decrypt(passphrase, data):
     from Crypto.Cipher import AES
-    return AES.new(md5.new(passphrase).digest()[:16]).decrypt(data)
+    return AES.new(md5(passphrase).digest()[:16]).decrypt(data)
 
 
 class IPersistable(Interface):
Index: twisted/news/database.py
===================================================================
--- twisted/news/database.py	(revision 25339)
+++ twisted/news/database.py	(working copy)
@@ -21,7 +21,11 @@
 from twisted.enterprise import adbapi
 from twisted.persisted import dirdbm
 
-import getpass, pickle, time, socket, md5
+import getpass, pickle, time, socket
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import os
 import StringIO
 from zope.interface import implements, Interface
@@ -53,7 +57,7 @@
 
         if not self.getHeader('Message-ID'):
             s = str(time.time()) + self.body
-            id = hexdigest(md5.md5(s)) + '@' + socket.gethostname()
+            id = hexdigest(md5(s)) + '@' + socket.gethostname()
             self.putHeader('Message-ID', '<%s>' % id)
 
         if not self.getHeader('Bytes'):
Index: twisted/web/server.py
===================================================================
--- twisted/web/server.py	(revision 25339)
+++ twisted/web/server.py	(working copy)
@@ -507,9 +507,13 @@
         """
         (internal) Generate an opaque, unique ID for a user's session.
         """
-        import md5, random
+        try:
+            from hashlib import md5
+        except ImportError:
+            from md5 import md5
+        import random
         self.counter = self.counter + 1
-        return md5.new("%s_%s" % (str(random.random()) , str(self.counter))).hexdigest()
+        return md5("%s_%s" % (str(random.random()) , str(self.counter))).hexdigest()
 
     def makeSession(self):
         """
Index: twisted/web/test/test_httpauth.py
===================================================================
--- twisted/web/test/test_httpauth.py	(revision 25339)
+++ twisted/web/test/test_httpauth.py	(working copy)
@@ -5,7 +5,11 @@
 Tests for L{twisted.web._auth}.
 """
 
-import md5, sha
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 
 from zope.interface import implements
 from zope.interface.verify import verifyObject
@@ -181,7 +185,7 @@
             self.algorithm, self.realm)
 
 
-    def test_MD5HashA1(self, _algorithm='md5', _hash=md5.md5):
+    def test_MD5HashA1(self, _algorithm='md5', _hash=md5):
         """
         L{calcHA1} accepts the C{'md5'} algorithm and returns an MD5 hash of
         its parameters, excluding the nonce and cnonce.
@@ -203,9 +207,9 @@
         hashA1 = calcHA1('md5-sess', self.username, self.realm, self.password,
                          nonce, self.cnonce)
         a1 = '%s:%s:%s' % (self.username, self.realm, self.password)
-        ha1 = md5.md5(a1).digest()
+        ha1 = md5(a1).digest()
         a1 = '%s:%s:%s' % (ha1, nonce, self.cnonce)
-        expected = md5.md5(a1).hexdigest()
+        expected = md5(a1).hexdigest()
         self.assertEqual(hashA1, expected)
 
 
@@ -214,10 +218,10 @@
         L{calcHA1} accepts the C{'sha'} algorithm and returns a SHA hash of its
         parameters, excluding the nonce and cnonce.
         """
-        self.test_MD5HashA1('sha', sha.sha)
+        self.test_MD5HashA1('sha', sha)
 
 
-    def test_MD5HashA2Auth(self, _algorithm='md5', _hash=md5.md5):
+    def test_MD5HashA2Auth(self, _algorithm='md5', _hash=md5):
         """
         L{calcHA2} accepts the C{'md5'} algorithm and returns an MD5 hash of
         its arguments, excluding the entity hash for QOP other than
@@ -230,7 +234,7 @@
         self.assertEqual(hashA2, expected)
 
 
-    def test_MD5HashA2AuthInt(self, _algorithm='md5', _hash=md5.md5):
+    def test_MD5HashA2AuthInt(self, _algorithm='md5', _hash=md5):
         """
         L{calcHA2} accepts the C{'md5'} algorithm and returns an MD5 hash of
         its arguments, including the entity hash for QOP of C{'auth-int'}.
@@ -265,7 +269,7 @@
         its arguments, excluding the entity hash for QOP other than
         C{'auth-int'}.
         """
-        self.test_MD5HashA2Auth('sha', sha.sha)
+        self.test_MD5HashA2Auth('sha', sha)
 
 
     def test_SHAHashA2AuthInt(self):
@@ -273,10 +277,10 @@
         L{calcHA2} accepts the C{'sha'} algorithm and returns a SHA hash of
         its arguments, including the entity hash for QOP of C{'auth-int'}.
         """
-        self.test_MD5HashA2AuthInt('sha', sha.sha)
+        self.test_MD5HashA2AuthInt('sha', sha)
 
 
-    def test_MD5HashResponse(self, _algorithm='md5', _hash=md5.md5):
+    def test_MD5HashResponse(self, _algorithm='md5', _hash=md5):
         """
         L{calcResponse} accepts the C{'md5'} algorithm and returns an MD5 hash
         of its parameters, excluding the nonce count, client nonce, and QoP
@@ -308,10 +312,10 @@
         of its parameters, excluding the nonce count, client nonce, and QoP
         value if the nonce count and client nonce are C{None}
         """
-        self.test_MD5HashResponse('sha', sha.sha)
+        self.test_MD5HashResponse('sha', sha)
 
 
-    def test_MD5HashResponseExtra(self, _algorithm='md5', _hash=md5.md5):
+    def test_MD5HashResponseExtra(self, _algorithm='md5', _hash=md5):
         """
         L{calcResponse} accepts the C{'md5'} algorithm and returns an MD5 hash
         of its parameters, including the nonce count, client nonce, and QoP
@@ -348,7 +352,7 @@
         of its parameters, including the nonce count, client nonce, and QoP
         value if they are specified.
         """
-        self.test_MD5HashResponseExtra('sha', sha.sha)
+        self.test_MD5HashResponseExtra('sha', sha)
 
 
     def makeRequest(self, method='GET', clientAddress=None):
@@ -639,7 +643,7 @@
         self.assertTrue(verifyObject(IUsernameDigestHash, creds))
 
         cleartext = '%s:%s:%s' % (self.username, self.realm, self.password)
-        hash = md5.md5(cleartext)
+        hash = md5(cleartext)
         self.assertTrue(creds.checkHash(hash.hexdigest()))
         hash.update('wrong')
         self.assertFalse(creds.checkHash(hash.hexdigest()))
@@ -761,7 +765,7 @@
         key = '%s,%s,%s' % (challenge['nonce'],
                             self.clientAddress.host,
                             '-137876876')
-        digest = md5.md5(key + credentialFactory.privateKey).hexdigest()
+        digest = md5(key + credentialFactory.privateKey).hexdigest()
         ekey = b64encode(key)
 
         oldNonceOpaque = '%s-%s' % (digest, ekey.strip('\n'))
@@ -786,7 +790,7 @@
                             self.clientAddress.host,
                             '0')
 
-        digest = md5.md5(key + 'this is not the right pkey').hexdigest()
+        digest = md5(key + 'this is not the right pkey').hexdigest()
         badChecksum = '%s-%s' % (digest, b64encode(key))
 
         self.assertRaises(
Index: twisted/web/woven/guard.py
===================================================================
--- twisted/web/woven/guard.py	(revision 25339)
+++ twisted/web/woven/guard.py	(working copy)
@@ -16,7 +16,10 @@
 
 import random
 import time
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import urllib
 
 # Twisted Imports
@@ -29,7 +32,7 @@
 from twisted.cred.error import LoginFailed, UnauthorizedLogin
 
 def _sessionCookie():
-    return md5.new("%s_%s" % (str(random.random()) , str(time.time()))).hexdigest()
+    return md5("%s_%s" % (str(random.random()) , str(time.time()))).hexdigest()
 
 class GuardSession(components.Componentized):
     """A user's session with a system.
Index: twisted/web/_auth/digest.py
===================================================================
--- twisted/web/_auth/digest.py	(revision 25339)
+++ twisted/web/_auth/digest.py	(working copy)
@@ -9,7 +9,11 @@
 """
 
 import time
-import md5, sha
+try:
+    from hashlib import md5, sha1 as sha
+except ImportError:
+    from md5 import md5
+    from sha import sha
 
 from zope.interface import implements
 
@@ -21,7 +25,7 @@
 # The digest math
 
 algorithms = {
-    'md5': md5.new,
+    'md5': md5,
 
     # md5-sess is more complicated than just another algorithm.  It requires
     # H(A1) state to be remembered from the first WWW-Authenticate challenge
@@ -30,9 +34,9 @@
     # recalculate H(A1) each time an Authorization header is received.  Read
     # RFC 2617, section 3.2.2.2 and do not try to make DigestCredentialFactory
     # support this unless you completely understand it. -exarkun
-    'md5-sess': md5.new,
+    'md5-sess': md5,
 
-    'sha': sha.new,
+    'sha': sha,
 }
 
 # DigestCalcHA1
@@ -257,7 +261,7 @@
         if clientip is None:
             clientip = ''
         key = "%s,%s,%s" % (nonce, clientip, now)
-        digest = md5.new(key + self.privateKey).hexdigest()
+        digest = md5(key + self.privateKey).hexdigest()
         ekey = key.encode('base64')
         return "%s-%s" % (digest, ekey.strip('\n'))
 
@@ -315,7 +319,7 @@
                 'Invalid response, incompatible opaque/nonce too old')
 
         # Verify the digest
-        digest = md5.new(key + self.privateKey).hexdigest()
+        digest = md5(key + self.privateKey).hexdigest()
         if digest != opaqueParts[0]:
             raise error.LoginFailed('Invalid response, invalid opaque value')
 
Index: twisted/web/monitor.py
===================================================================
--- twisted/web/monitor.py	(revision 25339)
+++ twisted/web/monitor.py	(working copy)
@@ -4,7 +4,10 @@
 #
 from twisted.web import client
 from twisted.internet import reactor
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 from zope.interface import implements
 
 class IChangeNotified:
@@ -53,7 +56,7 @@
     def page(self, p):
         if p is None:
             return self.gotMD5(None)
-        m = md5.new()
+        m = md5()
         m.update(p)
         self.gotMD5(m.digest())
 
Index: twisted/cred/util.py
===================================================================
--- twisted/cred/util.py	(revision 25339)
+++ twisted/cred/util.py	(working copy)
@@ -12,7 +12,10 @@
 """
 
 # System Imports
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import random
 
 from twisted.cred.error import Unauthorized
@@ -21,10 +24,10 @@
     """Respond to a challenge.
     This is useful for challenge/response authentication.
     """
-    m = md5.new()
+    m = md5()
     m.update(password)
     hashedPassword = m.digest()
-    m = md5.new()
+    m = md5()
     m.update(hashedPassword)
     m.update(challenge)
     doubleHashedPassword = m.digest()
@@ -36,5 +39,5 @@
     crap = ''
     for x in range(random.randrange(15,25)):
         crap = crap + chr(random.randint(65,90))
-    crap = md5.new(crap).digest()
+    crap = md5(crap).digest()
     return crap
Index: twisted/mail/test/test_mail.py
===================================================================
--- twisted/mail/test/test_mail.py	(revision 25339)
+++ twisted/mail/test/test_mail.py	(working copy)
@@ -7,7 +7,10 @@
 
 import os
 import errno
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import shutil
 import pickle
 import StringIO
@@ -587,7 +590,7 @@
         shutil.rmtree(self.tmpdir)
 
     def testAuthenticateAPOP(self):
-        resp = md5.new(self.P.magic + 'password').hexdigest()
+        resp = md5(self.P.magic + 'password').hexdigest()
         return self.P.authenticateUserAPOP('user', resp
             ).addCallback(self._cbAuthenticateAPOP
             )
@@ -599,13 +602,13 @@
         result[2]()
 
     def testAuthenticateIncorrectUserAPOP(self):
-        resp = md5.new(self.P.magic + 'password').hexdigest()
+        resp = md5(self.P.magic + 'password').hexdigest()
         return self.assertFailure(
             self.P.authenticateUserAPOP('resu', resp),
             cred.error.UnauthorizedLogin)
 
     def testAuthenticateIncorrectResponseAPOP(self):
-        resp = md5.new('wrong digest').hexdigest()
+        resp = md5('wrong digest').hexdigest()
         return self.assertFailure(
             self.P.authenticateUserAPOP('user', resp),
             cred.error.UnauthorizedLogin)
Index: twisted/mail/pop3client.py
===================================================================
--- twisted/mail/pop3client.py	(revision 25339)
+++ twisted/mail/pop3client.py	(working copy)
@@ -10,7 +10,11 @@
 @author: Jp Calderone
 """
 
-import re, md5
+import re
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 
 from twisted.python import log
 from twisted.internet import defer
@@ -485,7 +489,7 @@
     def _apop(self, username, password, challenge):
         # Internal helper.  Computes and sends an APOP response.  Returns
         # a Deferred that fires when the server responds to the response.
-        digest = md5.new(challenge + password).hexdigest()
+        digest = md5(challenge + password).hexdigest()
         return self.apop(username, digest)
 
     def apop(self, username, digest):
Index: twisted/mail/maildir.py
===================================================================
--- twisted/mail/maildir.py	(revision 25339)
+++ twisted/mail/maildir.py	(working copy)
@@ -12,7 +12,10 @@
 import stat
 import socket
 import time
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import cStringIO
 
 from zope.interface import implements
@@ -298,7 +301,7 @@
         """
         # Returning the actual filename is a mistake.  Hash it.
         base = os.path.basename(self.list[i])
-        return md5.md5(base).hexdigest()
+        return md5(base).hexdigest()
 
     def deleteMessage(self, i):
         """Delete a message
@@ -355,7 +358,7 @@
         return StringIO.StringIO(self.msgs[i])
 
     def getUidl(self, i):
-        return md5.new(self.msgs[i]).hexdigest()
+        return md5(self.msgs[i]).hexdigest()
 
     def deleteMessage(self, i):
         pass
Index: twisted/mail/pop3.py
===================================================================
--- twisted/mail/pop3.py	(revision 25339)
+++ twisted/mail/pop3.py	(working copy)
@@ -14,7 +14,10 @@
 import string
 import base64
 import binascii
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import warnings
 
 from zope.interface import implements, Interface
@@ -44,7 +47,7 @@
 
     def checkPassword(self, password):
         seed = self.magic + password
-        myDigest = md5.new(seed).hexdigest()
+        myDigest = md5(seed).hexdigest()
         return myDigest == self.digest
 
 
@@ -1031,7 +1034,7 @@
             self._dispatch(self.command+"_continue", None, line)
 
     def apopAuthenticate(self, user, password, magic):
-        digest = md5.new(magic + password).hexdigest()
+        digest = md5(magic + password).hexdigest()
         self.apop(user, digest)
 
     def apop(self, user, digest):
Index: twisted/internet/_sslverify.py
===================================================================
--- twisted/internet/_sslverify.py	(revision 25339)
+++ twisted/internet/_sslverify.py	(working copy)
@@ -1,7 +1,11 @@
 # -*- test-case-name: twisted.test.test_sslverify -*-
 # Copyright 2005 Divmod, Inc.  See LICENSE file for details
 
-import itertools, md5
+import itertools
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 from OpenSSL import SSL, crypto
 
 from twisted.python import reflect, util
@@ -451,7 +455,7 @@
         MD5 hex digest of signature on an empty certificate request with this
         key.
         """
-        return md5.md5(self._emptyReq).hexdigest()
+        return md5(self._emptyReq).hexdigest()
 
 
     def inspect(self):
@@ -725,7 +729,7 @@
             ctx.set_options(self._OP_ALL)
 
         if self.enableSessions:
-            sessionName = md5.md5("%s-%d" % (reflect.qual(self.__class__), _sessionCounter())).hexdigest()
+            sessionName = md5("%s-%d" % (reflect.qual(self.__class__), _sessionCounter())).hexdigest()
             ctx.set_session_id(sessionName)
 
         return ctx
Index: twisted/trial/test/test_loader.py
===================================================================
--- twisted/trial/test/test_loader.py	(revision 25339)
+++ twisted/trial/test/test_loader.py	(working copy)
@@ -5,7 +5,10 @@
 Tests for loading tests by name.
 """
 
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import os
 import shutil
 import sys
@@ -484,7 +487,7 @@
 #             if isinstance(s, type) or isinstance(s, types.ClassType):
 #                 return s.__module__+'.'+s.__name__
             n = runner.name(s)
-            d = md5.new(n).hexdigest()
+            d = md5(n).hexdigest()
             return d
         self.loadSortedPackages(sillySorter)
 
Index: twisted/spread/pb.py
===================================================================
--- twisted/spread/pb.py	(revision 25339)
+++ twisted/spread/pb.py	(working copy)
@@ -27,7 +27,10 @@
 @author: Glyph Lefkowitz
 """
 
-import md5
+try:
+    from hashlib import md5
+except ImportError:
+    from md5 import md5
 import random
 import new
 import types
@@ -997,10 +1000,10 @@
 
     This is useful for challenge/response authentication.
     """
-    m = md5.new()
+    m = md5()
     m.update(password)
     hashedPassword = m.digest()
-    m = md5.new()
+    m = md5()
     m.update(hashedPassword)
     m.update(challenge)
     doubleHashedPassword = m.digest()
@@ -1011,7 +1014,7 @@
     crap = ''
     for x in range(random.randrange(15,25)):
         crap = crap + chr(random.randint(65,90))
-    crap = md5.new(crap).digest()
+    crap = md5(crap).digest()
     return crap
 
 
@@ -1340,12 +1343,12 @@
 
     # IUsernameHashedPassword:
     def checkPassword(self, password):
-        return self.checkMD5Password(md5.md5(password).digest())
+        return self.checkMD5Password(md5(password).digest())
 
 
     # IUsernameMD5Password
     def checkMD5Password(self, md5Password):
-        md = md5.new()
+        md = md5()
         md.update(md5Password)
         md.update(self.challenge)
         correct = md.digest()
