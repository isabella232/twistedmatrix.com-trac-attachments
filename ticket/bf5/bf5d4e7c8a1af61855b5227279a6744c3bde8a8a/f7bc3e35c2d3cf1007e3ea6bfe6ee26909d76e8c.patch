Index: twisted/python/filepath.py
===================================================================
--- twisted/python/filepath.py	(revision 22614)
+++ twisted/python/filepath.py	(working copy)
@@ -9,7 +9,7 @@
 import os
 import errno
 import random
-import sha
+import hashlib
 import base64
 
 from os.path import isabs, exists, normpath, abspath, splitext
@@ -109,7 +109,7 @@
     """
     Create a pseudorandom, 16-character string for use in secure filenames.
     """
-    return armor(sha.new(randomBytes(64)).digest())[:16]
+    return armor(hashlib.sha1(randomBytes(64)).digest())[:16]
 
 class _PathHelper:
     """
Index: twisted/python/otp.py
===================================================================
--- twisted/python/otp.py	(revision 22614)
+++ twisted/python/otp.py	(working copy)
@@ -47,8 +47,8 @@
         result = chr(l % 256) + result
         l = l / 256L
     return result
-        
-import md5, sha
+
+from hashlib import md5 as md5, sha1 as sha
 hashid = {md5: 'md5', sha: 'sha1'}
 
 INITIALSEQUENCE = 1000
@@ -56,24 +56,24 @@
 
 class Unauthorized(Exception):
     """the Unauthorized exception
-    
+
     This exception is raised when an action is not allowed, or a user is not
     authenticated properly.
     """
 
 class OTPAuthenticator:
     """A One Time Password System
-    
+
     Based on RFC 2289, which is based on a the S/KEY Authentication-scheme.
     It uses the MD5- and SHA-algorithms for hashing
-    
+
     The variable OTP is at all times a 64bit string"""
 
     def __init__(self, hash = md5):
         "Set the hash to either md5 or sha1"
         self.hash = hash
         pass
-    
+
     def generateSeed(self):
         "Return a 10 char random seed, with 6 lowercase chars and 4 digits"
         seed = ''
@@ -88,7 +88,7 @@
             return self.foldDigest128(otp)
         if self.hash == sha:
             return self.foldDigest160(otp)
-    
+
     def foldDigest128(self, otp128):
         "Fold a 128 bit digest to 64 bit"
         regs = stringToDWords(otp128)
@@ -122,7 +122,7 @@
         "Run through the hash and fold to 64 bit"
         h = self.hash.new(digest)
         return self.foldDigest(h.digest())
-    
+
     def generateOTP(self, seed, passwd, sequence):
         """Return a 64 bit OTP based on inputs
         Run through makeReadable to get a 6 word pass-phrase"""
@@ -138,7 +138,7 @@
         for i in xrange(0, 64, 2):
             parity = parity + otp & 0x3
             otp = otp >> 2
-        return parity        
+        return parity
 
     def makeReadable(self, otp):
         "Returns a 6 word pass-phrase from a 64bit OTP"
@@ -151,7 +151,7 @@
         return string.join(list)
 
     def challenge(self, seed, sequence):
-        """Return a challenge in the format otp-<hash> <sequence> <seed>"""  
+        """Return a challenge in the format otp-<hash> <sequence> <seed>"""
         return "otp-%s %i %s" % (hashid[self.hash], sequence, seed)
 
     def parsePhrase(self, phrase):
@@ -178,9 +178,9 @@
     On the next authentication, the stored password is hashed and checked
     up against the one given by the user. If they match, the sequencecounter
     is decreased and the circle is closed.
-    
+
     This object should be glued to each user
-    
+
     Note:
     It does NOT reset the sequence when the combinations left approach zero,
     This has to be done manuelly by instancing a new object
Index: twisted/python/test/test_zipstream.py
===================================================================
--- twisted/python/test/test_zipstream.py	(revision 22614)
+++ twisted/python/test/test_zipstream.py	(working copy)
@@ -6,7 +6,7 @@
 """
 import sys
 import random
-import md5
+import hashlib
 import zipfile
 
 from twisted.python import zipstream, filepath
@@ -347,7 +347,7 @@
         unzipIterChunky should unzip the given number of bytes per iteration.
         """
         junk = ' '.join([str(random.random()) for n in xrange(1000)])
-        junkmd5 = md5.new(junk).hexdigest()
+        junkmd5 = hashlib.md5(junk).hexdigest()
 
         tempdir = filepath.FilePath(self.mktemp())
         tempdir.makedirs()
@@ -364,7 +364,7 @@
         for r in uziter:
             pass
         self.assertEqual(r, 0)
-        newmd5 = md5.new(
+        newmd5 = hashlib.md5(
             tempdir.child("zipstreamjunk").open().read()).hexdigest()
         self.assertEqual(newmd5, junkmd5)
 
Index: twisted/protocols/sip.py
===================================================================
--- twisted/protocols/sip.py	(revision 22614)
+++ twisted/protocols/sip.py	(working copy)
@@ -14,7 +14,7 @@
 import socket
 import random
 import time
-import md5
+import hashlib
 import sys
 from zope.interface import implements, Interface
 
@@ -94,7 +94,7 @@
     488: "Not Acceptable Here",
     491: "Request Pending",
     493: "Undecipherable",
-    
+
     500: "Internal Server Error",
     501: "Not Implemented",
     502: "Bad Gateway", # no donut
@@ -102,7 +102,7 @@
     504: "Server Time-out",
     505: "SIP Version not supported",
     513: "Message Too Large",
-    
+
     600: "Busy Everywhere",
     603: "Decline",
     604: "Does not exist anywhere",
@@ -132,7 +132,7 @@
     pszNonce,
     pszCNonce,
 ):
-    m = md5.md5()
+    m = hashlib.md5()
     m.update(pszUserName)
     m.update(":")
     m.update(pszRealm)
@@ -140,7 +140,7 @@
     m.update(pszPassword)
     HA1 = m.digest()
     if pszAlg == "md5-sess":
-        m = md5.md5()
+        m = hashlib.md5()
         m.update(HA1)
         m.update(":")
         m.update(pszNonce)
@@ -159,7 +159,7 @@
     pszDigestUri,
     pszHEntity,
 ):
-    m = md5.md5()
+    m = hashlib.md5()
     m.update(pszMethod)
     m.update(":")
     m.update(pszDigestUri)
@@ -167,8 +167,8 @@
         m.update(":")
         m.update(pszHEntity)
     HA2 = m.digest().encode('hex')
-    
-    m = md5.md5()
+
+    m = hashlib.md5()
     m.update(HA1)
     m.update(":")
     m.update(pszNonce)
@@ -301,7 +301,7 @@
 
     def __str__(self):
         return self.toString()
-    
+
     def __repr__(self):
         return '<URL %s:%s@%s:%r/%s>' % (self.username, self.password, self.host, self.port, self.transport)
 
@@ -419,12 +419,12 @@
     """A SIP message."""
 
     length = None
-    
+
     def __init__(self):
         self.headers = util.OrderedDict() # map name to list of values
         self.body = ""
         self.finished = 0
-    
+
     def addHeader(self, name, value):
         name = name.lower()
         name = longHeaders.get(name, name)
@@ -434,7 +434,7 @@
 
     def bodyDataReceived(self, data):
         self.body += data
-    
+
     def creationFinished(self):
         if (self.length != None) and (self.length != len(self.body)):
             raise ValueError, "wrong body length"
@@ -465,7 +465,7 @@
         else:
             self.uri = parseURL(uri)
             cleanRequestURL(self.uri)
-    
+
     def __repr__(self):
         return "<SIP Request %d:%s %s>" % (id(self), self.method, self.uri.toString())
 
@@ -501,9 +501,9 @@
     acceptResponses = 1
     acceptRequests = 1
     state = "firstline" # or "headers", "body" or "invalid"
-    
+
     debug = 0
-    
+
     def __init__(self, messageReceivedCallback):
         self.messageReceived = messageReceivedCallback
         self.reset()
@@ -514,11 +514,11 @@
         self.bodyReceived = 0 # how much of the body we received
         self.message = None
         self.setLineMode(remainingData)
-    
+
     def invalidMessage(self):
         self.state = "invalid"
         self.setRawMode()
-    
+
     def dataDone(self):
         # clear out any buffered data that may be hanging around
         self.clearLineBuffer()
@@ -536,21 +536,21 @@
         else:
             # we have enough data and message wasn't finished? something is wrong
             raise RuntimeError, "this should never happen"
-    
+
     def dataReceived(self, data):
         try:
             basic.LineReceiver.dataReceived(self, data)
         except:
             log.err()
             self.invalidMessage()
-    
+
     def handleFirstLine(self, line):
         """Expected to create self.message."""
         raise NotImplementedError
 
     def lineLengthExceeded(self, line):
         self.invalidMessage()
-    
+
     def lineReceived(self, line):
         if self.state == "firstline":
             while line.startswith("\n") or line.startswith("\r"):
@@ -608,7 +608,7 @@
         self.message.creationFinished()
         self.messageReceived(self.message)
         self.reset(remainingData)
-    
+
     def rawDataReceived(self, data):
         assert self.state in ("body", "invalid")
         if self.state == "invalid":
@@ -631,10 +631,10 @@
 
 class Base(protocol.DatagramProtocol):
     """Base class for SIP clients and servers."""
-    
+
     PORT = PORT
     debug = False
-    
+
     def __init__(self):
         self.messages = []
         self.parser = MessagesParser(self.addMessage)
@@ -658,7 +658,7 @@
     def _fixupNAT(self, message, (srcHost, srcPort)):
         # RFC 2543 6.40.2,
         senderVia = parseViaHeader(message.headers["via"][0])
-        if senderVia.host != srcHost:            
+        if senderVia.host != srcHost:
             senderVia.received = srcHost
             if senderVia.port != srcPort:
                 senderVia.rport = srcPort
@@ -709,7 +709,7 @@
 
     def handle_response(self, message, addr):
         """Override to define behavior for responses received.
-        
+
         @type message: C{Message}
         @type addr: C{tuple}
         """
@@ -760,11 +760,11 @@
 
 class Proxy(Base):
     """SIP proxy."""
-    
+
     PORT = PORT
 
     locator = None # object implementing ILocator
-    
+
     def __init__(self, host=None, port=PORT):
         """Create new instance.
 
@@ -774,7 +774,7 @@
         self.host = host or socket.getfqdn()
         self.port = port
         Base.__init__(self)
-        
+
     def getVia(self):
         """Return value of Via header for this proxy."""
         return Via(host=self.host, port=self.port)
@@ -797,10 +797,10 @@
                 d.addErrback(lambda e:
                     self.deliverResponse(self.responseFromRequest(e.code, message))
                 )
-        
+
     def handle_request_default(self, message, (srcHost, srcPort)):
         """Default request handler.
-        
+
         Default behaviour for OPTIONS and unknown methods for proxies
         is to forward message on to the client.
 
@@ -808,9 +808,9 @@
         everything.
         """
         def _mungContactHeader(uri, message):
-            message.headers['contact'][0] = uri.toString()            
+            message.headers['contact'][0] = uri.toString()
             return self.sendMessage(uri, message)
-        
+
         viaHeader = self.getVia()
         if viaHeader.toString() in message.headers["via"]:
             # must be a loop, so drop message
@@ -824,12 +824,12 @@
         d = self.locator.getAddress(uri)
         d.addCallback(self.sendMessage, message)
         d.addErrback(self._cantForwardRequest, message)
-    
+
     def _cantForwardRequest(self, error, message):
         error.trap(LookupError)
         del message.headers["via"][0] # this'll be us
         self.deliverResponse(self.responseFromRequest(404, message))
-    
+
     def deliverResponse(self, responseMessage):
         """Deliver response.
 
@@ -838,7 +838,7 @@
         # XXX we don't do multicast yet
         host = destVia.received or destVia.host
         port = destVia.rport or destVia.port or self.PORT
-        
+
         destAddr = URL(host=host, port=port)
         self.sendMessage(destAddr, responseMessage)
 
@@ -848,7 +848,7 @@
         for name in ("via", "to", "from", "call-id", "cseq"):
             response.headers[name] = request.headers.get(name, [])[:]
         return response
-    
+
     def handle_response(self, message, addr):
         """Default response handler."""
         v = parseViaHeader(message.headers["via"][0])
@@ -864,7 +864,7 @@
             self.gotResponse(message, addr)
             return
         self.deliverResponse(message)
-    
+
     def gotResponse(self, message, addr):
         """Called with responses that are addressed at this server."""
         pass
@@ -872,31 +872,31 @@
 class IAuthorizer(Interface):
     def getChallenge(peer):
         """Generate a challenge the client may respond to.
-        
+
         @type peer: C{tuple}
         @param peer: The client's address
-        
+
         @rtype: C{str}
         @return: The challenge string
         """
-    
+
     def decode(response):
         """Create a credentials object from the given response.
-        
+
         @type response: C{str}
         """
- 
+
 class BasicAuthorizer:
     """Authorizer for insecure Basic (base64-encoded plaintext) authentication.
-    
+
     This form of authentication is broken and insecure.  Do not use it.
     """
 
     implements(IAuthorizer)
-    
+
     def getChallenge(self, peer):
         return None
-    
+
     def decode(self, response):
         # At least one SIP client improperly pads its Base64 encoded messages
         for i in range(3):
@@ -917,12 +917,12 @@
 
 class DigestedCredentials(cred.credentials.UsernameHashedPassword):
     """Yet Another Simple Digest-MD5 authentication scheme"""
-    
+
     def __init__(self, username, fields, challenges):
         self.username = username
         self.fields = fields
         self.challenges = challenges
-    
+
     def checkPassword(self, password):
         method = 'REGISTER'
         response = self.fields.get('response')
@@ -937,7 +937,7 @@
         if opaque not in self.challenges:
             return False
         del self.challenges[opaque]
-        
+
         user, domain = self.username.split('@', 1)
         if uri is None:
             uri = 'sip:' + domain
@@ -946,17 +946,17 @@
             DigestCalcHA1(algo, user, domain, password, nonce, cnonce),
             nonce, nc, cnonce, qop, method, uri, None,
         )
-        
+
         return expected == response
 
 class DigestAuthorizer:
     CHALLENGE_LIFETIME = 15
-    
+
     implements(IAuthorizer)
-    
+
     def __init__(self):
         self.outstanding = {}
-    
+
     def generateNonce(self):
         c = tuple([random.randrange(sys.maxint) for _ in range(3)])
         c = '%d%d%d' % c
@@ -975,7 +975,7 @@
             'qop-options="auth"',
             'algorithm="MD5"',
         ))
-        
+
     def decode(self, response):
         response = ' '.join(response.splitlines())
         parts = response.split(',')
@@ -1003,11 +1003,11 @@
     authorizers = {
         'digest': DigestAuthorizer(),
     }
-    
+
     def __init__(self, *args, **kw):
         Proxy.__init__(self, *args, **kw)
         self.liveChallenges = {}
-        
+
     def handle_ACK_request(self, message, (host, port)):
         # XXX
         # ACKs are a client's way of indicating they got the last message
@@ -1042,7 +1042,7 @@
             m.headers.setdefault('www-authenticate', []).append(value)
         self.deliverResponse(m)
 
- 
+
     def login(self, message, host, port):
         parts = message.headers['authorization'][0].split(None, 1)
         a = self.authorizers.get(parts[0].lower())
@@ -1067,7 +1067,7 @@
     def _cbLogin(self, (i, a, l), message, host, port):
         # It's stateless, matey.  What a joke.
         self.register(message, host, port)
-    
+
     def _ebLogin(self, failure, message, host, port):
         failure.trap(cred.error.UnauthorizedLogin)
         self.unauthorized(message, host, port)
@@ -1137,7 +1137,7 @@
     """A simplistic registry for a specific domain."""
 
     implements(IRegistry, ILocator)
-    
+
     def __init__(self, domain):
         self.domain = domain # the domain we handle registration for
         self.users = {} # map username to (IDelayedCall for expiry, address URI)
@@ -1150,7 +1150,7 @@
             return defer.succeed(url)
         else:
             return defer.fail(LookupError("no such user"))
-            
+
     def getRegistrationInfo(self, userURI):
         if userURI.host != self.domain:
             return defer.fail(LookupError("unknown domain"))
@@ -1159,7 +1159,7 @@
             return defer.succeed(Registration(int(dc.getTime() - time.time()), url))
         else:
             return defer.fail(LookupError("no such user"))
-        
+
     def _expireRegistration(self, username):
         try:
             dc, url = self.users[username]
@@ -1169,7 +1169,7 @@
             dc.cancel()
             del self.users[username]
         return defer.succeed(Registration(0, url))
-    
+
     def registerAddress(self, domainURL, logicalURL, physicalURL):
         if domainURL.host != self.domain:
             log.msg("Registration for domain we don't handle.")
Index: twisted/conch/test/test_keys.py
===================================================================
--- twisted/conch/test/test_keys.py	(revision 22614)
+++ twisted/conch/test/test_keys.py	(working copy)
@@ -12,7 +12,7 @@
 from twisted.conch.test import keydata
 from twisted.python import randbytes
 from twisted.trial import unittest
-import sha, os, base64
+import hashlib, os, base64
 
 class SSHKeysHandlingTestCase(unittest.TestCase):
     """
@@ -316,7 +316,7 @@
         messageSize = 6
         self.assertEquals(keys.pkcs1Pad(data, messageSize),
                 '\x01\xff\x00ABC')
-        hash = sha.new().digest()
+        hash = hashlib.sha1().digest()
         messageSize = 40
         self.assertEquals(keys.pkcs1Digest('', messageSize),
                 '\x01\xff\xff\xff\x00' + keys.ID_SHA1 + hash)
@@ -348,7 +348,7 @@
         """
         data = 'data'
         key, sig = self._signDSA(data)
-        sigData = sha.new(data).digest()
+        sigData = hashlib.sha1(data).digest()
         v = key.sign(sigData, '\x55' * 19)
         self.assertEquals(sig, common.NS('ssh-dss') + common.NS(
             Crypto.Util.number.long_to_bytes(v[0], 20) +
Index: twisted/conch/ssh/transport.py
===================================================================
--- twisted/conch/ssh/transport.py	(revision 22614)
+++ twisted/conch/ssh/transport.py	(working copy)
@@ -3,7 +3,7 @@
 # Copyright (c) 2001-2004 Twisted Matrix Laboratories.
 # See LICENSE for details.
 
-# 
+#
 
 """The lowest level SSH protocol.  This handles the key negotiation, the encryption and the compression.
 
@@ -16,8 +16,7 @@
 
 # base library imports
 import struct
-import md5
-import sha
+import hashlib
 import zlib
 import math # for math.log
 import array
@@ -44,17 +43,17 @@
     comment = ''
     ourVersionString = ('SSH-'+protocolVersion+'-'+version+' '+comment).strip()
 
-    supportedCiphers = ['aes256-ctr', 'aes256-cbc', 'aes192-ctr', 'aes192-cbc', 
-                        'aes128-ctr', 'aes128-cbc', 'cast128-ctr', 
+    supportedCiphers = ['aes256-ctr', 'aes256-cbc', 'aes192-ctr', 'aes192-cbc',
+                        'aes128-ctr', 'aes128-cbc', 'cast128-ctr',
                         'cast128-cbc', 'blowfish-ctr', 'blowfish', 'idea-ctr'
                         'idea-cbc', '3des-ctr', '3des-cbc'] # ,'none']
     supportedMACs = ['hmac-sha1', 'hmac-md5'] # , 'none']
-    
+
     # both of the above support 'none', but for security are disabled by
     # default.  to enable them, subclass this class and add it, or do:
     #   SSHTransportBase.supportedCiphers.append('none')
 
-    supportedKeyExchanges = ['diffie-hellman-group-exchange-sha1', 
+    supportedKeyExchanges = ['diffie-hellman-group-exchange-sha1',
                              'diffie-hellman-group1-sha1']
     supportedPublicKeys = ['ssh-rsa', 'ssh-dss']
     supportedCompressions = ['none', 'zlib']
@@ -150,7 +149,7 @@
         if len(packet) != 4+packetLen:
             self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, 'bad packet length')
             return
-        if ms: 
+        if ms:
             macData, self.buf = self.buf[:ms],  self.buf[ms:]
             if not self.currentEncryptions.verify(self.incomingPacketSequence, packet, macData):
                 self.sendDisconnect(DISCONNECT_MAC_ERROR, 'bad MAC')
@@ -303,10 +302,10 @@
         self.kexAlg = ffs(kexAlgs, self.supportedKeyExchanges)
         self.keyAlg = ffs(keyAlgs, self.supportedPublicKeys)
         self.nextEncryptions = SSHCiphers(
-        ffs(encSC, self.supportedCiphers), 
-            ffs(encCS, self.supportedCiphers), 
-            ffs(macSC, self.supportedMACs), 
-            ffs(macCS, self.supportedMACs), 
+        ffs(encSC, self.supportedCiphers),
+            ffs(encCS, self.supportedCiphers),
+            ffs(macSC, self.supportedMACs),
+            ffs(macCS, self.supportedMACs),
          )
         self.outgoingCompressionType = ffs(compSC, self.supportedCompressions)
         self.incomingCompressionType = ffs(compCS, self.supportedCompressions)
@@ -317,11 +316,11 @@
             self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, "couldn't match all kex parts")
             return
         log.msg('kex alg, key alg: %s %s'%(self.kexAlg, self.keyAlg))
-        log.msg('server->client: %s %s %s'%(self.nextEncryptions.outCipType, 
-                                            self.nextEncryptions.outMacType, 
+        log.msg('server->client: %s %s %s'%(self.nextEncryptions.outCipType,
+                                            self.nextEncryptions.outMacType,
                                             self.outgoingCompressionType))
-        log.msg('client->server: %s %s %s'%(self.nextEncryptions.inCipType, 
-                                            self.nextEncryptions.inMacType, 
+        log.msg('client->server: %s %s %s'%(self.nextEncryptions.inCipType,
+                                            self.nextEncryptions.inMacType,
                                             self.incomingCompressionType))
 
 
@@ -334,7 +333,7 @@
             y = Util.number.getRandomNumber(16, randbytes.secureRandom)
             f = pow(DH_GENERATOR, y, DH_PRIME)
             sharedSecret = _MPpow(clientDHPubKey, y, DH_PRIME)
-            h = sha.new()
+            h = hashlib.sha1()
             h.update(NS(self.otherVersionString))
             h.update(NS(self.ourVersionString))
             h.update(NS(self.clientKexInitPayload))
@@ -391,7 +390,7 @@
 
         f = pow(self.g, y, self.p)
         sharedSecret = _MPpow(clientDHPubKey, y, self.p)
-        h = sha.new()
+        h = hashlib.sha1()
         h.update(NS(self.otherVersionString))
         h.update(NS(self.ourVersionString))
         h.update(NS(self.clientKexInitPayload))
@@ -444,8 +443,8 @@
         self.sendPacket(MSG_NEWKEYS, '')
 
     def _getKey(self, c, sharedSecret, exchangeHash):
-        k1 = sha.new(sharedSecret+exchangeHash+c+self.sessionID).digest()
-        k2 = sha.new(sharedSecret+exchangeHash+k1).digest()
+        k1 = hashlib.sha1(sharedSecret+exchangeHash+c+self.sessionID).digest()
+        k2 = hashlib.sha1(sharedSecret+exchangeHash+k1).digest()
         return k1+k2
 
 class SSHClientTransport(SSHTransportBase):
@@ -465,10 +464,10 @@
         self.kexAlg = ffs(self.supportedKeyExchanges, kexAlgs)
         self.keyAlg = ffs(self.supportedPublicKeys, keyAlgs)
         self.nextEncryptions = SSHCiphers(
-        ffs(self.supportedCiphers, encCS), 
-            ffs(self.supportedCiphers, encSC), 
-            ffs(self.supportedMACs, macCS), 
-            ffs(self.supportedMACs, macSC), 
+        ffs(self.supportedCiphers, encCS),
+            ffs(self.supportedCiphers, encSC),
+            ffs(self.supportedMACs, macCS),
+            ffs(self.supportedMACs, macSC),
          )
         self.outgoingCompressionType = ffs(self.supportedCompressions, compCS)
         self.incomingCompressionType = ffs(self.supportedCompressions, compSC)
@@ -479,11 +478,11 @@
             self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, "couldn't match all kex parts")
             return
         log.msg('kex alg, key alg: %s %s'%(self.kexAlg, self.keyAlg))
-        log.msg('client->server: %s %s %s'%(self.nextEncryptions.outCipType, 
-                                            self.nextEncryptions.outMacType, 
+        log.msg('client->server: %s %s %s'%(self.nextEncryptions.outCipType,
+                                            self.nextEncryptions.outMacType,
                                             self.outgoingCompressionType))
-        log.msg('server->client: %s %s %s'%(self.nextEncryptions.inCipType, 
-                                            self.nextEncryptions.inMacType, 
+        log.msg('server->client: %s %s %s'%(self.nextEncryptions.inCipType,
+                                            self.nextEncryptions.inMacType,
                                             self.incomingCompressionType))
 
         if self.kexAlg == 'diffie-hellman-group1-sha1':
@@ -498,7 +497,7 @@
             pubKey, packet = getNS(packet)
             f, packet = getMP(packet)
             signature, packet = getNS(packet)
-            fingerprint = ':'.join(map(lambda c: '%02x'%ord(c), md5.new(pubKey).digest()))
+            fingerprint = ':'.join(map(lambda c: '%02x'%ord(c), hashlib.md5(pubKey).digest()))
             d = self.verifyHostKey(pubKey, fingerprint)
             d.addCallback(self._continueGEX_GROUP, pubKey, f, signature)
             d.addErrback(lambda unused,self=self:self.sendDisconnect(DISCONNECT_HOST_KEY_NOT_VERIFIABLE, 'bad host key'))
@@ -511,7 +510,7 @@
 
     def _continueGEX_GROUP(self, ignored, pubKey, f, signature):
         sharedSecret = _MPpow(f, self.x, DH_PRIME)
-        h = sha.new()
+        h = hashlib.sha1()
         h.update(NS(self.ourVersionString))
         h.update(NS(self.otherVersionString))
         h.update(NS(self.ourKexInitPayload))
@@ -530,7 +529,7 @@
         pubKey, packet = getNS(packet)
         f, packet = getMP(packet)
         signature, packet = getNS(packet)
-        fingerprint = ':'.join(map(lambda c: '%02x'%ord(c), md5.new(pubKey).digest()))
+        fingerprint = ':'.join(map(lambda c: '%02x'%ord(c), hashlib.md5(pubKey).digest()))
         d = self.verifyHostKey(pubKey, fingerprint)
         d.addCallback(self._continueGEX_REPLY, pubKey, f, signature)
         d.addErrback(lambda unused, self=self: self.sendDisconnect(DISCONNECT_HOST_KEY_NOT_VERIFIABLE, 'bad host key'))
@@ -538,7 +537,7 @@
     def _continueGEX_REPLY(self, ignored, pubKey, f, signature):
         serverKey = keys.getPublicKeyObject(pubKey)
         sharedSecret = _MPpow(f, self.x, self.p)
-        h = sha.new()
+        h = hashlib.sha1()
         h.update(NS(self.ourVersionString))
         h.update(NS(self.otherVersionString))
         h.update(NS(self.ourKexInitPayload))
@@ -571,8 +570,8 @@
             self.ssh_NEWKEYS('')
 
     def _getKey(self, c, sharedSecret, exchangeHash):
-        k1 = sha.new(sharedSecret+exchangeHash+c+self.sessionID).digest()
-        k2 = sha.new(sharedSecret+exchangeHash+k1).digest()
+        k1 = hashlib.sha1(sharedSecret+exchangeHash+c+self.sessionID).digest()
+        k2 = hashlib.sha1(sharedSecret+exchangeHash+k1).digest()
         return k1+k2
 
     def ssh_NEWKEYS(self, packet):
@@ -618,29 +617,29 @@
 
     def connectionSecure(self):
         """
-        Called when the encryption has been set up.  Generally, 
+        Called when the encryption has been set up.  Generally,
         requestService() is called to run another service over the transport.
         """
         raise NotImplementedError
 
 class _DummyCipher:
     block_size = 1
-    
+
     def encrypt(self, x):
         return x
-    
+
     decrypt = encrypt
 
 class SSHCiphers:
     cipherMap = {
-        '3des-cbc':('DES3', 24, 0), 
-        'blowfish-cbc':('Blowfish', 16,0 ), 
-        'aes256-cbc':('AES', 32, 0), 
-        'aes192-cbc':('AES', 24, 0), 
-        'aes128-cbc':('AES', 16, 0), 
-        'arcfour':('ARC4', 16, 0), 
-        'idea-cbc':('IDEA', 16, 0), 
-        'cast128-cbc':('CAST', 16, 0), 
+        '3des-cbc':('DES3', 24, 0),
+        'blowfish-cbc':('Blowfish', 16,0 ),
+        'aes256-cbc':('AES', 32, 0),
+        'aes192-cbc':('AES', 24, 0),
+        'aes128-cbc':('AES', 16, 0),
+        'arcfour':('ARC4', 16, 0),
+        'idea-cbc':('IDEA', 16, 0),
+        'cast128-cbc':('CAST', 16, 0),
         'aes128-ctr':('AES', 16, 1),
         'aes192-ctr':('AES', 24, 1),
         'aes256-ctr':('AES', 32, 1),
@@ -651,7 +650,7 @@
         'none':(None, 0, 0),
     }
     macMap = {
-        'hmac-sha1': 'sha', 
+        'hmac-sha1': 'sha',
         'hmac-md5': 'md5',
         'none':None
      }
Index: twisted/conch/ssh/factory.py
===================================================================
--- twisted/conch/ssh/factory.py	(revision 22614)
+++ twisted/conch/ssh/factory.py	(working copy)
@@ -1,7 +1,7 @@
 # Copyright (c) 2001-2004 Twisted Matrix Laboratories.
 # See LICENSE for details.
 
-# 
+#
 
 """A Factory for SSH servers, along with an OpenSSHFactory to use the same data sources as OpenSSH.
 
@@ -10,8 +10,6 @@
 Maintainer: U{Paul Swartz<mailto:z3p@twistedmatrix.com>}
 """
 
-import md5
-
 try:
     import resource
 except ImportError:
@@ -63,8 +61,8 @@
 
     def getPublicKeys(self):
         """
-        Called when the factory is started to get the public portions of the 
-        servers host keys.  Returns a dictionary mapping SSH key types  to 
+        Called when the factory is started to get the public portions of the
+        servers host keys.  Returns a dictionary mapping SSH key types  to
         public key strings.
 
         @rtype: C{dict}
@@ -73,8 +71,8 @@
 
     def getPrivateKeys(self):
         """
-        Called when the factory is started to get the  private portions of the 
-        servers host keys.  Returns a dictionary mapping SSH key types to 
+        Called when the factory is started to get the  private portions of the
+        servers host keys.  Returns a dictionary mapping SSH key types to
         C{Crypto.PublicKey.pubkey.pubkey} objects.
 
         @rtype: C{dict}
Index: twisted/conch/ssh/keys.py
===================================================================
--- twisted/conch/ssh/keys.py	(revision 22614)
+++ twisted/conch/ssh/keys.py	(working copy)
@@ -13,7 +13,7 @@
 
 # base library imports
 import base64
-import sha, md5
+import hashlib
 import warnings
 
 # external library imports
@@ -168,8 +168,8 @@
                 len(ivdata), 2)])
             if not passphrase:
                 raise EncryptedKeyError('encrypted key with no passphrase')
-            ba = md5.new(passphrase + iv).digest()
-            bb = md5.new(ba + passphrase + iv).digest()
+            ba = hashlib.md5(passphrase + iv).digest()
+            bb = hashlib.md5(ba + passphrase + iv).digest()
             decKey = (ba + bb)[:24]
             b64Data = base64.decodestring(''.join(lines[3:-1]))
             keyData = DES3.new(decKey, DES3.MODE_CBC, iv).decrypt(b64Data)
@@ -500,8 +500,8 @@
                 hexiv = ''.join(['%02X' % ord(x) for x in iv])
                 lines.append('Proc-Type: 4,ENCRYPTED')
                 lines.append('DEK-Info: DES-EDE3-CBC,%s\n' % hexiv)
-                ba = md5.new(extra + iv).digest()
-                bb = md5.new(ba + extra + iv).digest()
+                ba = hashlib.md5(extra + iv).digest()
+                bb = hashlib.md5(ba + extra + iv).digest()
                 encKey = (ba + bb)[:24]
             asn1Data = asn1.pack([objData])
             if extra:
@@ -584,7 +584,7 @@
             signature = self.keyObject.sign(digest, '')[0]
             ret = common.NS(Util.number.long_to_bytes(signature))
         elif self.type() == 'DSA':
-            digest = sha.new(data).digest()
+            digest = hashlib.sha1(data).digest()
             randomBytes = randbytes.secureRandom(19)
             sig = self.keyObject.sign(digest, randomBytes)
             # SSH insists that the DSS signature blob be two 160-bit integers
@@ -613,7 +613,7 @@
             signature = common.getNS(signature)[0]
             numbers = [Util.number.bytes_to_long(n) for n in signature[:20],
                     signature[20:]]
-            digest = sha.new(data).digest()
+            digest = hashlib.sha1(data).digest()
         return self.keyObject.verify(digest, numbers)
 
 def getPublicKeyString(filename=None, line=0, data=''):
@@ -766,7 +766,7 @@
     @type data: C{str}
     @type messageLength: C{str}
     """
-    digest = sha.new(data).digest()
+    digest = hashlib.sha1(data).digest()
     return pkcs1Pad(ID_SHA1+digest, messageLength)
 
 def lenSig(obj):
Index: twisted/words/test/test_jabbercomponent.py
===================================================================
--- twisted/words/test/test_jabbercomponent.py	(revision 22614)
+++ twisted/words/test/test_jabbercomponent.py	(working copy)
@@ -5,7 +5,7 @@
 Tests for L{twisted.words.protocols.jabber.component}
 """
 
-import sha
+import hashlib
 from twisted.trial import unittest
 
 from twisted.words.protocols.jabber import component
@@ -48,7 +48,7 @@
         handshake = self.output[-1]
         self.assertEquals('handshake', handshake.name)
         self.assertEquals('test:component', handshake.uri)
-        self.assertEquals(sha.new("%s%s" % ('12345', 'secret')).hexdigest(),
+        self.assertEquals(hashlib.sha1("%s%s" % ('12345', 'secret')).hexdigest(),
                           unicode(handshake))
 
         # successful authentication
@@ -78,7 +78,7 @@
         xs.dataReceived("<stream:stream xmlns='jabber:component:accept' xmlns:stream='http://etherx.jabber.org/streams' from='cjid' id='12345'>")
 
         # Calculate what we expect the handshake value to be
-        hv = sha.new("%s%s" % ("12345", "secret")).hexdigest()
+        hv = hashlib.sha1("%s%s" % ("12345", "secret")).hexdigest()
 
         self.assertEquals(outlist[1], "<handshake>%s</handshake>" % (hv))
 
Index: twisted/words/test/test_jabberclient.py
===================================================================
--- twisted/words/test/test_jabberclient.py	(revision 22614)
+++ twisted/words/test/test_jabberclient.py	(working copy)
@@ -5,7 +5,7 @@
 Tests for L{twisted.words.protocols.jabber.client}
 """
 
-import sha
+import hashlib
 from twisted.trial import unittest
 from twisted.words.protocols.jabber import client, error, jid, xmlstream
 from twisted.words.protocols.jabber.sasl import SASLInitiatingInitializer
@@ -117,7 +117,7 @@
         self.assertEquals(('jabber:iq:auth', 'query'),
                           (iq.children[0].uri, iq.children[0].name))
         self.assertEquals('user', unicode(iq.query.username))
-        self.assertEquals(sha.new('12345secret').hexdigest(),
+        self.assertEquals(hashlib.sha1('12345secret').hexdigest(),
                           unicode(iq.query.digest))
         self.assertEquals('resource', unicode(iq.query.resource))
 
Index: twisted/words/protocols/jabber/sasl_mechanisms.py
===================================================================
--- twisted/words/protocols/jabber/sasl_mechanisms.py	(revision 22614)
+++ twisted/words/protocols/jabber/sasl_mechanisms.py	(working copy)
@@ -7,7 +7,7 @@
 Protocol agnostic implementations of SASL authentication mechanisms.
 """
 
-import md5, binascii, random, time, os
+import hashlib, binascii, random, time, os
 
 from zope.interface import Interface, Attribute, implements
 
@@ -178,7 +178,7 @@
         """
 
         def H(s):
-            return md5.new(s).digest()
+            return hashlib.md5(s).digest()
 
         def HEX(n):
             return binascii.b2a_hex(n)
@@ -221,4 +221,4 @@
 
 
     def _gen_nonce(self):
-        return md5.new("%s:%s:%s" % (str(random.random()) , str(time.gmtime()),str(os.getpid()))).hexdigest()
+        return hashlib.md5("%s:%s:%s" % (str(random.random()) , str(time.gmtime()),str(os.getpid()))).hexdigest()
Index: twisted/words/protocols/jabber/xmlstream.py
===================================================================
--- twisted/words/protocols/jabber/xmlstream.py	(revision 22614)
+++ twisted/words/protocols/jabber/xmlstream.py	(working copy)
@@ -42,8 +42,8 @@
     """
     Create a SHA1-digest string of a session identifier and password.
     """
-    import sha
-    return sha.new("%s%s" % (sid, password)).hexdigest()
+    import hashlib
+    return hashlib.sha1("%s%s" % (sid, password)).hexdigest()
 
 
 class Authenticator:
Index: twisted/words/protocols/oscar.py
===================================================================
--- twisted/words/protocols/oscar.py	(revision 22614)
+++ twisted/words/protocols/oscar.py	(working copy)
@@ -16,7 +16,7 @@
 from twisted.python import log
 
 import struct
-import md5
+import hashlib
 import string
 import socket
 import random
@@ -63,9 +63,9 @@
     return dict,data
 
 def encryptPasswordMD5(password,key):
-    m=md5.new()
+    m=hashlib.md5()
     m.update(key)
-    m.update(md5.new(password).digest())
+    m.update(hashlib.md5(password).digest())
     m.update("AOL Instant Messenger (SM)")
     return m.digest()
 
@@ -232,7 +232,7 @@
                     self.alertWhen.append('unaway')
             elif k == 0x013e:
                 self.alertSound = v
- 
+
     def oscarRep(self, groupID, buddyID):
         tlvData = reduce(lambda x,y: x+y, map(lambda (k,v):TLV(k,v), self.tlvs.items()), '\000\000')
         return struct.pack('!H', len(self.name)) + self.name + \
Index: twisted/web2/auth/digest.py
===================================================================
--- twisted/web2/auth/digest.py	(revision 22614)
+++ twisted/web2/auth/digest.py	(working copy)
@@ -12,15 +12,15 @@
 
 from twisted.web2.auth.interfaces import ICredentialFactory
 
-import md5, sha
+import hashlib
 import random, sys
 
 # The digest math
 
 algorithms = {
-    'md5': md5.new,
-    'md5-sess': md5.new,
-    'sha': sha.new,
+    'md5': hashlib.md5,
+    'md5-sess': hashlib.md5,
+    'sha': hashlib.sha1,
 }
 
 # DigestCalcHA1
@@ -228,7 +228,7 @@
         # Now, what we do is encode the nonce, client ip and a timestamp
         # in the opaque value with a suitable digest
         key = "%s,%s,%s" % (nonce, clientip, str(int(self._getTime())))
-        digest = md5.new(key + self.privateKey).hexdigest()
+        digest = hashlib.md5(key + self.privateKey).hexdigest()
         ekey = key.encode('base64')
         return "%s-%s" % (digest, ekey.strip('\n'))
 
@@ -275,7 +275,7 @@
                 'Invalid response, incompatible opaque/nonce too old')
 
         # Verify the digest
-        digest = md5.new(key + self.privateKey).hexdigest()
+        digest = hashlib.md5(key + self.privateKey).hexdigest()
         if digest != opaqueParts[0]:
             raise error.LoginFailed('Invalid response, invalid opaque value')
 
Index: twisted/web2/dav/test/test_copy.py
===================================================================
--- twisted/web2/dav/test/test_copy.py	(revision 22614)
+++ twisted/web2/dav/test/test_copy.py	(working copy)
@@ -7,10 +7,10 @@
 # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 # copies of the Software, and to permit persons to whom the Software is
 # furnished to do so, subject to the following conditions:
-# 
+#
 # The above copyright notice and this permission notice shall be included in all
 # copies or substantial portions of the Software.
-# 
+#
 # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -24,7 +24,7 @@
 
 import os
 import urllib
-import md5
+import hashlib
 
 import twisted.web2.dav.test.util
 from twisted.web2 import responsecode
@@ -162,7 +162,7 @@
             yield (request, do_test)
 
 def sumFile(path):
-    m = md5.new()
+    m = hashlib.md5()
 
     if os.path.isfile(path):
         f = file(path)
Index: twisted/web2/test/test_httpauth.py
===================================================================
--- twisted/web2/test/test_httpauth.py	(revision 22614)
+++ twisted/web2/test/test_httpauth.py	(working copy)
@@ -1,4 +1,4 @@
-import md5
+import hashlib
 from twisted.internet import address
 from twisted.trial import unittest
 from twisted.cred import error
@@ -263,10 +263,10 @@
         creds = self.credentialFactory.decode(clientResponse, _trivial_GET)
 
         self.failUnless(creds.checkHash(
-                md5.md5('username:test realm:password').hexdigest()))
+                hashlib.md5('username:test realm:password').hexdigest()))
 
         self.failIf(creds.checkHash(
-                md5.md5('username:test realm:bogus').hexdigest()))
+                hashlib.md5('username:test realm:bogus').hexdigest()))
 
     def test_invalidOpaque(self):
         """
@@ -364,7 +364,7 @@
         key = '%s,%s,%s' % (challenge['nonce'],
                             clientAddress.host,
                             '-137876876')
-        digest = md5.new(key + credentialFactory.privateKey).hexdigest()
+        digest = hashlib.md5(key + credentialFactory.privateKey).hexdigest()
         ekey = key.encode('base64')
 
         oldNonceOpaque = '%s-%s' % (digest, ekey.strip('\n'))
@@ -390,7 +390,7 @@
                             clientAddress.host,
                             '0')
 
-        digest = md5.new(key + 'this is not the right pkey').hexdigest()
+        digest = hashlib.md5(key + 'this is not the right pkey').hexdigest()
 
         badChecksum = '%s-%s' % (digest,
                                  key.encode('base64').strip('\n'))
@@ -834,7 +834,7 @@
     def test_forceAuthentication(self):
         """
         Test that if an HTTPError with an Unauthorized status code is raised
-        from within our protected resource, we add the WWW-Authenticate 
+        from within our protected resource, we add the WWW-Authenticate
         headers if they do not already exist.
         """
         self.portal.registerChecker(checkers.AllowAnonymousAccess())
Index: twisted/web2/static.py
===================================================================
--- twisted/web2/static.py	(revision 22614)
+++ twisted/web2/static.py	(working copy)
@@ -9,7 +9,6 @@
 # System Imports
 import os, time, stat
 import tempfile
-import md5
 
 # Sibling Imports
 from twisted.web2 import http_headers, resource
@@ -475,7 +474,7 @@
             flags = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, "O_BINARY", 0)
 
             fileobject = os.fdopen(os.open(outname, flags, self.permissions), 'wb', 0)
-                
+
             stream.readIntoFile(filestream, fileobject)
 
         return outname
Index: twisted/cred/util.py
===================================================================
--- twisted/cred/util.py	(revision 22614)
+++ twisted/cred/util.py	(working copy)
@@ -16,7 +16,7 @@
 """
 
 # System Imports
-import md5
+import hashlib
 import random
 
 from twisted.cred.error import Unauthorized
@@ -25,7 +25,7 @@
     """Respond to a challenge.
     This is useful for challenge/response authentication.
     """
-    m = md5.new()
+    m = hashlib.md5()
     m.update(password)
     hashedPassword = m.digest()
     m = md5.new()
@@ -40,5 +40,5 @@
     crap = ''
     for x in range(random.randrange(15,25)):
         crap = crap + chr(random.randint(65,90))
-    crap = md5.new(crap).digest()
+    crap = hashlib.md5(crap).digest()
     return crap
Index: twisted/web/server.py
===================================================================
--- twisted/web/server.py	(revision 22614)
+++ twisted/web/server.py	(working copy)
@@ -471,7 +471,7 @@
 class Site(http.HTTPFactory):
     """
     A web site: manage log, sessions, and resources.
-    
+
     @ivar counter: increment value used for generating unique sessions ID.
     @ivar requestFactory: factory creating requests objects. Default to
         L{Request}.
@@ -507,9 +507,9 @@
         """
         (internal) Generate an opaque, unique ID for a user's session.
         """
-        import md5, random
+        import hashlib, random
         self.counter = self.counter + 1
-        return md5.new("%s_%s" % (str(random.random()) , str(self.counter))).hexdigest()
+        return hashlib.md5("%s_%s" % (str(random.random()) , str(self.counter))).hexdigest()
 
     def makeSession(self):
         """
Index: twisted/web/woven/guard.py
===================================================================
--- twisted/web/woven/guard.py	(revision 22614)
+++ twisted/web/woven/guard.py	(working copy)
@@ -16,7 +16,7 @@
 
 import random
 import time
-import md5
+import hashlib
 import urllib
 
 # Twisted Imports
@@ -29,7 +29,7 @@
 from twisted.cred.error import LoginFailed, UnauthorizedLogin
 
 def _sessionCookie():
-    return md5.new("%s_%s" % (str(random.random()) , str(time.time()))).hexdigest()
+    return hashlib.md5("%s_%s" % (str(random.random()) , str(time.time()))).hexdigest()
 
 class GuardSession(components.Componentized):
     """A user's session with a system.
@@ -186,7 +186,7 @@
 class SessionWrapper(Resource):
 
     sessionLifetime = 1800
-    
+
     def __init__(self, rsrc, cookieKey=None):
         Resource.__init__(self)
         self.resource = rsrc
@@ -295,9 +295,9 @@
     If you want to determine what unauthenticated users see, make sure your
     L{Portal<twisted.cred.portal.Portal>} has a checker associated that allows
     anonymous access. (See L{twisted.cred.checkers.AllowAnonymousAccess})
-    
+
     """
-    
+
     def __init__(self, portal, callback=None, errback=None):
         """Constructs a UsernamePasswordWrapper around the given portal.
 
@@ -305,7 +305,7 @@
             associated with this portal must be able to accept username/password
             credentials.
         @type portal: L{twisted.cred.portal.Portal}
-        
+
         @param callback: Gets called after a successful login attempt.
             A resource that redirects to "." will display the avatar resource.
             If this parameter isn't provided, defaults to a standard Woven
@@ -343,7 +343,7 @@
             def triggerLogin(username, password, submit=None):
                 return self.portal.login(
                     UsernamePassword(username, password),
-                    None, 
+                    None,
                     IResource
                 ).addCallback(
                     loginSuccess
Index: twisted/web/monitor.py
===================================================================
--- twisted/web/monitor.py	(revision 22614)
+++ twisted/web/monitor.py	(working copy)
@@ -4,7 +4,7 @@
 #
 from twisted.web import client
 from twisted.internet import reactor
-import md5
+import hashlib
 from zope.interface import implements
 
 class IChangeNotified:
@@ -53,7 +53,7 @@
     def page(self, p):
         if p is None:
             return self.gotMD5(None)
-        m = md5.new()
+        m = hashlib.md5()
         m.update(p)
         self.gotMD5(m.digest())
 
Index: twisted/mail/test/test_mail.py
===================================================================
--- twisted/mail/test/test_mail.py	(revision 22614)
+++ twisted/mail/test/test_mail.py	(working copy)
@@ -7,7 +7,7 @@
 
 import os
 import errno
-import md5
+import hashlib
 import shutil
 import pickle
 import StringIO
@@ -587,7 +587,7 @@
         shutil.rmtree(self.tmpdir)
 
     def testAuthenticateAPOP(self):
-        resp = md5.new(self.P.magic + 'password').hexdigest()
+        resp = hashlib.md5(self.P.magic + 'password').hexdigest()
         return self.P.authenticateUserAPOP('user', resp
             ).addCallback(self._cbAuthenticateAPOP
             )
@@ -599,13 +599,13 @@
         result[2]()
 
     def testAuthenticateIncorrectUserAPOP(self):
-        resp = md5.new(self.P.magic + 'password').hexdigest()
+        resp = hashlib.md5(self.P.magic + 'password').hexdigest()
         return self.assertFailure(
             self.P.authenticateUserAPOP('resu', resp),
             cred.error.UnauthorizedLogin)
 
     def testAuthenticateIncorrectResponseAPOP(self):
-        resp = md5.new('wrong digest').hexdigest()
+        resp = hashlib.md5('wrong digest').hexdigest()
         return self.assertFailure(
             self.P.authenticateUserAPOP('user', resp),
             cred.error.UnauthorizedLogin)
Index: twisted/mail/maildir.py
===================================================================
--- twisted/mail/maildir.py	(revision 22614)
+++ twisted/mail/maildir.py	(working copy)
@@ -12,7 +12,7 @@
 import stat
 import socket
 import time
-import md5
+import hashlib
 import cStringIO
 
 from zope.interface import implements
@@ -298,7 +298,7 @@
         """
         # Returning the actual filename is a mistake.  Hash it.
         base = os.path.basename(self.list[i])
-        return md5.md5(base).hexdigest()
+        return hashlib.md5(base).hexdigest()
 
     def deleteMessage(self, i):
         """Delete a message
@@ -355,7 +355,7 @@
         return StringIO.StringIO(self.msgs[i])
 
     def getUidl(self, i):
-        return md5.new(self.msgs[i]).hexdigest()
+        return hashlib.md5(self.msgs[i]).hexdigest()
 
     def deleteMessage(self, i):
         pass
Index: twisted/mail/pop3.py
===================================================================
--- twisted/mail/pop3.py	(revision 22614)
+++ twisted/mail/pop3.py	(working copy)
@@ -15,7 +15,7 @@
 import string
 import base64
 import binascii
-import md5
+import hashlib
 import warnings
 
 from zope.interface import implements, Interface
@@ -45,7 +45,7 @@
 
     def checkPassword(self, password):
         seed = self.magic + password
-        myDigest = md5.new(seed).hexdigest()
+        myDigest = hashlib.md5(seed).hexdigest()
         return myDigest == self.digest
 
 
@@ -1032,7 +1032,7 @@
             self._dispatch(self.command+"_continue", None, line)
 
     def apopAuthenticate(self, user, password, magic):
-        digest = md5.new(magic + password).hexdigest()
+        digest = hashlib.md5(magic + password).hexdigest()
         self.apop(user, digest)
 
     def apop(self, user, digest):
Index: twisted/trial/test/test_loader.py
===================================================================
--- twisted/trial/test/test_loader.py	(revision 22614)
+++ twisted/trial/test/test_loader.py	(working copy)
@@ -1,5 +1,5 @@
 
-import md5
+import hashlib
 import os
 import shutil
 
@@ -468,7 +468,7 @@
 #             if isinstance(s, type) or isinstance(s, types.ClassType):
 #                 return s.__module__+'.'+s.__name__
             n = runner.name(s)
-            d = md5.new(n).hexdigest()
+            d = hashlib.md5(n).hexdigest()
             return d
         self.loadSortedPackages(sillySorter)
 
Index: twisted/spread/pb.py
===================================================================
--- twisted/spread/pb.py	(revision 22614)
+++ twisted/spread/pb.py	(working copy)
@@ -63,7 +63,7 @@
 except ImportError:
     import StringIO
 
-import md5
+import hashlib
 import random
 import new
 import types
@@ -1006,10 +1006,10 @@
 
     This is useful for challenge/response authentication.
     """
-    m = md5.new()
+    m = hashlib.md5()
     m.update(password)
     hashedPassword = m.digest()
-    m = md5.new()
+    m = hashlib.md5()
     m.update(hashedPassword)
     m.update(challenge)
     doubleHashedPassword = m.digest()
@@ -1020,7 +1020,7 @@
     crap = ''
     for x in range(random.randrange(15,25)):
         crap = crap + chr(random.randint(65,90))
-    crap = md5.new(crap).digest()
+    crap = hashlib.md5(crap).digest()
     return crap
 
 
@@ -1336,12 +1336,12 @@
 
     # IUsernameHashedPassword:
     def checkPassword(self, password):
-        return self.checkMD5Password(md5.md5(password).digest())
+        return self.checkMD5Password(hashlib.md5(password).digest())
 
 
     # IUsernameMD5Password
     def checkMD5Password(self, md5Password):
-        md = md5.new()
+        md = hashlib.md5()
         md.update(md5Password)
         md.update(self.challenge)
         correct = md.digest()
