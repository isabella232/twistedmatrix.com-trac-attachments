diff --git twisted/python/reflect.py twisted/python/reflect.py
index 4baf090..5846a7e 100644
--- twisted/python/reflect.py
+++ twisted/python/reflect.py
@@ -23,7 +23,6 @@ try:
 except ImportError:
     from StringIO import StringIO
 
-from twisted.python.deprecate import deprecated, deprecatedModuleAttribute
 from twisted.python.deprecate import _fullyQualifiedName as fullyQualifiedName
 from twisted.python.versions import Version
 
@@ -36,246 +35,6 @@ from twisted.python._reflectpy3 import ObjectNotFound, namedAny
 from twisted.python._reflectpy3 import filenameToModuleName
 from twisted.python._reflectpy3 import qual, safe_str, safe_repr
 
-class Settable:
-    """
-    A mixin class for syntactic sugar.  Lets you assign attributes by
-    calling with keyword arguments; for example, C{x(a=b,c=d,y=z)} is the
-    same as C{x.a=b;x.c=d;x.y=z}.  The most useful place for this is
-    where you don't want to name a variable, but you do want to set
-    some attributes; for example, C{X()(y=z,a=b)}.
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "Settable is old and untested. Please write your own version of this "
-        "functionality if you need it.", "twisted.python.reflect", "Settable")
-
-    def __init__(self, **kw):
-        self(**kw)
-
-    def __call__(self,**kw):
-        for key,val in kw.items():
-            setattr(self,key,val)
-        return self
-
-
-class AccessorType(type):
-    """
-    Metaclass that generates properties automatically.
-
-    This is for Python 2.2 and up.
-
-    Using this metaclass for your class will give you explicit accessor
-    methods; a method called set_foo, will automatically create a property
-    'foo' that uses set_foo as a setter method. Same for get_foo and del_foo.
-
-    Note that this will only work on methods that are present on class
-    creation. If you add methods after the class is defined they will not
-    automatically become properties. Likewise, class attributes will only
-    be used if they are present upon class creation, and no getter function
-    was set - if a getter is present, the class attribute will be ignored.
-
-    This is a 2.2-only alternative to the Accessor mixin - just set in your
-    class definition::
-
-        __metaclass__ = AccessorType
-
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "AccessorType is old and untested. Please write your own version of "
-        "this functionality if you need it.", "twisted.python.reflect",
-        "AccessorType")
-
-    def __init__(self, name, bases, d):
-        type.__init__(self, name, bases, d)
-        accessors = {}
-        prefixs = ["get_", "set_", "del_"]
-        for k in d.keys():
-            v = getattr(self, k)
-            for i in range(3):
-                if k.startswith(prefixs[i]):
-                    accessors.setdefault(k[4:], [None, None, None])[i] = v
-        for name, (getter, setter, deler) in accessors.items():
-            # create default behaviours for the property - if we leave
-            # the getter as None we won't be able to getattr, etc..
-            if getter is None:
-                if hasattr(self, name):
-                    value = getattr(self, name)
-                    def getter(this, value=value, name=name):
-                        if name in this.__dict__:
-                            return this.__dict__[name]
-                        else:
-                            return value
-                else:
-                    def getter(this, name=name):
-                        if name in this.__dict__:
-                            return this.__dict__[name]
-                        else:
-                            raise AttributeError("no such attribute %r" % name)
-            if setter is None:
-                def setter(this, value, name=name):
-                    this.__dict__[name] = value
-            if deler is None:
-                def deler(this, name=name):
-                    del this.__dict__[name]
-            setattr(self, name, property(getter, setter, deler, ""))
-
-
-class PropertyAccessor(object):
-    """
-    A mixin class for Python 2.2 that uses AccessorType.
-
-    This provides compatability with the pre-2.2 Accessor mixin, up
-    to a point.
-
-    Extending this class will give you explicit accessor methods; a
-    method called set_foo, for example, is the same as an if statement
-    in __setattr__ looking for 'foo'.  Same for get_foo and del_foo.
-
-    There are also reallyDel and reallySet methods, so you can
-    override specifics in subclasses without clobbering __setattr__
-    and __getattr__, or using non-2.1 compatible code.
-
-    There is are incompatibilities with Accessor - accessor
-    methods added after class creation will *not* be detected. OTOH,
-    this method is probably way faster.
-
-    In addition, class attributes will only be used if no getter
-    was defined, and instance attributes will not override getter methods
-    whereas in original Accessor the class attribute or instance attribute
-    would override the getter method.
-    """
-    # addendum to above:
-    # The behaviour of Accessor is wrong IMHO, and I've found bugs
-    # caused by it.
-    #  -- itamar
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "PropertyAccessor is old and untested. Please write your own version "
-        "of this functionality if you need it.", "twisted.python.reflect",
-        "PropertyAccessor")
-    __metaclass__ = AccessorType
-
-    def reallySet(self, k, v):
-        self.__dict__[k] = v
-
-    def reallyDel(self, k):
-        del self.__dict__[k]
-
-
-class Accessor:
-    """
-    Extending this class will give you explicit accessor methods; a
-    method called C{set_foo}, for example, is the same as an if statement
-    in L{__setattr__} looking for C{'foo'}.  Same for C{get_foo} and
-    C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
-    so you can override specifics in subclasses without clobbering
-    L{__setattr__} and L{__getattr__}.
-
-    This implementation is for Python 2.1.
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "Accessor is an implementation for Python 2.1 which is no longer "
-        "supported by Twisted.", "twisted.python.reflect", "Accessor")
-
-    def __setattr__(self, k,v):
-        kstring='set_%s'%k
-        if hasattr(self.__class__,kstring):
-            return getattr(self,kstring)(v)
-        else:
-            self.reallySet(k,v)
-
-    def __getattr__(self, k):
-        kstring='get_%s'%k
-        if hasattr(self.__class__,kstring):
-            return getattr(self,kstring)()
-        raise AttributeError("%s instance has no accessor for: %s" % (qual(self.__class__),k))
-
-    def __delattr__(self, k):
-        kstring='del_%s'%k
-        if hasattr(self.__class__,kstring):
-            getattr(self,kstring)()
-            return
-        self.reallyDel(k)
-
-    def reallySet(self, k,v):
-        """
-        *actually* set self.k to v without incurring side-effects.
-        This is a hook to be overridden by subclasses.
-        """
-        if k == "__dict__":
-            self.__dict__.clear()
-            self.__dict__.update(v)
-        else:
-            self.__dict__[k]=v
-
-    def reallyDel(self, k):
-        """
-        *actually* del self.k without incurring side-effects.  This is a
-        hook to be overridden by subclasses.
-        """
-        del self.__dict__[k]
-
-# just in case
-OriginalAccessor = Accessor
-deprecatedModuleAttribute(
-    Version("Twisted", 12, 1, 0),
-    "OriginalAccessor is a reference to class twisted.python.reflect.Accessor "
-    "which is deprecated.", "twisted.python.reflect", "OriginalAccessor")
-
-
-class Summer(Accessor):
-    """
-    Extend from this class to get the capability to maintain 'related
-    sums'.  Have a tuple in your class like the following::
-
-        sums=(('amount','credit','credit_total'),
-              ('amount','debit','debit_total'))
-
-    and the 'credit_total' member of the 'credit' member of self will
-    always be incremented when the 'amount' member of self is
-    incremented, similiarly for the debit versions.
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "Summer is a child class of twisted.python.reflect.Accessor which is " 
-        "deprecated.", "twisted.python.reflect", "Summer")
-
-    def reallySet(self, k,v):
-        "This method does the work."
-        for sum in self.sums:
-            attr=sum[0]
-            obj=sum[1]
-            objattr=sum[2]
-            if k == attr:
-                try:
-                    oldval=getattr(self, attr)
-                except:
-                    oldval=0
-                diff=v-oldval
-                if hasattr(self, obj):
-                    ob=getattr(self,obj)
-                    if ob is not None:
-                        try:oldobjval=getattr(ob, objattr)
-                        except:oldobjval=0.0
-                        setattr(ob,objattr,oldobjval+diff)
-
-            elif k == obj:
-                if hasattr(self, attr):
-                    x=getattr(self,attr)
-                    setattr(self,attr,0)
-                    y=getattr(self,k)
-                    Accessor.reallySet(self,k,v)
-                    setattr(self,attr,x)
-                    Accessor.reallySet(self,y,v)
-        Accessor.reallySet(self,k,v)
-
 
 class QueueMethod:
     """
@@ -370,30 +129,6 @@ def isinst(inst,clazz):
 
 ## the following were factored out of usage
 
-@deprecated(Version("Twisted", 11, 0, 0), "inspect.getmro")
-def allYourBase(classObj, baseClass=None):
-    """
-    allYourBase(classObj, baseClass=None) -> list of all base
-    classes that are subclasses of baseClass, unless it is None,
-    in which case all bases will be added.
-    """
-    l = []
-    _accumulateBases(classObj, l, baseClass)
-    return l
-
-
-@deprecated(Version("Twisted", 11, 0, 0), "inspect.getmro")
-def accumulateBases(classObj, l, baseClass=None):
-    _accumulateBases(classObj, l, baseClass)
-
-
-def _accumulateBases(classObj, l, baseClass=None):
-    for base in classObj.__bases__:
-        if baseClass is None or issubclass(base, baseClass):
-            l.append(base)
-        _accumulateBases(base, l, baseClass)
-
-
 def accumulateClassDict(classObj, attr, adict, baseClass=None):
     """
     Accumulate all attributes of a given name in a class hierarchy into a single dictionary.
@@ -519,12 +254,11 @@ __all__ = [
 
     'ISNT', 'WAS', 'IS',
 
-    'Settable', 'AccessorType', 'PropertyAccessor', 'Accessor', 'Summer',
-    'QueueMethod', 'OriginalAccessor',
+    'QueueMethod',
 
     'funcinfo', 'fullFuncName', 'qual', 'getcurrent', 'getClass', 'isinst',
     'namedModule', 'namedObject', 'namedClass', 'namedAny',
-    'safe_repr', 'safe_str', 'allYourBase', 'accumulateBases',
+    'safe_repr', 'safe_str',
     'prefixedMethodNames', 'addMethodNamesToDict', 'prefixedMethods',
     'accumulateMethods',
     'accumulateClassDict', 'accumulateClassList', 'isSame', 'isLike',
diff --git twisted/test/test_reflect.py twisted/test/test_reflect.py
index 4a66211..50229a2 100644
--- twisted/test/test_reflect.py
+++ twisted/test/test_reflect.py
@@ -19,134 +19,6 @@ from twisted.python import reflect
 from twisted.python.versions import Version
 from twisted.python.test.test_reflectpy3 import LookupsTestCase
 
-with warnings.catch_warnings():
-    warnings.filterwarnings(action="ignore", category=DeprecationWarning,
-            message="twisted.python.reflect.Accessor was deprecated")
-    warnings.filterwarnings(action="ignore", category=DeprecationWarning,
-            message="twisted.python.reflect.PropertyAccessor was deprecated")
-    warnings.filterwarnings(action="ignore", category=DeprecationWarning,
-            message="twisted.python.reflect.Settable was deprecated")
-
-    from twisted.python.reflect import Accessor, PropertyAccessor, Settable
-
-
-class SettableTest(unittest.TestCase):
-    def setUp(self):
-        self.setter = Settable()
-
-    def tearDown(self):
-        del self.setter
-
-    def testSet(self):
-        self.setter(a=1, b=2)
-        self.assertEqual(self.setter.a, 1)
-        self.assertEqual(self.setter.b, 2)
-
-
-
-class AccessorTester(Accessor):
-
-    def set_x(self, x):
-        self.y = x
-        self.reallySet('x', x)
-
-
-    def get_z(self):
-        self.q = 1
-        return 1
-
-
-    def del_z(self):
-        self.reallyDel("q")
-
-
-
-class PropertyAccessorTester(PropertyAccessor):
-    """
-    Test class to check L{reflect.PropertyAccessor} functionalities.
-    """
-    r = 0
-
-    def set_r(self, r):
-        self.s = r
-
-
-    def set_x(self, x):
-        self.y = x
-        self.reallySet('x', x)
-
-
-    def get_z(self):
-        self.q = 1
-        return 1
-
-
-    def del_z(self):
-        self.reallyDel("q")
-
-
-
-class AccessorTest(unittest.TestCase):
-    def setUp(self):
-        self.tester = AccessorTester()
-
-    def testSet(self):
-        self.tester.x = 1
-        self.assertEqual(self.tester.x, 1)
-        self.assertEqual(self.tester.y, 1)
-
-    def testGet(self):
-        self.assertEqual(self.tester.z, 1)
-        self.assertEqual(self.tester.q, 1)
-
-    def testDel(self):
-        self.tester.z
-        self.assertEqual(self.tester.q, 1)
-        del self.tester.z
-        self.assertEqual(hasattr(self.tester, "q"), 0)
-        self.tester.x = 1
-        del self.tester.x
-        self.assertEqual(hasattr(self.tester, "x"), 0)
-
-
-
-class PropertyAccessorTest(AccessorTest):
-    """
-    Tests for L{reflect.PropertyAccessor}, using L{PropertyAccessorTester}.
-    """
-
-    def setUp(self):
-        self.tester = PropertyAccessorTester()
-
-
-    def test_setWithDefaultValue(self):
-        """
-        If an attribute is present in the class, it can be retrieved by
-        default.
-        """
-        self.assertEqual(self.tester.r, 0)
-        self.tester.r = 1
-        self.assertEqual(self.tester.r, 0)
-        self.assertEqual(self.tester.s, 1)
-
-
-    def test_getValueInDict(self):
-        """
-        The attribute value can be overriden by directly modifying the value in
-        C{__dict__}.
-        """
-        self.tester.__dict__["r"] = 10
-        self.assertEqual(self.tester.r, 10)
-
-
-    def test_notYetInDict(self):
-        """
-        If a getter is defined on an attribute but without any default value,
-        it raises C{AttributeError} when trying to access it.
-        """
-        self.assertRaises(AttributeError, getattr, self.tester, "x")
-
-
 
 class ImportHooksLookupTests(unittest.TestCase, LookupsTestCase):
     """
@@ -307,119 +179,3 @@ class GetClass(unittest.TestCase):
         new = NewClass()
         self.assertEqual(reflect.getClass(NewClass).__name__, 'type')
         self.assertEqual(reflect.getClass(new).__name__, 'NewClass')
-
-
-
-class DeprecationTestCase(unittest.TestCase):
-    """
-    Test deprecations in twisted.python.reflect
-    """
-
-    def test_allYourBase(self):
-        """
-        Test deprecation of L{reflect.allYourBase}. See #5481 for removal.
-        """
-        self.callDeprecated(
-            (Version("Twisted", 11, 0, 0), "inspect.getmro"),
-            reflect.allYourBase, DeprecationTestCase)
-
-
-    def test_accumulateBases(self):
-        """
-        Test deprecation of L{reflect.accumulateBases}. See #5481 for removal.
-        """
-        l = []
-        self.callDeprecated(
-            (Version("Twisted", 11, 0, 0), "inspect.getmro"),
-            reflect.accumulateBases, DeprecationTestCase, l, None)
-
-
-    def lookForDeprecationWarning(self, testMethod, attributeName, warningMsg):
-        """
-        Test deprecation of attribute 'reflect.attributeName' by calling
-        'reflect.testMethod' and verifying the warning message
-        'reflect.warningMsg'
-
-        @param testMethod: Name of the offending function to be used with
-            flushWarnings
-        @type testmethod: C{str}
-
-        @param attributeName: Name of attribute to be checked for deprecation
-        @type attributeName: C{str}
-
-        @param warningMsg: Deprecation warning message
-        @type warningMsg: C{str}
-        """
-        warningsShown = self.flushWarnings([testMethod])
-        self.assertEqual(len(warningsShown), 1)
-        self.assertIdentical(warningsShown[0]['category'], DeprecationWarning)
-        self.assertEqual(
-            warningsShown[0]['message'],
-            "twisted.python.reflect." + attributeName + " "
-            "was deprecated in Twisted 12.1.0: " + warningMsg + ".")
-
-
-    def test_settable(self):
-        """
-        Test deprecation of L{reflect.Settable}.
-        """
-        reflect.Settable()
-        self.lookForDeprecationWarning(
-            self.test_settable, "Settable",
-            "Settable is old and untested. Please write your own version of this "
-            "functionality if you need it")
-
-
-    def test_accessorType(self):
-        """
-        Test deprecation of L{reflect.AccessorType}.
-        """
-        reflect.AccessorType(' ', ( ), { })
-        self.lookForDeprecationWarning(
-            self.test_accessorType, "AccessorType",
-            "AccessorType is old and untested. Please write your own version of "
-            "this functionality if you need it")
-
-
-    def test_propertyAccessor(self):
-        """
-        Test deprecation of L{reflect.PropertyAccessor}.
-        """
-        reflect.PropertyAccessor()
-        self.lookForDeprecationWarning(
-            self.test_propertyAccessor, "PropertyAccessor",
-            "PropertyAccessor is old and untested. Please write your own "
-            "version of this functionality if you need it")
-
-
-    def test_accessor(self):
-        """
-        Test deprecation of L{reflect.Accessor}.
-        """
-        reflect.Accessor()
-        self.lookForDeprecationWarning(
-            self.test_accessor, "Accessor",
-            "Accessor is an implementation for Python 2.1 which is no longer "
-            "supported by Twisted")
-
-
-    def test_originalAccessor(self):
-        """
-        Test deprecation of L{reflect.OriginalAccessor}.
-        """
-        reflect.OriginalAccessor()
-        self.lookForDeprecationWarning(
-            self.test_originalAccessor, "OriginalAccessor",
-            "OriginalAccessor is a reference to class "
-            "twisted.python.reflect.Accessor which is deprecated")
-
-
-    def test_summer(self):
-        """
-        Test deprecation of L{reflect.Summer}.
-        """
-        reflect.Summer()
-        self.lookForDeprecationWarning(
-            self.test_summer, "Summer",
-            "Summer is a child class of twisted.python.reflect.Accessor which "
-            "is deprecated")
diff --git twisted/topfiles/6689.removal twisted/topfiles/6689.removal
new file mode 100644
index 0000000..be9a857
--- /dev/null
+++ twisted/topfiles/6689.removal
@@ -0,0 +1 @@
+accumulateBases, allYourBase, Accessor, AccessorType, OriginalAccessor, PropertyAccessor, Settable and Summer in twisted.python.reflect, deprecated since Twisted 12.1.0, are now removed.
