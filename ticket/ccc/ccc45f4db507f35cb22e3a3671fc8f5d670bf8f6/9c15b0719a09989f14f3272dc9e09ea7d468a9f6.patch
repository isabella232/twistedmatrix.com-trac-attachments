diff --git twisted/names/dns.py twisted/names/dns.py
index 50fef18..eebd26c 100644
--- twisted/names/dns.py
+++ twisted/names/dns.py
@@ -14,10 +14,12 @@ from __future__ import division, absolute_import
 __all__ = [
     'IEncodable', 'IRecord',
 
-    'A', 'A6', 'AAAA', 'AFSDB', 'CNAME', 'DNAME', 'HINFO',
-    'MAILA', 'MAILB', 'MB', 'MD', 'MF', 'MG', 'MINFO', 'MR', 'MX',
-    'NAPTR', 'NS', 'NULL', 'OPT', 'PTR', 'RP', 'SOA', 'SPF', 'SRV', 'TXT',
-    'WKS',
+    'A', 'A6', 'AAAA', 'AFSDB', 'APL', 'ATMA', 'CERT', 'CNAME', 'DHCID',
+    'DNAME', 'DNSKEY', 'DS', 'EID', 'GPOS', 'HINFO', 'IPSECKEY', 'ISDN',
+    'KEY', 'KX', 'LOC', 'MAILA', 'MAILB', 'MB', 'MD', 'MF', 'MG', 'MINFO',
+    'MR', 'MX', 'NAPTR', 'NIMLOC', 'NS', 'NSAP', 'NSAPPTR', 'NSEC', 'NSEC3',
+    'NSEC3PARAM', 'NULL', 'NULL', 'NXT', 'OPT', 'PTR', 'PX', 'RP', 'RRSIG',
+    'RT', 'SIG', 'SINK', 'SOA', 'SPF', 'SRV', 'SSHFP', 'TXT', 'WKS', 'X25',
 
     'ANY', 'CH', 'CS', 'HS', 'IN',
 
@@ -112,44 +114,67 @@ def randomSource():
 PORT = 53
 
 (A, NS, MD, MF, CNAME, SOA, MB, MG, MR, NULL, WKS, PTR, HINFO, MINFO, MX, TXT,
- RP, AFSDB) = range(1, 19)
-AAAA = 28
-SRV = 33
-NAPTR = 35
-A6 = 38
-DNAME = 39
-OPT = 41
+ RP, AFSDB, X25, ISDN, RT, NSAP, NSAPPTR, SIG, KEY, PX, GPOS, AAAA, LOC, NXT,
+ EID, NIMLOC, SRV, ATMA, NAPTR, KX, CERT, A6, DNAME, SINK, OPT, APL, DS,
+ SSHFP, IPSECKEY, RRSIG, NSEC, DNSKEY, DHCID, NSEC3, NSEC3PARAM, TLSA
+ ) = range(1, 53)
+
 SPF = 99
 
 QUERY_TYPES = {
-    A: 'A',
-    NS: 'NS',
-    MD: 'MD',
-    MF: 'MF',
-    CNAME: 'CNAME',
-    SOA: 'SOA',
-    MB: 'MB',
-    MG: 'MG',
-    MR: 'MR',
-    NULL: 'NULL',
-    WKS: 'WKS',
-    PTR: 'PTR',
-    HINFO: 'HINFO',
-    MINFO: 'MINFO',
-    MX: 'MX',
-    TXT: 'TXT',
-    RP: 'RP',
-    AFSDB: 'AFSDB',
-
-    # 19 through 27?  Eh, I'll get to 'em.
-
-    AAAA: 'AAAA',
-    SRV: 'SRV',
-    NAPTR: 'NAPTR',
-    A6: 'A6',
-    DNAME: 'DNAME',
-    OPT: 'OPT',
-    SPF: 'SPF'
+    A: 'A', # (1) RFC1035
+    NS: 'NS', # (2) RFC1035
+    MD: 'MD', # (3) RFC1035
+    MF: 'MF', # (4) RFC1035
+    CNAME: 'CNAME', # (5) RFC1035
+    SOA: 'SOA', # (6) RFC1035
+    MB: 'MB', # (7) RFC1035
+    MG: 'MG', # (8) RFC1035
+    MR: 'MR', # (9) RFC1035
+    NULL: 'NULL', # (10) RFC1035
+    WKS: 'WKS', # (11) RFC1035
+    PTR: 'PTR', # (12) RFC1035
+    HINFO: 'HINFO', # (13) RFC1035
+    MINFO: 'MINFO', # (14) RFC1035
+    MX: 'MX', # (15) RFC1035
+    TXT: 'TXT', # (16) RFC1035
+    RP: 'RP', # (17) RFC1183
+    AFSDB: 'AFSDB', # (18) RFC1183
+    X25: 'X25', # (19) RFC1183
+    ISDN: 'ISDN', # (20) RFC1183
+    RT: 'RT', # (21) RFC1183
+    NSAP: 'NSAP', # (22) RFC1706
+    NSAPPTR: 'NSAP-PTR', # NSAP-PTR (23) RFC1348, RFC1637, RFC1706
+    SIG: 'SIG', # (24) RFC4034, RFC3755, RFC2535, RFC2536, RFC2537...
+    KEY: 'KEY', # (25) RFC4034, RFC3755, RFC2535, RFC2536, RFC2537...
+    PX: 'PX', # (26) RFC2163
+    GPOS: 'GPOS', # (27) RFC1712
+    AAAA: 'AAAA', # (28) RFC3596
+    LOC: 'LOC', # (29) RFC1876)
+    NXT: 'NXT', # (30) RFC3755, RFC2535
+    EID: 'EID', # (31)
+    NIMLOC: 'NIMLOC', # (32
+    SRV: 'SRV', # (33) RFC2782
+    ATMA: 'ATMA', # (34)
+    NAPTR: 'NAPTR', # (35) RFC2915, RFC2168, RFC3403
+    KX: 'KX', # (36) RFC2230
+    CERT: 'CERT', # (37) RFC4398
+    A6: 'A6', # (38) RFC3226, RFC2874, RFC6563
+    DNAME: 'DNAME', # (39) RFC6672
+    SINK: 'SINK', # (40)
+    OPT: 'OPT', # (41) RFC6891, RFC3225
+    APL: 'APL', # (42) RFC3123
+    DS: 'DS', # (43) RFC4034, RFC3658
+    SSHFP: 'SSHFP', # (44) RFC4255
+    IPSECKEY: 'IPSECKEY', # (45) RFC4025
+    RRSIG: 'RRSIG', # (46) RFC4034, RFC3755
+    NSEC: 'NSEC', # (47) RFC4034, RFC3755
+    DNSKEY: 'DNSKEY', # (48) RFC4034, RFC3755
+    DHCID: 'DHCID', # (49) RFC4701
+    NSEC3: 'NSEC3', # (50) RFC5155
+    NSEC3PARAM: 'NSEC3PARAM', # (51) RFC5155
+    TLSA: 'TLSA', # (52) RFC6698
+    SPF: 'SPF', # (99) RFC7208
 }
 
 IXFR, AXFR, MAILB, MAILA, ALL_RECORDS = range(251, 256)
@@ -949,152 +974,97 @@ class SimpleRecord(tputil.FancyStrMixin, tputil.FancyEqMixin):
         return hash(self.name)
 
 
-# Kinds of RRs - oh my!
-class Record_NS(SimpleRecord):
-    """
-    An authoritative nameserver.
-    """
-    TYPE = NS
-    fancybasename = 'NS'
-
-
 
-class Record_MD(SimpleRecord):
+@implementer(IEncodable, IRecord)
+class AddressRecord(tputil.FancyStrMixin, tputil.FancyEqMixin):
     """
-    A mail destination.
+    A Resource Record for either A or AAAA records
 
-    This record type is obsolete.
+    @type address: C{str}
+    @ivar address: The packed network-order representation of the IP address
+        associated with this record.
 
-    @see: L{Record_MX}
+    @type ttl: C{int}
+    @ivar ttl: The maximum number of seconds which this record should be
+        cached.
     """
-    TYPE = MD
-    fancybasename = 'MD'
-
+    compareAttributes = ('address', 'ttl')
+    showAttributes = (('_address', 'address', '%s'), 'ttl')
 
+    address = None
 
-class Record_MF(SimpleRecord):
-    """
-    A mail forwarder.
+    def encode(self, strio, compDict = None):
+        strio.write(self.address)
 
-    This record type is obsolete.
+    def decode(self, strio, length = None):
+        self.address = readPrecisely(strio, self.LEN)
 
-    @see: L{Record_MX}
-    """
-    TYPE = MF
-    fancybasename = 'MF'
+    def __hash__(self):
+        return hash(self.address)
 
 
 
-class Record_CNAME(SimpleRecord):
+class Record_A(AddressRecord):
     """
-    The canonical name for an alias.
+    An IPv4 host address.
     """
-    TYPE = CNAME
-    fancybasename = 'CNAME'
-
+    TYPE = A
+    fancybasename = 'A'
+    LEN = 4
 
+    _address = property(lambda self: self.dottedQuad())
 
-class Record_MB(SimpleRecord):
-    """
-    A mailbox domain name.
+    def __init__(self, address='0.0.0.0', ttl=None):
+        address = socket.inet_aton(address)
+        self.address = address
+        self.ttl = str2time(ttl)
 
-    This is an experimental record type.
-    """
-    TYPE = MB
-    fancybasename = 'MB'
+    def dottedQuad(self):
+        return socket.inet_ntoa(self.address)
 
 
 
-class Record_MG(SimpleRecord):
+class Record_NS(SimpleRecord):
     """
-    A mail group member.
-
-    This is an experimental record type.
+    An authoritative nameserver.
     """
-    TYPE = MG
-    fancybasename = 'MG'
-
+    TYPE = NS
+    fancybasename = 'NS'
 
 
-class Record_MR(SimpleRecord):
-    """
-    A mail rename domain name.
 
-    This is an experimental record type.
+class Record_MD(SimpleRecord):
     """
-    TYPE = MR
-    fancybasename = 'MR'
-
+    A mail destination.
 
+    This record type is obsolete.
 
-class Record_PTR(SimpleRecord):
-    """
-    A domain name pointer.
+    @see: L{Record_MX}
     """
-    TYPE = PTR
-    fancybasename = 'PTR'
+    TYPE = MD
+    fancybasename = 'MD'
 
 
 
-class Record_DNAME(SimpleRecord):
+class Record_MF(SimpleRecord):
     """
-    A non-terminal DNS name redirection.
+    A mail forwarder.
 
-    This record type provides the capability to map an entire subtree of the
-    DNS name space to another domain.  It differs from the CNAME record which
-    maps a single node of the name space.
+    This record type is obsolete.
 
-    @see: U{http://www.faqs.org/rfcs/rfc2672.html}
-    @see: U{http://www.faqs.org/rfcs/rfc3363.html}
+    @see: L{Record_MX}
     """
-    TYPE = DNAME
-    fancybasename = 'DNAME'
+    TYPE = MF
+    fancybasename = 'MF'
 
 
 
-@implementer(IEncodable, IRecord)
-class Record_A(tputil.FancyEqMixin):
+class Record_CNAME(SimpleRecord):
     """
-    An IPv4 host address.
-
-    @type address: C{str}
-    @ivar address: The packed network-order representation of the IPv4 address
-        associated with this record.
-
-    @type ttl: C{int}
-    @ivar ttl: The maximum number of seconds which this record should be
-        cached.
+    The canonical name for an alias.
     """
-    compareAttributes = ('address', 'ttl')
-
-    TYPE = A
-    address = None
-
-    def __init__(self, address='0.0.0.0', ttl=None):
-        address = socket.inet_aton(address)
-        self.address = address
-        self.ttl = str2time(ttl)
-
-
-    def encode(self, strio, compDict = None):
-        strio.write(self.address)
-
-
-    def decode(self, strio, length = None):
-        self.address = readPrecisely(strio, 4)
-
-
-    def __hash__(self):
-        return hash(self.address)
-
-
-    def __str__(self):
-        return '<A address=%s ttl=%s>' % (self.dottedQuad(), self.ttl)
-    __repr__ = __str__
-
-
-    def dottedQuad(self):
-        return socket.inet_ntoa(self.address)
+    TYPE = CNAME
+    fancybasename = 'CNAME'
 
 
 
@@ -1181,6 +1151,39 @@ class Record_SOA(tputil.FancyEqMixin, tputil.FancyStrMixin):
 
 
 
+class Record_MB(SimpleRecord):
+    """
+    A mailbox domain name.
+
+    This is an experimental record type.
+    """
+    TYPE = MB
+    fancybasename = 'MB'
+
+
+
+class Record_MG(SimpleRecord):
+    """
+    A mail group member.
+
+    This is an experimental record type.
+    """
+    TYPE = MG
+    fancybasename = 'MG'
+
+
+
+class Record_MR(SimpleRecord):
+    """
+    A mail rename domain name.
+
+    This is an experimental record type.
+    """
+    TYPE = MR
+    fancybasename = 'MR'
+
+
+
 @implementer(IEncodable, IRecord)
 class Record_NULL(tputil.FancyStrMixin, tputil.FancyEqMixin):
     """
@@ -1270,290 +1273,255 @@ class Record_WKS(tputil.FancyEqMixin, tputil.FancyStrMixin):
 
 
 
+class Record_PTR(SimpleRecord):
+    """
+    A domain name pointer.
+    """
+    TYPE = PTR
+    fancybasename = 'PTR'
+
+
+
 @implementer(IEncodable, IRecord)
-class Record_AAAA(tputil.FancyEqMixin, tputil.FancyStrMixin):
+class Record_HINFO(tputil.FancyStrMixin, tputil.FancyEqMixin):
     """
-    An IPv6 host address.
+    Host information.
 
-    @type address: C{str}
-    @ivar address: The packed network-order representation of the IPv6 address
-        associated with this record.
+    @type cpu: C{str}
+    @ivar cpu: Specifies the CPU type.
+
+    @type os: C{str}
+    @ivar os: Specifies the OS.
 
     @type ttl: C{int}
     @ivar ttl: The maximum number of seconds which this record should be
         cached.
-
-    @see: U{http://www.faqs.org/rfcs/rfc1886.html}
     """
-    TYPE = AAAA
-
-    fancybasename = 'AAAA'
-    showAttributes = (('_address', 'address', '%s'), 'ttl')
-    compareAttributes = ('address', 'ttl')
+    TYPE = HINFO
 
-    _address = property(lambda self: socket.inet_ntop(AF_INET6, self.address))
+    fancybasename = 'HINFO'
+    showAttributes = (('cpu', _nicebytes), ('os', _nicebytes), 'ttl')
+    compareAttributes = ('cpu', 'os', 'ttl')
 
-    def __init__(self, address='::', ttl=None):
-        self.address = socket.inet_pton(AF_INET6, address)
+    def __init__(self, cpu='', os='', ttl=None):
+        self.cpu, self.os = cpu, os
         self.ttl = str2time(ttl)
 
 
     def encode(self, strio, compDict = None):
-        strio.write(self.address)
+        strio.write(struct.pack('!B', len(self.cpu)) + self.cpu)
+        strio.write(struct.pack('!B', len(self.os)) + self.os)
 
 
     def decode(self, strio, length = None):
-        self.address = readPrecisely(strio, 16)
+        cpu = struct.unpack('!B', readPrecisely(strio, 1))[0]
+        self.cpu = readPrecisely(strio, cpu)
+        os = struct.unpack('!B', readPrecisely(strio, 1))[0]
+        self.os = readPrecisely(strio, os)
+
+
+    def __eq__(self, other):
+        if isinstance(other, Record_HINFO):
+            return (self.os.lower() == other.os.lower() and
+                    self.cpu.lower() == other.cpu.lower() and
+                    self.ttl == other.ttl)
+        return NotImplemented
 
 
     def __hash__(self):
-        return hash(self.address)
+        return hash((self.os.lower(), self.cpu.lower()))
 
 
 
 @implementer(IEncodable, IRecord)
-class Record_A6(tputil.FancyStrMixin, tputil.FancyEqMixin):
+class Record_MINFO(tputil.FancyEqMixin, tputil.FancyStrMixin):
     """
-    An IPv6 address.
+    Mailbox or mail list information.
 
     This is an experimental record type.
 
-    @type prefixLen: C{int}
-    @ivar prefixLen: The length of the suffix.
-
-    @type suffix: C{str}
-    @ivar suffix: An IPv6 address suffix in network order.
-
-    @type prefix: L{Name}
-    @ivar prefix: If specified, a name which will be used as a prefix for other
-        A6 records.
+    @type rmailbx: L{Name}
+    @ivar rmailbx: A domain-name which specifies a mailbox which is responsible
+        for the mailing list or mailbox.  If this domain name names the root,
+        the owner of the MINFO RR is responsible for itself.
 
-    @type bytes: C{int}
-    @ivar bytes: The length of the prefix.
+    @type emailbx: L{Name}
+    @ivar emailbx: A domain-name which specifies a mailbox which is to receive
+        error messages related to the mailing list or mailbox specified by the
+        owner of the MINFO record.  If this domain name names the root, errors
+        should be returned to the sender of the message.
 
     @type ttl: C{int}
     @ivar ttl: The maximum number of seconds which this record should be
         cached.
+    """
+    TYPE = MINFO
 
-    @see: U{http://www.faqs.org/rfcs/rfc2874.html}
-    @see: U{http://www.faqs.org/rfcs/rfc3363.html}
-    @see: U{http://www.faqs.org/rfcs/rfc3364.html}
-    """
-    TYPE = A6
-
-    fancybasename = 'A6'
-    showAttributes = (('_suffix', 'suffix', '%s'), ('prefix', 'prefix', '%s'), 'ttl')
-    compareAttributes = ('prefixLen', 'prefix', 'suffix', 'ttl')
+    rmailbx = None
+    emailbx = None
 
-    _suffix = property(lambda self: socket.inet_ntop(AF_INET6, self.suffix))
+    fancybasename = 'MINFO'
+    compareAttributes = ('rmailbx', 'emailbx', 'ttl')
+    showAttributes = (('rmailbx', 'responsibility', '%s'),
+                      ('emailbx', 'errors', '%s'),
+                      'ttl')
 
-    def __init__(self, prefixLen=0, suffix='::', prefix=b'', ttl=None):
-        self.prefixLen = prefixLen
-        self.suffix = socket.inet_pton(AF_INET6, suffix)
-        self.prefix = Name(prefix)
-        self.bytes = int((128 - self.prefixLen) / 8.0)
+    def __init__(self, rmailbx=b'', emailbx=b'', ttl=None):
+        self.rmailbx, self.emailbx = Name(rmailbx), Name(emailbx)
         self.ttl = str2time(ttl)
 
 
     def encode(self, strio, compDict = None):
-        strio.write(struct.pack('!B', self.prefixLen))
-        if self.bytes:
-            strio.write(self.suffix[-self.bytes:])
-        if self.prefixLen:
-            # This may not be compressed
-            self.prefix.encode(strio, None)
+        self.rmailbx.encode(strio, compDict)
+        self.emailbx.encode(strio, compDict)
 
 
     def decode(self, strio, length = None):
-        self.prefixLen = struct.unpack('!B', readPrecisely(strio, 1))[0]
-        self.bytes = int((128 - self.prefixLen) / 8.0)
-        if self.bytes:
-            self.suffix = b'\x00' * (16 - self.bytes) + readPrecisely(strio, self.bytes)
-        if self.prefixLen:
-            self.prefix.decode(strio)
-
-
-    def __eq__(self, other):
-        if isinstance(other, Record_A6):
-            return (self.prefixLen == other.prefixLen and
-                    self.suffix[-self.bytes:] == other.suffix[-self.bytes:] and
-                    self.prefix == other.prefix and
-                    self.ttl == other.ttl)
-        return NotImplemented
+        self.rmailbx, self.emailbx = Name(), Name()
+        self.rmailbx.decode(strio)
+        self.emailbx.decode(strio)
 
 
     def __hash__(self):
-        return hash((self.prefixLen, self.suffix[-self.bytes:], self.prefix))
-
-
-    def __str__(self):
-        return '<A6 %s %s (%d) ttl=%s>' % (
-            self.prefix,
-            socket.inet_ntop(AF_INET6, self.suffix),
-            self.prefixLen, self.ttl
-        )
+        return hash((self.rmailbx, self.emailbx))
 
 
 
 @implementer(IEncodable, IRecord)
-class Record_SRV(tputil.FancyEqMixin, tputil.FancyStrMixin):
+class Record_MX(tputil.FancyStrMixin, tputil.FancyEqMixin):
     """
-    The location of the server(s) for a specific protocol and domain.
-
-    This is an experimental record type.
-
-    @type priority: C{int}
-    @ivar priority: The priority of this target host.  A client MUST attempt to
-        contact the target host with the lowest-numbered priority it can reach;
-        target hosts with the same priority SHOULD be tried in an order defined
-        by the weight field.
-
-    @type weight: C{int}
-    @ivar weight: Specifies a relative weight for entries with the same
-        priority. Larger weights SHOULD be given a proportionately higher
-        probability of being selected.
+    Mail exchange.
 
-    @type port: C{int}
-    @ivar port: The port on this target host of this service.
+    @type preference: C{int}
+    @ivar preference: Specifies the preference given to this RR among others at
+        the same owner.  Lower values are preferred.
 
-    @type target: L{Name}
-    @ivar target: The domain name of the target host.  There MUST be one or
-        more address records for this name, the name MUST NOT be an alias (in
-        the sense of RFC 1034 or RFC 2181).  Implementors are urged, but not
-        required, to return the address record(s) in the Additional Data
-        section.  Unless and until permitted by future standards action, name
-        compression is not to be used for this field.
+    @type name: L{Name}
+    @ivar name: A domain-name which specifies a host willing to act as a mail
+        exchange.
 
     @type ttl: C{int}
     @ivar ttl: The maximum number of seconds which this record should be
         cached.
-
-    @see: U{http://www.faqs.org/rfcs/rfc2782.html}
     """
-    TYPE = SRV
+    TYPE = MX
 
-    fancybasename = 'SRV'
-    compareAttributes = ('priority', 'weight', 'target', 'port', 'ttl')
-    showAttributes = ('priority', 'weight', ('target', 'target', '%s'), 'port', 'ttl')
+    fancybasename = 'MX'
+    compareAttributes = ('preference', 'name', 'ttl')
+    showAttributes = ('preference', ('name', 'name', '%s'), 'ttl')
 
-    def __init__(self, priority=0, weight=0, port=0, target=b'', ttl=None):
-        self.priority = int(priority)
-        self.weight = int(weight)
-        self.port = int(port)
-        self.target = Name(target)
+    def __init__(self, preference=0, name=b'', ttl=None, **kwargs):
+        self.preference, self.name = int(preference), Name(kwargs.get('exchange', name))
         self.ttl = str2time(ttl)
 
-
     def encode(self, strio, compDict = None):
-        strio.write(struct.pack('!HHH', self.priority, self.weight, self.port))
-        # This can't be compressed
-        self.target.encode(strio, None)
+        strio.write(struct.pack('!H', self.preference))
+        self.name.encode(strio, compDict)
 
 
     def decode(self, strio, length = None):
-        r = struct.unpack('!HHH', readPrecisely(strio, struct.calcsize('!HHH')))
-        self.priority, self.weight, self.port = r
-        self.target = Name()
-        self.target.decode(strio)
-
+        self.preference = struct.unpack('!H', readPrecisely(strio, 2))[0]
+        self.name = Name()
+        self.name.decode(strio)
 
     def __hash__(self):
-        return hash((self.priority, self.weight, self.port, self.target))
+        return hash((self.preference, self.name))
 
 
 
 @implementer(IEncodable, IRecord)
-class Record_NAPTR(tputil.FancyEqMixin, tputil.FancyStrMixin):
+class Record_TXT(tputil.FancyEqMixin, tputil.FancyStrMixin):
     """
-    The location of the server(s) for a specific protocol and domain.
+    Freeform text.
 
-    @type order: C{int}
-    @ivar order: An integer specifying the order in which the NAPTR records
-        MUST be processed to ensure the correct ordering of rules.  Low numbers
-        are processed before high numbers.
+    @type data: C{list} of C{bytes}
+    @ivar data: Freeform text which makes up this record.
 
-    @type preference: C{int}
-    @ivar preference: An integer that specifies the order in which NAPTR
-        records with equal "order" values SHOULD be processed, low numbers
-        being processed before high numbers.
+    @type ttl: C{int}
+    @ivar ttl: The maximum number of seconds which this record should be cached.
+    """
+    TYPE = TXT
 
-    @type flag: L{Charstr}
-    @ivar flag: A <character-string> containing flags to control aspects of the
-        rewriting and interpretation of the fields in the record.  Flags
-        are single characters from the set [A-Z0-9].  The case of the alphabetic
-        characters is not significant.
+    fancybasename = 'TXT'
+    showAttributes = (('data', _nicebyteslist), 'ttl')
+    compareAttributes = ('data', 'ttl')
 
-        At this time only four flags, "S", "A", "U", and "P", are defined.
+    def __init__(self, *data, **kw):
+        self.data = list(data)
+        # arg man python sucks so bad
+        self.ttl = str2time(kw.get('ttl', None))
 
-    @type service: L{Charstr}
-    @ivar service: Specifies the service(s) available down this rewrite path.
-        It may also specify the particular protocol that is used to talk with a
-        service.  A protocol MUST be specified if the flags field states that
-        the NAPTR is terminal.
 
-    @type regexp: L{Charstr}
-    @ivar regexp: A STRING containing a substitution expression that is applied
-        to the original string held by the client in order to construct the
-        next domain name to lookup.
+    def encode(self, strio, compDict=None):
+        for d in self.data:
+            strio.write(struct.pack('!B', len(d)) + d)
 
-    @type replacement: L{Name}
-    @ivar replacement: The next NAME to query for NAPTR, SRV, or address
-        records depending on the value of the flags field.  This MUST be a
-        fully qualified domain-name.
+
+    def decode(self, strio, length=None):
+        soFar = 0
+        self.data = []
+        while soFar < length:
+            L = struct.unpack('!B', readPrecisely(strio, 1))[0]
+            self.data.append(readPrecisely(strio, L))
+            soFar += L + 1
+        if soFar != length:
+            log.msg(
+                "Decoded %d bytes in %s record, but rdlength is %d" % (
+                    soFar, self.fancybasename, length
+                )
+            )
+
+
+    def __hash__(self):
+        return hash(tuple(self.data))
+
+
+
+@implementer(IEncodable, IRecord)
+class Record_RP(tputil.FancyEqMixin, tputil.FancyStrMixin):
+    """
+    The responsible person for a domain.
+
+    @type mbox: L{Name}
+    @ivar mbox: A domain name that specifies the mailbox for the responsible
+        person.
+
+    @type txt: L{Name}
+    @ivar txt: A domain name for which TXT RR's exist (indirection through
+        which allows information sharing about the contents of this RP record).
 
     @type ttl: C{int}
     @ivar ttl: The maximum number of seconds which this record should be
         cached.
 
-    @see: U{http://www.faqs.org/rfcs/rfc2915.html}
+    @see: U{http://www.faqs.org/rfcs/rfc1183.html}
     """
-    TYPE = NAPTR
-
-    compareAttributes = ('order', 'preference', 'flags', 'service', 'regexp',
-                         'replacement')
-    fancybasename = 'NAPTR'
+    TYPE = RP
 
-    showAttributes = ('order', 'preference', ('flags', 'flags', '%s'),
-                      ('service', 'service', '%s'), ('regexp', 'regexp', '%s'),
-                      ('replacement', 'replacement', '%s'), 'ttl')
+    fancybasename = 'RP'
+    compareAttributes = ('mbox', 'txt', 'ttl')
+    showAttributes = (('mbox', 'mbox', '%s'), ('txt', 'txt', '%s'), 'ttl')
 
-    def __init__(self, order=0, preference=0, flags=b'', service=b'', regexp=b'',
-                 replacement=b'', ttl=None):
-        self.order = int(order)
-        self.preference = int(preference)
-        self.flags = Charstr(flags)
-        self.service = Charstr(service)
-        self.regexp = Charstr(regexp)
-        self.replacement = Name(replacement)
+    def __init__(self, mbox=b'', txt=b'', ttl=None):
+        self.mbox = Name(mbox)
+        self.txt = Name(txt)
         self.ttl = str2time(ttl)
 
 
-    def encode(self, strio, compDict=None):
-        strio.write(struct.pack('!HH', self.order, self.preference))
-        # This can't be compressed
-        self.flags.encode(strio, None)
-        self.service.encode(strio, None)
-        self.regexp.encode(strio, None)
-        self.replacement.encode(strio, None)
+    def encode(self, strio, compDict = None):
+        self.mbox.encode(strio, compDict)
+        self.txt.encode(strio, compDict)
 
 
-    def decode(self, strio, length=None):
-        r = struct.unpack('!HH', readPrecisely(strio, struct.calcsize('!HH')))
-        self.order, self.preference = r
-        self.flags = Charstr()
-        self.service = Charstr()
-        self.regexp = Charstr()
-        self.replacement = Name()
-        self.flags.decode(strio)
-        self.service.decode(strio)
-        self.regexp.decode(strio)
-        self.replacement.decode(strio)
+    def decode(self, strio, length = None):
+        self.mbox = Name()
+        self.txt = Name()
+        self.mbox.decode(strio)
+        self.txt.decode(strio)
 
 
     def __hash__(self):
-        return hash((
-            self.order, self.preference, self.flags,
-            self.service, self.regexp, self.replacement))
+        return hash((self.mbox, self.txt))
 
 
 
@@ -1606,246 +1574,298 @@ class Record_AFSDB(tputil.FancyStrMixin, tputil.FancyEqMixin):
 
 
 
-@implementer(IEncodable, IRecord)
-class Record_RP(tputil.FancyEqMixin, tputil.FancyStrMixin):
+class Record_AAAA(AddressRecord):
     """
-    The responsible person for a domain.
-
-    @type mbox: L{Name}
-    @ivar mbox: A domain name that specifies the mailbox for the responsible
-        person.
-
-    @type txt: L{Name}
-    @ivar txt: A domain name for which TXT RR's exist (indirection through
-        which allows information sharing about the contents of this RP record).
-
-    @type ttl: C{int}
-    @ivar ttl: The maximum number of seconds which this record should be
-        cached.
-
-    @see: U{http://www.faqs.org/rfcs/rfc1183.html}
+    An IPv6 host address.
     """
-    TYPE = RP
-
-    fancybasename = 'RP'
-    compareAttributes = ('mbox', 'txt', 'ttl')
-    showAttributes = (('mbox', 'mbox', '%s'), ('txt', 'txt', '%s'), 'ttl')
-
-    def __init__(self, mbox=b'', txt=b'', ttl=None):
-        self.mbox = Name(mbox)
-        self.txt = Name(txt)
-        self.ttl = str2time(ttl)
+    TYPE = AAAA
+    LEN = 16
 
+    fancybasename = 'AAAA'
 
-    def encode(self, strio, compDict = None):
-        self.mbox.encode(strio, compDict)
-        self.txt.encode(strio, compDict)
+    _address = property(lambda self: socket.inet_ntop(AF_INET6, self.address))
 
+    def __init__(self, address='::', ttl=None):
+        self.address = socket.inet_pton(AF_INET6, address)
+        self.ttl = str2time(ttl)
 
-    def decode(self, strio, length = None):
-        self.mbox = Name()
-        self.txt = Name()
-        self.mbox.decode(strio)
-        self.txt.decode(strio)
 
 
-    def __hash__(self):
-        return hash((self.mbox, self.txt))
+@implementer(IEncodable, IRecord)
+class Record_SRV(tputil.FancyEqMixin, tputil.FancyStrMixin):
+    """
+    The location of the server(s) for a specific protocol and domain.
 
+    This is an experimental record type.
 
+    @type priority: C{int}
+    @ivar priority: The priority of this target host.  A client MUST attempt to
+        contact the target host with the lowest-numbered priority it can reach;
+        target hosts with the same priority SHOULD be tried in an order defined
+        by the weight field.
 
-@implementer(IEncodable, IRecord)
-class Record_HINFO(tputil.FancyStrMixin, tputil.FancyEqMixin):
-    """
-    Host information.
+    @type weight: C{int}
+    @ivar weight: Specifies a relative weight for entries with the same
+        priority. Larger weights SHOULD be given a proportionately higher
+        probability of being selected.
 
-    @type cpu: C{str}
-    @ivar cpu: Specifies the CPU type.
+    @type port: C{int}
+    @ivar port: The port on this target host of this service.
 
-    @type os: C{str}
-    @ivar os: Specifies the OS.
+    @type target: L{Name}
+    @ivar target: The domain name of the target host.  There MUST be one or
+        more address records for this name, the name MUST NOT be an alias (in
+        the sense of RFC 1034 or RFC 2181).  Implementors are urged, but not
+        required, to return the address record(s) in the Additional Data
+        section.  Unless and until permitted by future standards action, name
+        compression is not to be used for this field.
 
     @type ttl: C{int}
     @ivar ttl: The maximum number of seconds which this record should be
         cached.
+
+    @see: U{http://www.faqs.org/rfcs/rfc2782.html}
     """
-    TYPE = HINFO
+    TYPE = SRV
 
-    fancybasename = 'HINFO'
-    showAttributes = (('cpu', _nicebytes), ('os', _nicebytes), 'ttl')
-    compareAttributes = ('cpu', 'os', 'ttl')
+    fancybasename = 'SRV'
+    compareAttributes = ('priority', 'weight', 'target', 'port', 'ttl')
+    showAttributes = ('priority', 'weight', ('target', 'target', '%s'), 'port', 'ttl')
 
-    def __init__(self, cpu='', os='', ttl=None):
-        self.cpu, self.os = cpu, os
+    def __init__(self, priority=0, weight=0, port=0, target=b'', ttl=None):
+        self.priority = int(priority)
+        self.weight = int(weight)
+        self.port = int(port)
+        self.target = Name(target)
         self.ttl = str2time(ttl)
 
 
     def encode(self, strio, compDict = None):
-        strio.write(struct.pack('!B', len(self.cpu)) + self.cpu)
-        strio.write(struct.pack('!B', len(self.os)) + self.os)
+        strio.write(struct.pack('!HHH', self.priority, self.weight, self.port))
+        # This can't be compressed
+        self.target.encode(strio, None)
 
 
     def decode(self, strio, length = None):
-        cpu = struct.unpack('!B', readPrecisely(strio, 1))[0]
-        self.cpu = readPrecisely(strio, cpu)
-        os = struct.unpack('!B', readPrecisely(strio, 1))[0]
-        self.os = readPrecisely(strio, os)
-
-
-    def __eq__(self, other):
-        if isinstance(other, Record_HINFO):
-            return (self.os.lower() == other.os.lower() and
-                    self.cpu.lower() == other.cpu.lower() and
-                    self.ttl == other.ttl)
-        return NotImplemented
+        r = struct.unpack('!HHH', readPrecisely(strio, struct.calcsize('!HHH')))
+        self.priority, self.weight, self.port = r
+        self.target = Name()
+        self.target.decode(strio)
 
 
     def __hash__(self):
-        return hash((self.os.lower(), self.cpu.lower()))
+        return hash((self.priority, self.weight, self.port, self.target))
 
 
 
 @implementer(IEncodable, IRecord)
-class Record_MINFO(tputil.FancyEqMixin, tputil.FancyStrMixin):
+class Record_A6(tputil.FancyStrMixin, tputil.FancyEqMixin):
     """
-    Mailbox or mail list information.
+    An IPv6 address.
 
     This is an experimental record type.
 
-    @type rmailbx: L{Name}
-    @ivar rmailbx: A domain-name which specifies a mailbox which is responsible
-        for the mailing list or mailbox.  If this domain name names the root,
-        the owner of the MINFO RR is responsible for itself.
+    @type prefixLen: C{int}
+    @ivar prefixLen: The length of the suffix.
 
-    @type emailbx: L{Name}
-    @ivar emailbx: A domain-name which specifies a mailbox which is to receive
-        error messages related to the mailing list or mailbox specified by the
-        owner of the MINFO record.  If this domain name names the root, errors
-        should be returned to the sender of the message.
+    @type suffix: C{str}
+    @ivar suffix: An IPv6 address suffix in network order.
+
+    @type prefix: L{Name}
+    @ivar prefix: If specified, a name which will be used as a prefix for other
+        A6 records.
+
+    @type bytes: C{int}
+    @ivar bytes: The length of the prefix.
 
     @type ttl: C{int}
     @ivar ttl: The maximum number of seconds which this record should be
         cached.
+
+    @see: U{http://www.faqs.org/rfcs/rfc2874.html}
+    @see: U{http://www.faqs.org/rfcs/rfc3363.html}
+    @see: U{http://www.faqs.org/rfcs/rfc3364.html}
     """
-    TYPE = MINFO
+    TYPE = A6
 
-    rmailbx = None
-    emailbx = None
+    fancybasename = 'A6'
+    showAttributes = (('_suffix', 'suffix', '%s'), ('prefix', 'prefix', '%s'), 'ttl')
+    compareAttributes = ('prefixLen', 'prefix', 'suffix', 'ttl')
 
-    fancybasename = 'MINFO'
-    compareAttributes = ('rmailbx', 'emailbx', 'ttl')
-    showAttributes = (('rmailbx', 'responsibility', '%s'),
-                      ('emailbx', 'errors', '%s'),
-                      'ttl')
+    _suffix = property(lambda self: socket.inet_ntop(AF_INET6, self.suffix))
 
-    def __init__(self, rmailbx=b'', emailbx=b'', ttl=None):
-        self.rmailbx, self.emailbx = Name(rmailbx), Name(emailbx)
+    def __init__(self, prefixLen=0, suffix='::', prefix=b'', ttl=None):
+        self.prefixLen = prefixLen
+        self.suffix = socket.inet_pton(AF_INET6, suffix)
+        self.prefix = Name(prefix)
+        self.bytes = int((128 - self.prefixLen) / 8.0)
         self.ttl = str2time(ttl)
 
 
     def encode(self, strio, compDict = None):
-        self.rmailbx.encode(strio, compDict)
-        self.emailbx.encode(strio, compDict)
+        strio.write(struct.pack('!B', self.prefixLen))
+        if self.bytes:
+            strio.write(self.suffix[-self.bytes:])
+        if self.prefixLen:
+            # This may not be compressed
+            self.prefix.encode(strio, None)
 
 
     def decode(self, strio, length = None):
-        self.rmailbx, self.emailbx = Name(), Name()
-        self.rmailbx.decode(strio)
-        self.emailbx.decode(strio)
+        self.prefixLen = struct.unpack('!B', readPrecisely(strio, 1))[0]
+        self.bytes = int((128 - self.prefixLen) / 8.0)
+        if self.bytes:
+            self.suffix = b'\x00' * (16 - self.bytes) + readPrecisely(strio, self.bytes)
+        if self.prefixLen:
+            self.prefix.decode(strio)
+
+
+    def __eq__(self, other):
+        if isinstance(other, Record_A6):
+            return (self.prefixLen == other.prefixLen and
+                    self.suffix[-self.bytes:] == other.suffix[-self.bytes:] and
+                    self.prefix == other.prefix and
+                    self.ttl == other.ttl)
+        return NotImplemented
 
 
     def __hash__(self):
-        return hash((self.rmailbx, self.emailbx))
+        return hash((self.prefixLen, self.suffix[-self.bytes:], self.prefix))
 
 
+    def __str__(self):
+        return '<A6 %s %s (%d) ttl=%s>' % (
+            self.prefix,
+            socket.inet_ntop(AF_INET6, self.suffix),
+            self.prefixLen, self.ttl
+        )
 
-@implementer(IEncodable, IRecord)
-class Record_MX(tputil.FancyStrMixin, tputil.FancyEqMixin):
-    """
-    Mail exchange.
 
-    @type preference: C{int}
-    @ivar preference: Specifies the preference given to this RR among others at
-        the same owner.  Lower values are preferred.
 
-    @type name: L{Name}
-    @ivar name: A domain-name which specifies a host willing to act as a mail
-        exchange.
+class Record_DNAME(SimpleRecord):
+    """
+    A non-terminal DNS name redirection.
 
-    @type ttl: C{int}
-    @ivar ttl: The maximum number of seconds which this record should be
-        cached.
+    This record type provides the capability to map an entire subtree of the
+    DNS name space to another domain.  It differs from the CNAME record which
+    maps a single node of the name space.
+
+    @see: U{http://www.faqs.org/rfcs/rfc2672.html}
+    @see: U{http://www.faqs.org/rfcs/rfc3363.html}
     """
-    TYPE = MX
+    TYPE = DNAME
+    fancybasename = 'DNAME'
 
-    fancybasename = 'MX'
-    compareAttributes = ('preference', 'name', 'ttl')
-    showAttributes = ('preference', ('name', 'name', '%s'), 'ttl')
 
-    def __init__(self, preference=0, name=b'', ttl=None, **kwargs):
-        self.preference, self.name = int(preference), Name(kwargs.get('exchange', name))
-        self.ttl = str2time(ttl)
 
-    def encode(self, strio, compDict = None):
-        strio.write(struct.pack('!H', self.preference))
-        self.name.encode(strio, compDict)
+@implementer(IEncodable, IRecord)
+class Record_NAPTR(tputil.FancyEqMixin, tputil.FancyStrMixin):
+    """
+    The location of the server(s) for a specific protocol and domain.
 
+    @type order: C{int}
+    @ivar order: An integer specifying the order in which the NAPTR records
+        MUST be processed to ensure the correct ordering of rules.  Low numbers
+        are processed before high numbers.
 
-    def decode(self, strio, length = None):
-        self.preference = struct.unpack('!H', readPrecisely(strio, 2))[0]
-        self.name = Name()
-        self.name.decode(strio)
+    @type preference: C{int}
+    @ivar preference: An integer that specifies the order in which NAPTR
+        records with equal "order" values SHOULD be processed, low numbers
+        being processed before high numbers.
 
-    def __hash__(self):
-        return hash((self.preference, self.name))
+    @type flag: L{Charstr}
+    @ivar flag: A <character-string> containing flags to control aspects of the
+        rewriting and interpretation of the fields in the record.  Flags
+        are single characters from the set [A-Z0-9].  The case of the alphabetic
+        characters is not significant.
 
+        At this time only four flags, "S", "A", "U", and "P", are defined.
 
+    @type service: L{Charstr}
+    @ivar service: Specifies the service(s) available down this rewrite path.
+        It may also specify the particular protocol that is used to talk with a
+        service.  A protocol MUST be specified if the flags field states that
+        the NAPTR is terminal.
 
-@implementer(IEncodable, IRecord)
-class Record_TXT(tputil.FancyEqMixin, tputil.FancyStrMixin):
-    """
-    Freeform text.
+    @type regexp: L{Charstr}
+    @ivar regexp: A STRING containing a substitution expression that is applied
+        to the original string held by the client in order to construct the
+        next domain name to lookup.
 
-    @type data: C{list} of C{bytes}
-    @ivar data: Freeform text which makes up this record.
+    @type replacement: L{Name}
+    @ivar replacement: The next NAME to query for NAPTR, SRV, or address
+        records depending on the value of the flags field.  This MUST be a
+        fully qualified domain-name.
 
     @type ttl: C{int}
-    @ivar ttl: The maximum number of seconds which this record should be cached.
+    @ivar ttl: The maximum number of seconds which this record should be
+        cached.
+
+    @see: U{http://www.faqs.org/rfcs/rfc2915.html}
     """
-    TYPE = TXT
+    TYPE = NAPTR
 
-    fancybasename = 'TXT'
-    showAttributes = (('data', _nicebyteslist), 'ttl')
-    compareAttributes = ('data', 'ttl')
+    compareAttributes = ('order', 'preference', 'flags', 'service', 'regexp',
+                         'replacement')
+    fancybasename = 'NAPTR'
 
-    def __init__(self, *data, **kw):
-        self.data = list(data)
-        # arg man python sucks so bad
-        self.ttl = str2time(kw.get('ttl', None))
+    showAttributes = ('order', 'preference', ('flags', 'flags', '%s'),
+                      ('service', 'service', '%s'), ('regexp', 'regexp', '%s'),
+                      ('replacement', 'replacement', '%s'), 'ttl')
+
+    def __init__(self, order=0, preference=0, flags=b'', service=b'', regexp=b'',
+                 replacement=b'', ttl=None):
+        self.order = int(order)
+        self.preference = int(preference)
+        self.flags = Charstr(flags)
+        self.service = Charstr(service)
+        self.regexp = Charstr(regexp)
+        self.replacement = Name(replacement)
+        self.ttl = str2time(ttl)
 
 
     def encode(self, strio, compDict=None):
-        for d in self.data:
-            strio.write(struct.pack('!B', len(d)) + d)
+        strio.write(struct.pack('!HH', self.order, self.preference))
+        # This can't be compressed
+        self.flags.encode(strio, None)
+        self.service.encode(strio, None)
+        self.regexp.encode(strio, None)
+        self.replacement.encode(strio, None)
 
 
     def decode(self, strio, length=None):
-        soFar = 0
-        self.data = []
-        while soFar < length:
-            L = struct.unpack('!B', readPrecisely(strio, 1))[0]
-            self.data.append(readPrecisely(strio, L))
-            soFar += L + 1
-        if soFar != length:
-            log.msg(
-                "Decoded %d bytes in %s record, but rdlength is %d" % (
-                    soFar, self.fancybasename, length
-                )
-            )
+        r = struct.unpack('!HH', readPrecisely(strio, struct.calcsize('!HH')))
+        self.order, self.preference = r
+        self.flags = Charstr()
+        self.service = Charstr()
+        self.regexp = Charstr()
+        self.replacement = Name()
+        self.flags.decode(strio)
+        self.service.decode(strio)
+        self.regexp.decode(strio)
+        self.replacement.decode(strio)
 
 
     def __hash__(self):
-        return hash(tuple(self.data))
+        return hash((
+            self.order, self.preference, self.flags,
+            self.service, self.regexp, self.replacement))
+
+
+
+class Record_SPF(Record_TXT):
+    """
+    Structurally, freeform text. Semantically, a policy definition, formatted
+    as defined in U{rfc 4408<http://www.faqs.org/rfcs/rfc4408.html>}.
+
+    @type data: C{list} of C{str}
+    @ivar data: Freeform text which makes up this record.
+
+    @type ttl: C{int}
+    @ivar ttl: The maximum number of seconds which this record should be cached.
+    """
+    TYPE = SPF
+    fancybasename = 'SPF'
 
 
 
@@ -1895,22 +1915,6 @@ class UnknownRecord(tputil.FancyEqMixin, tputil.FancyStrMixin, object):
 
 
 
-class Record_SPF(Record_TXT):
-    """
-    Structurally, freeform text. Semantically, a policy definition, formatted
-    as defined in U{rfc 4408<http://www.faqs.org/rfcs/rfc4408.html>}.
-
-    @type data: C{list} of C{str}
-    @ivar data: Freeform text which makes up this record.
-
-    @type ttl: C{int}
-    @ivar ttl: The maximum number of seconds which this record should be cached.
-    """
-    TYPE = SPF
-    fancybasename = 'SPF'
-
-
-
 def _responseFromMessage(responseConstructor, message, **kwargs):
     """
     Generate a L{Message} like instance suitable for use as the response to
