Index: twisted/web2/dav/test/test_options.py
===================================================================
--- twisted/web2/dav/test/test_options.py	(revision 22823)
+++ twisted/web2/dav/test/test_options.py	(working copy)
@@ -1,58 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-from twisted.web2.iweb import IResponse
-
-import twisted.web2.dav.test.util
-from twisted.web2.test.test_server import SimpleRequest
-
-class OPTIONS(twisted.web2.dav.test.util.TestCase):
-    """
-    OPTIONS request
-    """
-    def test_DAV1(self):
-        """
-        DAV level 1
-        """
-        return self._test_level("1")
-
-    def test_DAV2(self):
-        """
-        DAV level 2
-        """
-        return self._test_level("2")
-
-    test_DAV2.todo = "DAV level 2 unimplemented"
-
-    def _test_level(self, level):
-        def doTest(response):
-            response = IResponse(response)
-
-            dav = response.headers.getHeader("dav")
-            if not dav: self.fail("no DAV header: %s" % (response.headers,))
-            self.assertIn(level, dav, "no DAV level %s header" % (level,))
-
-            return response
-
-        return self.send(SimpleRequest(self.site, "OPTIONS", "/"), doTest)
Index: twisted/web2/dav/test/TODO.txt
===================================================================
--- twisted/web2/dav/test/TODO.txt	(revision 22823)
+++ twisted/web2/dav/test/TODO.txt	(working copy)
@@ -1,18 +0,0 @@
-More tests:
-
-Headers:
- - Etag
- - Content Length
- - Last Modified
- - Content Type
- - Creation Date
- - Display Name
-
-Conditions:
- - If-Match
- - If-None-Match
- - If-Modified-Since
- - If-Unmodified-Since
-
-Misc:
- - unquote in locateChild() issue?
Index: twisted/web2/dav/test/__init__.py
===================================================================
--- twisted/web2/dav/test/__init__.py	(revision 22823)
+++ twisted/web2/dav/test/__init__.py	(working copy)
@@ -1,27 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-Tests for twisted.web2.dav.
-"""
Index: twisted/web2/dav/test/test_delete.py
===================================================================
--- twisted/web2/dav/test/test_delete.py	(revision 22823)
+++ twisted/web2/dav/test/test_delete.py	(working copy)
@@ -1,74 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import os
-import urllib
-import random
-
-from twisted.web2 import responsecode
-from twisted.web2.iweb import IResponse
-from twisted.web2.test.test_server import SimpleRequest
-from twisted.web2.dav.test.util import serialize
-import twisted.web2.dav.test.util
-
-class DELETE(twisted.web2.dav.test.util.TestCase):
-    """
-    DELETE request
-    """
-    # FIXME:
-    # Try setting unwriteable perms on file, then delete
-    # Try check response XML for error in some but not all files
-
-    def test_DELETE(self):
-        """
-        DELETE request
-        """
-        def check_result(response, path):
-            response = IResponse(response)
-
-            if response.code != responsecode.NO_CONTENT:
-                self.fail("DELETE response %s != %s" % (response.code, responsecode.NO_CONTENT))
-
-            if os.path.exists(path):
-                self.fail("DELETE did not remove path %s" % (path,))
-
-        def work():
-            for filename in os.listdir(self.docroot):
-                path = os.path.join(self.docroot, filename)
-                uri = urllib.quote("/" + filename)
-
-                if os.path.isdir(path): uri = uri + "/"
-
-                def do_test(response, path=path):
-                    return check_result(response, path)
-
-                request = SimpleRequest(self.site, "DELETE", uri)
-
-                depth = random.choice(("infinity", None))
-                if depth is not None:
-                    request.headers.setHeader("depth", depth)
-
-                yield (request, do_test)
-
-        return serialize(self.send, work())
Index: twisted/web2/dav/test/test_mkcol.py
===================================================================
--- twisted/web2/dav/test/test_mkcol.py	(revision 22823)
+++ twisted/web2/dav/test/test_mkcol.py	(working copy)
@@ -1,85 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import os
-
-from twisted.web2 import responsecode
-from twisted.web2.iweb import IResponse
-from twisted.web2.stream import MemoryStream
-from twisted.web2.dav.fileop import rmdir
-from twisted.web2.test.test_server import SimpleRequest
-import twisted.web2.dav.test.util
-
-class MKCOL(twisted.web2.dav.test.util.TestCase):
-    """
-    MKCOL request
-    """
-    # FIXME:
-    # Try in nonexistant parent collection.
-    # Try on existing resource.
-    # Try with request body?
-    def test_MKCOL(self):
-        """
-        MKCOL request
-        """
-        path, uri = self.mkdtemp("collection")
-
-        rmdir(path)
-
-        def check_result(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.CREATED:
-                self.fail("MKCOL response %s != %s" % (response.code, responsecode.CREATED))
-
-            if not os.path.isdir(path):
-                self.fail("MKCOL did not create directory %s" % (path,))
-
-        request = SimpleRequest(self.site, "MKCOL", uri)
-
-        return self.send(request, check_result)
-
-    def test_MKCOL_invalid_body(self):
-        """
-        MKCOL request with invalid request body
-        (Any body at all is invalid in our implementation; there is no
-        such thing as a valid body.)
-        """
-        path, uri = self.mkdtemp("collection")
-
-        rmdir(path)
-
-        def check_result(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.UNSUPPORTED_MEDIA_TYPE:
-                self.fail("MKCOL response %s != %s" % (response.code, responsecode.UNSUPPORTED_MEDIA_TYPE))
-
-            if os.path.isdir(path):
-                self.fail("MKCOL incorrectly created directory %s" % (path,))
-
-        request = SimpleRequest(self.site, "MKCOL", uri)
-        request.stream = MemoryStream("This is not a valid MKCOL request body.")
-
-        return self.send(request, check_result)
Index: twisted/web2/dav/test/test_move.py
===================================================================
--- twisted/web2/dav/test/test_move.py	(revision 22823)
+++ twisted/web2/dav/test/test_move.py	(working copy)
@@ -1,109 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import os
-
-from twisted.web2 import responsecode
-
-import twisted.web2.dav.test.util
-import twisted.web2.dav.test.test_copy
-from twisted.web2.dav.test.util import serialize
-from twisted.web2.dav.test.test_copy import sumFile
-
-class MOVE(twisted.web2.dav.test.util.TestCase):
-    """
-    MOVE request
-    """
-    # FIXME:
-    # Check that properties are being moved
-    def test_MOVE_create(self):
-        """
-        MOVE to new resource.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.CREATED:
-                self.fail("Incorrect response code for MOVE %s: %s != %s"
-                          % (uri, response.code, responsecode.CREATED))
-
-            if response.headers.getHeader("location") is None:
-                self.fail("Reponse to MOVE %s with CREATE status is missing location: header."
-                          % (uri,))
-
-            if isfile:
-                if not os.path.isfile(dst_path):
-                    self.fail("MOVE %s produced no output file" % (uri,))
-                if sum != sumFile(dst_path):
-                    self.fail("MOVE %s produced different file" % (uri,))
-            else:
-                if not os.path.isdir(dst_path):
-                    self.fail("MOVE %s produced no output directory" % (uri,))
-                if sum != sumFile(dst_path):
-                    self.fail("isdir %s produced different directory" % (uri,))
-
-        return serialize(self.send, work(self, test))
-
-    def test_MOVE_exists(self):
-        """
-        MOVE to existing resource.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.PRECONDITION_FAILED:
-                self.fail("Incorrect response code for MOVE without overwrite %s: %s != %s"
-                          % (uri, response.code, responsecode.PRECONDITION_FAILED))
-            else:
-                # FIXME: Check XML error code (2518bis)
-                pass
-
-        return serialize(self.send, work(self, test, overwrite=False))
-
-    def test_MOVE_overwrite(self):
-        """
-        MOVE to existing resource with overwrite header.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.NO_CONTENT:
-                self.fail("Incorrect response code for MOVE with overwrite %s: %s != %s"
-                          % (uri, response.code, responsecode.NO_CONTENT))
-            else:
-                # FIXME: Check XML error code (2518bis)
-                pass
-
-        return serialize(self.send, work(self, test, overwrite=True))
-
-    def test_MOVE_no_parent(self):
-        """
-        MOVE to resource with no parent.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.CONFLICT:
-                self.fail("Incorrect response code for MOVE with no parent %s: %s != %s"
-                          % (uri, response.code, responsecode.CONFLICT))
-            else:
-                # FIXME: Check XML error code (2518bis)
-                pass
-
-        return serialize(self.send, work(self, test, dst=os.path.join(self.docroot, "elvislives!")))
-
-def work(self, test, overwrite=None, dst=None):
-    return twisted.web2.dav.test.test_copy.work(self, test, overwrite, dst, depths=(None,))
Index: twisted/web2/dav/test/test_put.py
===================================================================
--- twisted/web2/dav/test/test_put.py	(revision 22823)
+++ twisted/web2/dav/test/test_put.py	(working copy)
@@ -1,148 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import os
-import filecmp
-
-from twisted.web2 import responsecode
-from twisted.web2.iweb import IResponse
-from twisted.web2.stream import FileStream
-from twisted.web2.http import HTTPError
-
-import twisted.web2.dav.test.util
-from twisted.web2.test.test_server import SimpleRequest
-from twisted.web2.dav.test.util import serialize
-
-class PUT(twisted.web2.dav.test.util.TestCase):
-    """
-    PUT request
-    """
-    def test_PUT_simple(self):
-        """
-        PUT request
-        """
-        dst_path = os.path.join(self.docroot, "dst")
-
-        def checkResult(response, path):
-            response = IResponse(response)
-
-            if response.code not in (
-                responsecode.CREATED,
-                responsecode.NO_CONTENT
-            ):
-                self.fail("PUT failed: %s" % (response.code,))
-
-            if not os.path.isfile(dst_path):
-                self.fail("PUT failed to create file %s." % (dst_path,))
-
-            if not filecmp.cmp(path, dst_path):
-                self.fail("PUT failed to preserve data for file %s in file %s." % (path, dst_path))
-
-            etag = response.headers.getHeader("etag")
-            if not etag:
-                self.fail("No etag header in PUT response %r." % (response,))
-
-        #
-        # We need to serialize these request & test iterations because they can
-        # interfere with each other.
-        #
-        def work():
-            dst_uri = "/dst"
-
-            for name in os.listdir(self.docroot):
-                if name == "dst":
-                    continue
-
-                path = os.path.join(self.docroot, name)
-
-                # Can't really PUT something you can't read
-                if not os.path.isfile(path): continue
-    
-                def do_test(response): checkResult(response, path)
-    
-                request = SimpleRequest(self.site, "PUT", dst_uri)
-                request.stream = FileStream(file(path, "rb"))
-    
-                yield (request, do_test)
-
-        return serialize(self.send, work())
-
-    def test_PUT_again(self):
-        """
-        PUT on existing resource with If-None-Match header
-        """
-        dst_path = os.path.join(self.docroot, "dst")
-        dst_uri = "/dst"
-
-        def work():
-            for code in (
-                responsecode.CREATED,
-                responsecode.PRECONDITION_FAILED,
-                responsecode.NO_CONTENT,
-                responsecode.PRECONDITION_FAILED,
-                responsecode.NO_CONTENT,
-                responsecode.CREATED,
-            ):
-                def checkResult(response, code=code):
-                    response = IResponse(response)
-
-                    if response.code != code:
-                        self.fail("Incorrect response code for PUT (%s != %s)"
-                                  % (response.code, code))
-
-                def onError(f):
-                    f.trap(HTTPError)
-                    return checkResult(f.value.response)
-
-                request = SimpleRequest(self.site, "PUT", dst_uri)
-                request.stream = FileStream(file(__file__, "rb"))
-    
-                if code == responsecode.CREATED:
-                    if os.path.isfile(dst_path):
-                        os.remove(dst_path)
-                    request.headers.setHeader("if-none-match", ("*",))
-                elif code == responsecode.PRECONDITION_FAILED:
-                    request.headers.setHeader("if-none-match", ("*",))
-    
-                yield (request, (checkResult, onError))
-
-        return serialize(self.send, work())
-
-    def test_PUT_no_parent(self):
-        """
-        PUT with no parent
-        """
-        dst_uri = "/put/no/parent"
-
-        def checkResult(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.CONFLICT:
-                self.fail("Incorrect response code for PUT with no parent (%s != %s)"
-                          % (response.code, responsecode.CONFLICT))
-
-        request = SimpleRequest(self.site, "PUT", dst_uri)
-        request.stream = FileStream(file(__file__, "rb"))
-
-        return self.send(request, checkResult)
Index: twisted/web2/dav/test/test_copy.py
===================================================================
--- twisted/web2/dav/test/test_copy.py	(revision 22823)
+++ twisted/web2/dav/test/test_copy.py	(working copy)
@@ -1,189 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import os
-import urllib
-import md5
-
-import twisted.web2.dav.test.util
-from twisted.web2 import responsecode
-from twisted.web2.test.test_server import SimpleRequest
-from twisted.web2.dav.test.util import dircmp, serialize
-from twisted.web2.dav.fileop import rmdir
-
-class COPY(twisted.web2.dav.test.util.TestCase):
-    """
-    COPY request
-    """
-    # FIXME:
-    # Check that properties are being copied
-    def test_COPY_create(self):
-        """
-        COPY to new resource.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.CREATED:
-                self.fail("Incorrect response code for COPY %s (depth=%r): %s != %s"
-                          % (uri, depth, response.code, responsecode.CREATED))
-
-            if response.headers.getHeader("location") is None:
-                self.fail("Reponse to COPY %s (depth=%r) with CREATE status is missing location: header."
-                          % (uri, depth))
-
-            if os.path.isfile(path):
-                if not os.path.isfile(dst_path):
-                    self.fail("COPY %s (depth=%r) produced no output file" % (uri, depth))
-                if not cmp(path, dst_path):
-                    self.fail("COPY %s (depth=%r) produced different file" % (uri, depth))
-                os.remove(dst_path)
-
-            elif os.path.isdir(path):
-                if not os.path.isdir(dst_path):
-                    self.fail("COPY %s (depth=%r) produced no output directory" % (uri, depth))
-
-                if depth in ("infinity", None):
-                    if dircmp(path, dst_path):
-                        self.fail("COPY %s (depth=%r) produced different directory" % (uri, depth))
-
-                elif depth == "0":
-                    for filename in os.listdir(dst_path):
-                        self.fail("COPY %s (depth=%r) shouldn't copy directory contents (eg. %s)" % (uri, depth, filename))
-
-                else: raise AssertionError("Unknown depth: %r" % (depth,))
-
-                rmdir(dst_path)
-
-            else:
-                self.fail("Source %s is neither a file nor a directory"
-                          % (path,))
-
-        return serialize(self.send, work(self, test))
-
-    def test_COPY_exists(self):
-        """
-        COPY to existing resource.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.PRECONDITION_FAILED:
-                self.fail("Incorrect response code for COPY without overwrite %s: %s != %s"
-                          % (uri, response.code, responsecode.PRECONDITION_FAILED))
-            else:
-                # FIXME: Check XML error code (2518bis)
-                pass
-
-        return serialize(self.send, work(self, test, overwrite=False))
-
-    def test_COPY_overwrite(self):
-        """
-        COPY to existing resource with overwrite header.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.NO_CONTENT:
-                self.fail("Incorrect response code for COPY with overwrite %s: %s != %s"
-                          % (uri, response.code, responsecode.NO_CONTENT))
-            else:
-                # FIXME: Check XML error code (2518bis)
-                pass
-
-            self.failUnless(os.path.exists(dst_path), "COPY didn't produce file: %s" % (dst_path,))
-
-        return serialize(self.send, work(self, test, overwrite=True))
-
-    def test_COPY_no_parent(self):
-        """
-        COPY to resource with no parent.
-        """
-        def test(response, path, isfile, sum, uri, depth, dst_path):
-            if response.code != responsecode.CONFLICT:
-                self.fail("Incorrect response code for COPY with no parent %s: %s != %s"
-                          % (uri, response.code, responsecode.CONFLICT))
-            else:
-                # FIXME: Check XML error code (2518bis)
-                pass
-
-        return serialize(self.send, work(self, test, dst=os.path.join(self.docroot, "elvislives!")))
-
-def work(self, test, overwrite=None, dst=None, depths=("0", "infinity", None)):
-    if dst is None:
-        dst = os.path.join(self.docroot, "dst")
-        os.mkdir(dst)
-
-    for basename in os.listdir(self.docroot):
-        if basename == "dst": continue
-
-        path = os.path.join(self.docroot, basename)
-        uri = "/" + basename
-        isfile = os.path.isfile(path)
-        sum = sumFile(path)
-        basename = os.path.basename(path)
-        dst_path = os.path.join(dst, basename)
-        dst_uri = urllib.quote("/dst/" + basename)
-
-        if not isfile:
-            uri     += "/"
-            dst_uri += "/"
-
-        if overwrite is not None:
-            # Create a file at dst_path to create a conflict
-            file(dst_path, "w").close()
-
-        for depth in depths:
-            def do_test(response, path=path, isfile=isfile, sum=sum, uri=uri, depth=depth, dst_path=dst_path):
-                test(response, path, isfile, sum, uri, depth, dst_path)
-
-            request = SimpleRequest(self.site, self.__class__.__name__, uri)
-            request.headers.setHeader("destination", dst_uri)
-            if depth is not None:
-                request.headers.setHeader("depth", depth)
-            if overwrite is not None:
-                request.headers.setHeader("overwrite", overwrite)
-
-            yield (request, do_test)
-
-def sumFile(path):
-    m = md5.new()
-
-    if os.path.isfile(path):
-        f = file(path)
-        try:
-            m.update(f.read())
-        finally:
-            f.close()
-
-    elif os.path.isdir(path):
-        for dir, subdirs, files in os.walk(path):
-            for filename in files:
-                m.update(filename)
-                f = file(os.path.join(dir, filename))
-                try:
-                    m.update(f.read())
-                finally:
-                    f.close()
-            for dirname in subdirs:
-                m.update(dirname + "/")
-
-    else:
-        raise AssertionError()
-
-    return m.digest()
Index: twisted/web2/dav/test/test_report_expand.py
===================================================================
--- twisted/web2/dav/test/test_report_expand.py	(revision 22823)
+++ twisted/web2/dav/test/test_report_expand.py	(working copy)
@@ -1,37 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-from twisted.trial.unittest import SkipTest
-
-import twisted.web2.dav.test.util
-
-class REPORT_expand(twisted.web2.dav.test.util.TestCase):
-    """
-    DAV:expand-property REPORT request
-    """
-    def test_REPORT_expand_property(self):
-        """
-        DAV:expand-property REPORT request.
-        """
-        raise SkipTest("test unimplemeted")
Index: twisted/web2/dav/test/test_report.py
===================================================================
--- twisted/web2/dav/test/test_report.py	(revision 22823)
+++ twisted/web2/dav/test/test_report.py	(working copy)
@@ -1,71 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-from twisted.web2.iweb import IResponse
-from twisted.web2.stream import MemoryStream
-from twisted.web2 import responsecode
-
-import twisted.web2.dav.test.util
-from twisted.web2.test.test_server import SimpleRequest
-from twisted.web2.dav import davxml
-
-class REPORT(twisted.web2.dav.test.util.TestCase):
-    """
-    REPORT request
-    """
-    def test_REPORT_no_body(self):
-        """
-        REPORT request with no body
-        """
-        def do_test(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.BAD_REQUEST:
-                self.fail("Unexpected response code for REPORT with no body: %s"
-                          % (response.code,))
-
-        request = SimpleRequest(self.site, "REPORT", "/")
-        request.stream = MemoryStream("")
-
-        return self.send(request, do_test)
-
-    def test_REPORT_unknown(self):
-        """
-        Unknown/bogus report type
-        """
-        def do_test(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.FORBIDDEN:
-                self.fail("Unexpected response code for unknown REPORT: %s"
-                          % (response.code,))
-        class GoofyReport (davxml.WebDAVUnknownElement):
-            namespace = "GOOFY:"
-            name      = "goofy-report"
-            def __init__(self): super(GoofyReport, self).__init__()
-
-        request = SimpleRequest(self.site, "REPORT", "/")
-        request.stream = MemoryStream(GoofyReport().toxml())
-
-        return self.send(request, do_test)
Index: twisted/web2/dav/test/test_util.py
===================================================================
--- twisted/web2/dav/test/test_util.py	(revision 22823)
+++ twisted/web2/dav/test/test_util.py	(working copy)
@@ -1,96 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-from twisted.trial import unittest
-from twisted.web2.dav import util
-
-class Utilities(unittest.TestCase):
-    """
-    Utilities.
-    """
-    def test_normalizeURL(self):
-        """
-        normalizeURL()
-        """
-        self.assertEquals(util.normalizeURL("http://server//foo"), "http://server/foo")
-        self.assertEquals(util.normalizeURL("http://server/foo/.."), "http://server/")
-        self.assertEquals(util.normalizeURL("/foo/bar/..//"), "/foo")
-        self.assertEquals(util.normalizeURL("/foo/bar/.//"), "/foo/bar")
-        self.assertEquals(util.normalizeURL("//foo///bar/../baz"), "/foo/baz")
-        self.assertEquals(util.normalizeURL("//foo///bar/./baz"), "/foo/bar/baz")
-        self.assertEquals(util.normalizeURL("///../"), "/")
-        self.assertEquals(util.normalizeURL("/.."), "/")
-
-    def test_joinURL(self):
-        """
-        joinURL()
-        """
-        self.assertEquals(util.joinURL("http://server/foo/"), "http://server/foo/")
-        self.assertEquals(util.joinURL("http://server/foo", "/bar"), "http://server/foo/bar")
-        self.assertEquals(util.joinURL("http://server/foo", "bar"), "http://server/foo/bar")
-        self.assertEquals(util.joinURL("http://server/foo/", "/bar"), "http://server/foo/bar")
-        self.assertEquals(util.joinURL("http://server/foo/", "/bar/.."), "http://server/foo")
-        self.assertEquals(util.joinURL("http://server/foo/", "/bar/."), "http://server/foo/bar")
-        self.assertEquals(util.joinURL("http://server/foo/", "/bar/../"), "http://server/foo/")
-        self.assertEquals(util.joinURL("http://server/foo/", "/bar/./"), "http://server/foo/bar/")
-        self.assertEquals(util.joinURL("http://server/foo/../", "/bar"), "http://server/bar")
-        self.assertEquals(util.joinURL("/foo/"), "/foo/")
-        self.assertEquals(util.joinURL("/foo", "/bar"), "/foo/bar")
-        self.assertEquals(util.joinURL("/foo", "bar"), "/foo/bar")
-        self.assertEquals(util.joinURL("/foo/", "/bar"), "/foo/bar")
-        self.assertEquals(util.joinURL("/foo/", "/bar/.."), "/foo")
-        self.assertEquals(util.joinURL("/foo/", "/bar/."), "/foo/bar")
-        self.assertEquals(util.joinURL("/foo/", "/bar/../"), "/foo/")
-        self.assertEquals(util.joinURL("/foo/", "/bar/./"), "/foo/bar/")
-        self.assertEquals(util.joinURL("/foo/../", "/bar"), "/bar")
-        self.assertEquals(util.joinURL("/foo", "/../"), "/")
-        self.assertEquals(util.joinURL("/foo", "/./"), "/foo/")
-
-    def test_parentForURL(self):
-        """
-        parentForURL()
-        """
-        self.assertEquals(util.parentForURL("http://server/"), None)
-        self.assertEquals(util.parentForURL("http://server//"), None)
-        self.assertEquals(util.parentForURL("http://server/foo/.."), None)
-        self.assertEquals(util.parentForURL("http://server/foo/../"), None)
-        self.assertEquals(util.parentForURL("http://server/foo/."), "http://server/")
-        self.assertEquals(util.parentForURL("http://server/foo/./"), "http://server/")
-        self.assertEquals(util.parentForURL("http://server/foo"), "http://server/")
-        self.assertEquals(util.parentForURL("http://server//foo"), "http://server/")
-        self.assertEquals(util.parentForURL("http://server/foo/bar/.."), "http://server/")
-        self.assertEquals(util.parentForURL("http://server/foo/bar/."), "http://server/foo/")
-        self.assertEquals(util.parentForURL("http://server/foo/bar"), "http://server/foo/")
-        self.assertEquals(util.parentForURL("http://server/foo/bar/"), "http://server/foo/")
-        self.assertEquals(util.parentForURL("/"), None)
-        self.assertEquals(util.parentForURL("/foo/.."), None)
-        self.assertEquals(util.parentForURL("/foo/../"), None)
-        self.assertEquals(util.parentForURL("/foo/."), "/")
-        self.assertEquals(util.parentForURL("/foo/./"), "/")
-        self.assertEquals(util.parentForURL("/foo"), "/")
-        self.assertEquals(util.parentForURL("/foo"), "/")
-        self.assertEquals(util.parentForURL("/foo/bar/.."), "/")
-        self.assertEquals(util.parentForURL("/foo/bar/."), "/foo/")
-        self.assertEquals(util.parentForURL("/foo/bar"), "/foo/")
-        self.assertEquals(util.parentForURL("/foo/bar/"), "/foo/")
Index: twisted/web2/dav/test/util.py
===================================================================
--- twisted/web2/dav/test/util.py	(revision 22823)
+++ twisted/web2/dav/test/util.py	(working copy)
@@ -1,156 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import os
-from urllib import quote as url_quote
-from filecmp import dircmp as DirCompare
-from tempfile import mkdtemp
-from shutil import copy
-from random import randrange, choice
-
-from twisted.python import log
-from twisted.trial import unittest
-from twisted.internet.defer import Deferred
-from twisted.web2.dav.fileop import rmdir
-from twisted.web2.dav.util import joinURL
-from twisted.web2.dav.static import DAVFile
-
-class TodoTest(Exception):
-    pass
-
-class TestCase(unittest.TestCase):
-    docroot = property(lambda(self): self.site.resource.fp.path)
-
-    resource_class = DAVFile
-
-    def setUp(self):
-        log.msg("Setting up %s" % (self.__class__,))
-
-        docroot = self.mktemp()
-        os.mkdir(docroot)
-
-        dirs = (
-            os.path.join(docroot, "dir1"),
-            os.path.join(docroot, "dir2"),
-            os.path.join(docroot, "dir2", "subdir1"),
-            os.path.join(docroot, "dir3"),
-            os.path.join(docroot, "dir4"),
-            os.path.join(docroot, "dir4", "subdir1"),
-            os.path.join(docroot, "dir4", "subdir1", "subsubdir1"),
-            os.path.join(docroot, "dir4", "subdir2"),
-            os.path.join(docroot, "dir4", "subdir2", "dir1"),
-            os.path.join(docroot, "dir4", "subdir2", "dir2"),
-        )
-    
-        for dir in dirs: os.mkdir(dir)
-
-        src = os.path.dirname(__file__)
-        files = [
-            os.path.join(src, f)
-            for f in os.listdir(src)
-            if os.path.isfile(os.path.join(src, f))
-        ]
-    
-        dc = randrange(len(dirs))
-        while dc:
-            dc -= 1
-            dir = choice(dirs)
-            fc = randrange(len(files))
-            while fc:
-                fc -= 1
-                copy(choice(files), dir)
-
-        for path in files[:8]:
-            copy(path, docroot)
-    
-        self.site = Site(self.resource_class(docroot))
-
-    def tearDown(self):
-        log.msg("Tearing down %s" % (self.__class__,))
-        rmdir(self.docroot)
-
-    def mkdtemp(self, prefix):
-        """
-        Creates a new directory in the document root and returns its path and
-        URI.
-        """
-        path = mkdtemp(prefix=prefix + "_", dir=self.docroot)
-        uri  = joinURL("/", url_quote(os.path.basename(path))) + "/"
-
-        return (path, uri)
-
-    def send(self, request, callback):
-        log.msg("Sending %s request for URI %s" % (request.method, request.uri))
-
-        d = request.locateResource(request.uri)
-        d.addCallback(lambda resource: resource.renderHTTP(request))
-        d.addCallback(request._cbFinishRender)
-
-        if type(callback) is tuple:
-            d.addCallbacks(*callback)
-        else:
-            d.addCallback(callback)
-
-        return d
-
-    def _ebDeferTestMethod(self, f, result):
-        if f.check(TodoTest):
-            result.addExpectedFailure(self, f, unittest.makeTodo(f.getErrorMessage()))
-        else:
-            return unittest.TestCase._ebDeferTestMethod(self, f, result)
-
-class Site:
-    # FIXME: There is no ISite interface; there should be.
-    # implements(ISite)
-
-    def __init__(self, resource):
-        self.resource = resource
-
-def dircmp(dir1, dir2):
-    dc = DirCompare(dir1, dir2)
-    return bool(
-        dc.left_only or dc.right_only or
-        dc.diff_files or
-        dc.common_funny or dc.funny_files
-    )
-
-def serialize(f, work):
-    d = Deferred()
-
-    def oops(error):
-        d.errback(error)
-
-    def do_serialize(_):
-        try:
-            args = work.next()
-        except StopIteration:
-            d.callback(None)
-        else:
-            r = f(*args)
-            r.addCallback(do_serialize)
-            r.addErrback(oops)
-
-    do_serialize(None)
-
-    return d
Index: twisted/web2/dav/test/test_http.py
===================================================================
--- twisted/web2/dav/test/test_http.py	(revision 22823)
+++ twisted/web2/dav/test/test_http.py	(working copy)
@@ -1,89 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import errno
-
-from twisted.python.failure import Failure
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError
-from twisted.web2.dav.http import ErrorResponse, statusForFailure
-import twisted.web2.dav.test.util
-
-class HTTP(twisted.web2.dav.test.util.TestCase):
-    """
-    HTTP Utilities
-    """
-    def test_statusForFailure_errno(self):
-        """
-        statusForFailure() for exceptions with known errno values
-        """
-        for ex_class in (IOError, OSError):
-            for exception, result in (
-                (ex_class(errno.EACCES, "Permission denied" ), responsecode.FORBIDDEN),
-                (ex_class(errno.EPERM , "Permission denied" ), responsecode.FORBIDDEN),
-                (ex_class(errno.ENOSPC, "No space available"), responsecode.INSUFFICIENT_STORAGE_SPACE),
-                (ex_class(errno.ENOENT, "No such file"      ), responsecode.NOT_FOUND),
-            ):
-                self._check_exception(exception, result)
-
-    def test_statusForFailure_HTTPError(self):
-        """
-        statusForFailure() for HTTPErrors
-        """
-        for code in responsecode.RESPONSES:
-            self._check_exception(HTTPError(code), code)
-            self._check_exception(HTTPError(ErrorResponse(code, ("http://twistedmatrix.com/", "bar"))), code)
-
-    def test_statusForFailure_exception(self):
-        """
-        statusForFailure() for known/unknown exceptions
-        """
-        for exception, result in (
-            (NotImplementedError("Duh..."), responsecode.NOT_IMPLEMENTED),
-        ):
-            self._check_exception(exception, result)
-
-        class UnknownException (Exception):
-            pass
-
-        try:
-            self._check_exception(UnknownException(), None)
-        except UnknownException:
-            pass
-        else:
-            self.fail("Unknown exception should have re-raised.")
-
-    def _check_exception(self, exception, result):
-        try:
-            raise exception
-        except Exception, e:
-            failure = Failure()
-            status = statusForFailure(failure)
-            self.failUnless(
-                status == result,
-                "Failure %r (%s) generated incorrect status code: %s != %s"
-                % (failure, failure.value, status, result)
-            )
-        else:
-            raise AssertionError("We shouldn't be here.")
Index: twisted/web2/dav/test/test_prop.py
===================================================================
--- twisted/web2/dav/test/test_prop.py	(revision 22823)
+++ twisted/web2/dav/test/test_prop.py	(working copy)
@@ -1,330 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-import random
-
-from twisted.trial.unittest import SkipTest
-from twisted.web2 import responsecode
-from twisted.web2.iweb import IResponse
-from twisted.web2.stream import MemoryStream
-from twisted.web2 import http_headers
-from twisted.web2.dav import davxml
-from twisted.web2.dav.resource import DAVResource
-from twisted.web2.dav.davxml import dav_namespace, lookupElement
-from twisted.web2.dav.util import davXMLFromStream
-from twisted.web2.test.test_server import SimpleRequest
-from twisted.web2.dav.test.util import serialize
-import twisted.web2.dav.test.util
-
-live_properties = [lookupElement(qname)() for qname in DAVResource.liveProperties if qname[0] == dav_namespace]
-
-#
-# See whether dead properties are available
-#
-from twisted.web2.dav.noneprops import NonePropertyStore
-from twisted.web2.dav.static import DeadPropertyStore
-if DeadPropertyStore == NonePropertyStore:
-    have_dead_properties = False
-else:
-    have_dead_properties = True
-
-class PROP(twisted.web2.dav.test.util.TestCase):
-    """
-    PROPFIND, PROPPATCH requests
-    """
-    def test_PROPFIND_basic(self):
-        """
-        PROPFIND request
-        """
-        def check_result(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.MULTI_STATUS:
-                self.fail("Incorrect response code for PROPFIND (%s != %s)"
-                          % (response.code, responsecode.MULTI_STATUS))
-
-            content_type = response.headers.getHeader("content-type")
-            if content_type not in (http_headers.MimeType("text", "xml"),
-                                    http_headers.MimeType("application", "xml")):
-                self.fail("Incorrect content-type for PROPFIND response (%r not in %r)"
-                          % (content_type, (http_headers.MimeType("text", "xml"),
-                                            http_headers.MimeType("application", "xml"))))
-
-            return davXMLFromStream(response.stream).addCallback(check_xml)
-
-        def check_xml(doc):
-            multistatus = doc.root_element
-
-            if not isinstance(multistatus, davxml.MultiStatus):
-                self.fail("PROPFIND response XML root element is not multistatus: %r" % (multistatus,))
-
-            for response in multistatus.childrenOfType(davxml.PropertyStatusResponse):
-                if response.childOfType(davxml.HRef) == "/":
-                    for propstat in response.childrenOfType(davxml.PropertyStatus):
-                        status = propstat.childOfType(davxml.Status)
-                        properties = propstat.childOfType(davxml.PropertyContainer).children
-
-                        if status.code != responsecode.OK:
-                            self.fail("PROPFIND failed (status %s) to locate live properties: %s"
-                                      % (status.code, properties))
-
-                        properties_to_find = [p.qname() for p in live_properties]
-
-                        for property in properties:
-                            qname = property.qname()
-                            if qname in properties_to_find:
-                                properties_to_find.remove(qname)
-                            else:
-                                self.fail("PROPFIND found property we didn't ask for: %r" % (property,))
-
-                        if properties_to_find:
-                            self.fail("PROPFIND failed to find properties: %r" % (properties_to_find,))
-
-                    break
-
-            else:
-                self.fail("No response for URI /")
-
-        query = davxml.PropertyFind(davxml.PropertyContainer(*live_properties))
-
-        request = SimpleRequest(self.site, "PROPFIND", "/")
-
-        depth = random.choice(("0", "1", "infinity", None))
-        if depth is not None:
-            request.headers.setHeader("depth", depth)
-
-        request.stream = MemoryStream(query.toxml())
-
-        return self.send(request, check_result)
-
-    def test_PROPFIND_list(self):
-        """
-        PROPFIND with allprop, propname
-        """
-        def check_result(which):
-            def _check_result(response):
-                response = IResponse(response)
-
-                if response.code != responsecode.MULTI_STATUS:
-                    self.fail("Incorrect response code for PROPFIND (%s != %s)"
-                              % (response.code, responsecode.MULTI_STATUS))
-
-                return davXMLFromStream(response.stream).addCallback(check_xml, which)
-            return _check_result
-
-        def check_xml(doc, which):
-            response = doc.root_element.childOfType(davxml.PropertyStatusResponse)
-
-            self.failUnless(
-                response.childOfType(davxml.HRef) == "/",
-                "Incorrect response URI: %s != /" % (response.childOfType(davxml.HRef),)
-            )
-
-            for propstat in response.childrenOfType(davxml.PropertyStatus):
-                status = propstat.childOfType(davxml.Status)
-                properties = propstat.childOfType(davxml.PropertyContainer).children
-
-                if status.code != responsecode.OK:
-                    self.fail("PROPFIND failed (status %s) to locate live properties: %s"
-                              % (status.code, properties))
-
-                if which.name == "allprop":
-                    properties_to_find = [p.qname() for p in live_properties if not p.hidden]
-                else:
-                    properties_to_find = [p.qname() for p in live_properties]
-
-                for property in properties:
-                    qname = property.qname()
-                    if qname in properties_to_find:
-                        properties_to_find.remove(qname)
-                    elif qname[0] != dav_namespace:
-                        pass
-                    else:
-                        self.fail("PROPFIND with %s found property we didn't expect: %r" % (which.name, property))
-
-                    if which.name == "propname":
-                        # Element should be empty
-                        self.failUnless(len(property.children) == 0)
-                    else:
-                        # Element should have a value
-                        # Actually, this isn't necessarily true, but it is for the live
-                        # properties we've defined so far...
-                        self.failIf(len(property.children) == 0)
-
-                if properties_to_find:
-                    self.fail("PROPFIND with %s failed to find properties: %r" % (which.name, properties_to_find))
-
-            properties = propstat.childOfType(davxml.PropertyContainer).children
-
-        def work():
-            for which in (davxml.AllProperties(), davxml.PropertyName()):
-                query = davxml.PropertyFind(which)
-
-                request = SimpleRequest(self.site, "PROPFIND", "/")
-                request.headers.setHeader("depth", "0")
-                request.stream = MemoryStream(query.toxml())
-
-                yield (request, check_result(which))
-
-        return serialize(self.send, work())
-
-    def test_PROPPATCH_basic(self):
-        """
-        PROPPATCH
-        """
-        # FIXME:
-        # Do PROPFIND to make sure it's still there
-        # Test nonexistant resource
-        # Test None namespace in property
-
-        def check_patch_response(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.MULTI_STATUS:
-                self.fail("Incorrect response code for PROPFIND (%s != %s)"
-                          % (response.code, responsecode.MULTI_STATUS))
-
-            content_type = response.headers.getHeader("content-type")
-            if content_type not in (http_headers.MimeType("text", "xml"),
-                                    http_headers.MimeType("application", "xml")):
-                self.fail("Incorrect content-type for PROPPATCH response (%r not in %r)"
-                          % (content_type, (http_headers.MimeType("text", "xml"),
-                                            http_headers.MimeType("application", "xml"))))
-
-            return davXMLFromStream(response.stream).addCallback(check_patch_xml)
-
-        def check_patch_xml(doc):
-            multistatus = doc.root_element
-
-            if not isinstance(multistatus, davxml.MultiStatus):
-                self.fail("PROPFIND response XML root element is not multistatus: %r" % (multistatus,))
-
-            # Requested a property change one resource, so there should be exactly one response
-            response = multistatus.childOfType(davxml.Response)
-
-            # Should have a response description (its contents are arbitrary)
-            response.childOfType(davxml.ResponseDescription)
-
-            # Requested property change was on /
-            self.failUnless(
-                response.childOfType(davxml.HRef) == "/",
-                "Incorrect response URI: %s != /" % (response.childOfType(davxml.HRef),)
-            )
-
-            # Requested one property change, so there should be exactly one property status
-            propstat = response.childOfType(davxml.PropertyStatus)
-
-            # And the contained property should be a SpiffyProperty
-            self.failIf(
-                propstat.childOfType(davxml.PropertyContainer).childOfType(SpiffyProperty) is None,
-                "Not a SpiffyProperty in PROPPATCH property status: %s" % (propstat.toxml())
-            )
-
-            if not have_dead_properties:
-                raise SkipTest(
-                    "No dead property store available for DAVFile.  "
-                    "Install xattr (http://undefined.org/python/#xattr) to enable use of dead properties."
-                )
-
-            # And the status should be 200
-            self.failUnless(
-                propstat.childOfType(davxml.Status).code == responsecode.OK,
-                "Incorrect status code for PROPPATCH of property %s: %s != %s"
-                % (propstat.childOfType(davxml.PropertyContainer).toxml(),
-                   propstat.childOfType(davxml.Status).code, responsecode.OK)
-            )
-
-        patch = davxml.PropertyUpdate(
-            davxml.Set(
-                davxml.PropertyContainer(
-                    SpiffyProperty.fromString("This is a spiffy resource.")
-                )
-            )
-        )
-
-        request = SimpleRequest(self.site, "PROPPATCH", "/")
-        request.stream = MemoryStream(patch.toxml())
-        return self.send(request, check_patch_response)
-
-    def test_PROPPATCH_liveprop(self):
-        """
-        PROPPATCH on a live property
-        """
-        prop = davxml.GETETag.fromString("some-etag-string")
-        patch = davxml.PropertyUpdate(davxml.Set(davxml.PropertyContainer(prop)))
-
-        return self._simple_PROPPATCH(patch, prop, responsecode.FORBIDDEN, "edit of live property")
-
-    def test_PROPPATCH_exists_not(self):
-        """
-        PROPPATCH remove a non-existant property
-        """
-        prop = davxml.Timeout() # Timeout isn't a valid property, so it won't exist.
-        patch = davxml.PropertyUpdate(davxml.Remove(davxml.PropertyContainer(prop)))
-
-        return self._simple_PROPPATCH(patch, prop, responsecode.OK, "remove of non-existant property")
-
-    def _simple_PROPPATCH(self, patch, prop, expected_code, what):
-        def check_result(response):
-            response = IResponse(response)
-
-            if response.code != responsecode.MULTI_STATUS:
-                self.fail("Incorrect response code for PROPPATCH (%s != %s)"
-                          % (response.code, responsecode.MULTI_STATUS))
-
-            return davXMLFromStream(response.stream).addCallback(check_xml)
-
-        def check_xml(doc):
-            response = doc.root_element.childOfType(davxml.Response)
-            propstat = response.childOfType(davxml.PropertyStatus)
-
-            self.failUnless(
-                response.childOfType(davxml.HRef) == "/",
-                "Incorrect response URI: %s != /" % (response.childOfType(davxml.HRef),)
-            )
-
-            self.failIf(
-                propstat.childOfType(davxml.PropertyContainer).childOfType(prop) is None,
-                "Not a %s in PROPPATCH property status: %s" % (prop.sname(), propstat.toxml())
-            )
-
-            if not have_dead_properties:
-                raise SkipTest(
-                    "No dead property store available for DAVFile.  "
-                    "Install xattr (http://undefined.org/python/#xattr) to enable use of dead properties."
-                )
-
-            self.failUnless(
-                propstat.childOfType(davxml.Status).code == expected_code,
-                "Incorrect status code for PROPPATCH %s: %s != %s"
-                % (what, propstat.childOfType(davxml.Status).code, expected_code)
-            )
-
-        request = SimpleRequest(self.site, "PROPPATCH", "/")
-        request.stream = MemoryStream(patch.toxml())
-        return self.send(request, check_result)
-
-class SpiffyProperty (davxml.WebDAVTextElement):
-    namespace = "http://twistedmatrix.com/ns/private/tests"
-    name = "spiffyproperty"
Index: twisted/web2/dav/test/data/xml/REPORT_request.xml
===================================================================
--- twisted/web2/dav/test/data/xml/REPORT_request.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/REPORT_request.xml	(working copy)
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<D:expand-property xmlns:D="DAV:">
-  <D:property name="version-history">
-    <D:property name="version-set">
-      <D:property name="creator-displayname"/>
-      <D:property name="activity-set"/>
-    </D:property>
-  </D:property>
-</D:expand-property>
Index: twisted/web2/dav/test/data/xml/PROPFIND_bad.xml
===================================================================
--- twisted/web2/dav/test/data/xml/PROPFIND_bad.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/PROPFIND_bad.xml	(working copy)
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<propfind xmlns="DAV:">
-  <foobar/>
-  <allprop/>
-</propfind>
Index: twisted/web2/dav/test/data/xml/PROPPATCH_request.xml
===================================================================
--- twisted/web2/dav/test/data/xml/PROPPATCH_request.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/PROPPATCH_request.xml	(working copy)
@@ -1,12 +0,0 @@
-<D:propertyupdate xmlns:D="DAV:">
-<D:set><D:prop><prop0 xmlns="http://webdav.org/neon/litmus/">value0</prop0></D:prop></D:set>
-<D:set><D:prop><prop1 xmlns="http://webdav.org/neon/litmus/">value1</prop1></D:prop></D:set>
-<D:set><D:prop><prop2 xmlns="http://webdav.org/neon/litmus/">value2</prop2></D:prop></D:set>
-<D:set><D:prop><prop3 xmlns="http://webdav.org/neon/litmus/">value3</prop3></D:prop></D:set>
-<D:set><D:prop><prop4 xmlns="http://webdav.org/neon/litmus/">value4</prop4></D:prop></D:set>
-<D:set><D:prop><prop5 xmlns="http://webdav.org/neon/litmus/">value5</prop5></D:prop></D:set>
-<D:set><D:prop><prop6 xmlns="http://webdav.org/neon/litmus/">value6</prop6></D:prop></D:set>
-<D:set><D:prop><prop7 xmlns="http://webdav.org/neon/litmus/">value7</prop7></D:prop></D:set>
-<D:set><D:prop><prop8 xmlns="http://webdav.org/neon/litmus/">value8</prop8></D:prop></D:set>
-<D:set><D:prop><prop9 xmlns="http://webdav.org/neon/litmus/">value9</prop9></D:prop></D:set>
-</D:propertyupdate>
Index: twisted/web2/dav/test/data/xml/PROPFIND_request.xml
===================================================================
--- twisted/web2/dav/test/data/xml/PROPFIND_request.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/PROPFIND_request.xml	(working copy)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<propfind xmlns="DAV:">
-  <prop>
-    <getcontentlength xmlns="DAV:"/>
-    <getlastmodified xmlns="DAV:"/>
-    <displayname xmlns="DAV:"/>
-    <resourcetype xmlns="DAV:"/>
-    <foo xmlns="http://webdav.org/neon/litmus/"/>
-    <bar xmlns="http://webdav.org/neon/litmus/"/>
-  </prop>
-</propfind>
Index: twisted/web2/dav/test/data/xml/REPORT_response.xml
===================================================================
--- twisted/web2/dav/test/data/xml/REPORT_response.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/REPORT_response.xml	(working copy)
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<D:multistatus xmlns:D="DAV:">
-  <D:response>
-    <D:href>http://www.webdav.org/foo.html</D:href>
-    <D:propstat>
-      <D:prop>
-        <D:version-history>
-          <D:response>
-            <D:href>http://repo.webdav.org/his/23</D:href>
-            <D:propstat>
-              <D:prop>
-                <D:version-set>
-                  <D:response>
-                    <D:href>http://repo.webdav.org/his/23/ver/1</D:href>
-                    <D:propstat>
-                      <D:prop>
-                        <D:creator-displayname>Fred</D:creator-displayname>
-                        <D:activity-set>
-                          <D:href>
-                               http://www.webdav.org/ws/dev/sally
-                             </D:href>
-                        </D:activity-set>
-                      </D:prop>
-                      <D:status>HTTP/1.1 200 OK</D:status>
-                    </D:propstat>
-                  </D:response>
-                  <D:response>
-                    <D:href>http://repo.webdav.org/his/23/ver/2</D:href>
-                    <D:propstat>
-                      <D:prop>
-                        <D:creator-displayname>Sally</D:creator-displayname>
-                        <D:activity-set>
-                          <D:href>http://repo.webdav.org/act/add-refresh-cmd</D:href>
-                        </D:activity-set>
-                      </D:prop>
-                      <D:status>HTTP/1.1 200 OK</D:status>
-                    </D:propstat>
-                  </D:response>
-                </D:version-set>
-              </D:prop>
-              <D:status>HTTP/1.1 200 OK</D:status>
-            </D:propstat>
-          </D:response>
-        </D:version-history>
-      </D:prop>
-      <D:status>HTTP/1.1 200 OK</D:status>
-    </D:propstat>
-  </D:response>
-</D:multistatus>
Index: twisted/web2/dav/test/data/xml/PROPFIND_nonamespace.xml
===================================================================
--- twisted/web2/dav/test/data/xml/PROPFIND_nonamespace.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/PROPFIND_nonamespace.xml	(working copy)
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<propfind xmlns="DAV:">
-  <prop>
-    <nonamespace xmlns=""/>
-  </prop>
-</propfind>
Index: twisted/web2/dav/test/data/xml/PROPFIND_response.xml
===================================================================
--- twisted/web2/dav/test/data/xml/PROPFIND_response.xml	(revision 22823)
+++ twisted/web2/dav/test/data/xml/PROPFIND_response.xml	(working copy)
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<D:multistatus xmlns:D="DAV:">
-  <D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
-    <D:href>/uploads/</D:href>
-    <D:propstat>
-      <D:prop>
-        <lp1:resourcetype>
-          <D:collection/>
-        </lp1:resourcetype>
-        <lp1:creationdate>2005-07-05T23:08:01Z</lp1:creationdate>
-        <lp1:getlastmodified>Tue, 05 Jul 2005 23:08:01 GMT</lp1:getlastmodified>
-        <lp1:getetag>"77a99-66-27dd9640"</lp1:getetag>
-        <D:supportedlock>
-          <D:lockentry>
-            <D:lockscope>
-              <D:exclusive/>
-            </D:lockscope>
-            <D:locktype>
-              <D:write/>
-            </D:locktype>
-          </D:lockentry>
-          <D:lockentry>
-            <D:lockscope>
-              <D:shared/>
-            </D:lockscope>
-            <D:locktype>
-              <D:write/>
-            </D:locktype>
-          </D:lockentry>
-        </D:supportedlock>
-        <D:getcontenttype>httpd/unix-directory</D:getcontenttype>
-      </D:prop>
-      <D:status>HTTP/1.1 200 OK</D:status>
-    </D:propstat>
-  </D:response>
-  <D:response xmlns:lp1="DAV:" xmlns:lp2="http://apache.org/dav/props/">
-    <D:href>/uploads/foo.txt</D:href>
-    <D:propstat>
-      <D:prop>
-        <lp1:resourcetype/>
-        <lp1:creationdate>2005-07-05T23:08:08Z</lp1:creationdate>
-        <lp1:getcontentlength>19</lp1:getcontentlength>
-        <lp1:getlastmodified>Tue, 05 Jul 2005 23:08:08 GMT</lp1:getlastmodified>
-        <lp1:getetag>"77a9f-13-28486600"</lp1:getetag>
-        <lp2:executable>F</lp2:executable>
-        <D:supportedlock>
-          <D:lockentry>
-            <D:lockscope>
-              <D:exclusive/>
-            </D:lockscope>
-            <D:locktype>
-              <D:write/>
-            </D:locktype>
-          </D:lockentry>
-          <D:lockentry>
-            <D:lockscope>
-              <D:shared/>
-            </D:lockscope>
-            <D:locktype>
-              <D:write/>
-            </D:locktype>
-          </D:lockentry>
-        </D:supportedlock>
-        <D:getcontenttype>text/plain</D:getcontenttype>
-      </D:prop>
-      <D:status>HTTP/1.1 200 OK</D:status>
-    </D:propstat>
-  </D:response>
-</D:multistatus>
Index: twisted/web2/dav/test/test_lock.py
===================================================================
--- twisted/web2/dav/test/test_lock.py	(revision 22823)
+++ twisted/web2/dav/test/test_lock.py	(working copy)
@@ -1,53 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-from twisted.trial.unittest import SkipTest
-import twisted.web2.dav.test.util
-
-class LOCK_UNLOCK(twisted.web2.dav.test.util.TestCase):
-    """
-    LOCK, UNLOCK requests
-    """
-    # FIXME:
-    # Check PUT
-    # Check POST
-    # Check PROPPATCH
-    # Check LOCK
-    # Check UNLOCK
-    # Check MOVE, COPY
-    # Check DELETE
-    # Check MKCOL
-    # Check null resource
-    # Check collections
-    # Check depth
-    # Check If header
-    # Refresh lock
-
-    def test_LOCK_UNLOCK(self):
-        """
-        LOCK, UNLOCK request
-        """
-        raise SkipTest("test unimplemented")
-
-    test_LOCK_UNLOCK.todo = "LOCK/UNLOCK unimplemented"
Index: twisted/web2/dav/method/lock.py
===================================================================
--- twisted/web2/dav/method/lock.py	(revision 22823)
+++ twisted/web2/dav/method/lock.py	(working copy)
@@ -1,44 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_lock -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV LOCK and UNLOCK methods
-"""
-
-__all__ = ["http_LOCK", "http_UNLOCK"]
-
-from twisted.web2 import responsecode
-
-def http_LOCK(self, request):
-    """
-    Respond to a LOCK request. (RFC 2518, section 8.10)
-    """
-    return responsecode.NOT_IMPLEMENTED
-
-def http_UNLOCK(self, request):
-    """
-    Respond to a UNLOCK request. (RFC 2518, section 8.11)
-    """
-    return responsecode.NOT_IMPLEMENTED
Index: twisted/web2/dav/method/put.py
===================================================================
--- twisted/web2/dav/method/put.py	(revision 22823)
+++ twisted/web2/dav/method/put.py	(working copy)
@@ -1,89 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_put -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV PUT method
-"""
-
-__all__ = ["preconditions_PUT", "http_PUT"]
-
-from twisted.python import log
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-from twisted.web2.dav.fileop import put
-
-def preconditions_PUT(self, request):
-    if self.fp.exists():
-        if not self.fp.isfile():
-            log.err("Unable to PUT to non-file: %s" % (self.fp.path,))
-            raise HTTPError(StatusResponse(
-                responsecode.FORBIDDEN,
-                "The requested resource exists but is not backed by a regular file."
-            ))
-        resource_is_new = False
-    else:
-        if not self.fp.parent().isdir():
-            log.err("No such directory: %s" % (self.fp.path,))
-            raise HTTPError(StatusResponse(
-                responsecode.CONFLICT,
-                "Parent collection resource does not exist."
-            ))
-        resource_is_new = True
-
-    #
-    # HTTP/1.1 (RFC 2068, section 9.6) requires that we respond with a Not
-    # Implemented error if we get a Content-* header which we don't
-    # recognize and handle properly.
-    #
-    for header, value in request.headers.getAllRawHeaders():
-        if header.startswith("Content-") and header not in (
-           #"Content-Base",     # Doesn't make sense in PUT?
-           #"Content-Encoding", # Requires that we decode it?
-            "Content-Language",
-            "Content-Length",
-           #"Content-Location", # Doesn't make sense in PUT?
-            "Content-MD5",
-           #"Content-Range",    # FIXME: Need to implement this
-            "Content-Type",
-        ):
-            log.err("Client sent unrecognized content header in PUT request: %s"
-                    % (header,))
-            raise HTTPError(StatusResponse(
-                responsecode.NOT_IMPLEMENTED,
-                "Unrecognized content header %r in request." % (header,)
-            ))
-
-def http_PUT(self, request):
-    """
-    Respond to a PUT request. (RFC 2518, section 8.7)
-    """
-    log.msg("Writing request stream to %s" % (self.fp.path,))
-
-    #
-    # Don't pass in the request URI, since PUT isn't specified to be able
-    # to return a MULTI_STATUS response, which is WebDAV-specific (and PUT is
-    # not).
-    #
-    return put(request.stream, self.fp)
Index: twisted/web2/dav/method/report_expand.py
===================================================================
--- twisted/web2/dav/method/report_expand.py	(revision 22823)
+++ twisted/web2/dav/method/report_expand.py	(working copy)
@@ -1,115 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_report_expand -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV expand-property report
-"""
-
-__all__ = ["report_DAV__expand_property"]
-
-from twisted.python import log
-from twisted.python.failure import Failure
-from twisted.internet.defer import deferredGenerator, waitForDeferred
-from twisted.web2 import responsecode
-from twisted.web2.dav import davxml
-from twisted.web2.dav.http import statusForFailure
-from twisted.web2.dav.davxml import dav_namespace
-
-def report_DAV__expand_property(self, request, expand_property):
-    """
-    Generate an expand-property REPORT. (RFC 3253, section 3.8)
-    """
-    # FIXME: Handle depth header
-
-    if not isinstance(expand_property, davxml.ExpandProperty):
-        raise ValueError("%s expected as root element, not %s."
-                         % (davxml.ExpandProperty.sname(), expand_property.sname()))
-
-    #
-    # Expand DAV:allprop
-    #
-    properties = {}
-
-    for property in expand_property.children:
-        namespace = property.getAttribute("namespace")
-        name      = property.getAttribute("name")
-
-        if not namespace: namespace = dav_namespace
-
-        if (namespace, name) == (dav_namespace, "allprop"):
-            all_properties = waitForDeferred(self.listAllProp(request))
-            yield all_properties
-            all_properties = all_properties.getResult()
-
-            for all_property in all_properties:
-                properties[all_property.qname()] = property
-        else:
-            properties[(namespace, name)] = property
-
-    #
-    # Look up the requested properties
-    #
-    properties_by_status = {
-        responsecode.OK        : [],
-        responsecode.NOT_FOUND : [],
-    }
-
-    for property in properties:
-        my_properties = waitForDeferred(self.listProperties(request))
-        yield my_properties
-        my_properties = my_properties.getResult()
-
-        if property in my_properties:
-            try:
-                value = waitForDeferred(self.readProperty(property, request))
-                yield value
-                value = value.getResult()
-
-                if isinstance(value, davxml.HRef):
-                    raise NotImplementedError()
-                else:
-                    raise NotImplementedError()
-            except:
-                f = Failure()
-
-                log.err("Error reading property %r for resource %s: %s"
-                        % (property, self, f.value))
-
-                status = statusForFailure(f, "getting property: %s" % (property,))
-                if status not in properties_by_status:
-                    properties_by_status[status] = []
-
-                raise NotImplementedError()
-
-                #properties_by_status[status].append(
-                #    ____propertyName(property)
-                #)
-        else:
-            log.err("Can't find property %r for resource %s" % (property, self))
-            properties_by_status[responsecode.NOT_FOUND].append(property)
-
-    raise NotImplementedError()
-
-report_DAV__expand_property = deferredGenerator(report_DAV__expand_property)
Index: twisted/web2/dav/method/report.py
===================================================================
--- twisted/web2/dav/method/report.py	(revision 22823)
+++ twisted/web2/dav/method/report.py	(working copy)
@@ -1,104 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_report -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV REPORT method
-"""
-
-__all__ = ["http_REPORT"]
-
-import string
-
-from twisted.python import log
-from twisted.internet.defer import deferredGenerator, waitForDeferred
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-from twisted.web2.dav import davxml
-from twisted.web2.dav.http import ErrorResponse
-from twisted.web2.dav.util import davXMLFromStream
-
-def http_REPORT(self, request):
-    """
-    Respond to a REPORT request. (RFC 3253, section 3.6)
-    """
-    if not self.fp.exists():
-        log.err("File not found: %s" % (self.fp.path,))
-        raise HTTPError(responsecode.NOT_FOUND)
-
-    #
-    # Read request body
-    #
-    try:
-        doc = waitForDeferred(davXMLFromStream(request.stream))
-        yield doc
-        doc = doc.getResult()
-    except ValueError, e:
-        log.err("Error while handling REPORT body: %s" % (e,))
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, str(e)))
-
-    if doc is None:
-        raise HTTPError(StatusResponse(
-            responsecode.BAD_REQUEST,
-            "REPORT request body may not be empty"
-        ))
-
-    #
-    # Parse request
-    #
-    namespace = doc.root_element.namespace
-    name = doc.root_element.name
-
-    def to_method(s):
-        ok = string.ascii_letters + string.digits + "_"
-        out = []
-        for c in s:
-            if c in ok:
-                out.append(c)
-            else:
-                out.append("_")
-        return "report_" + "".join(out)
-
-    if namespace:
-        method_name = to_method(namespace + "_" + name)
-    else:
-        method_name = to_method(name)
-
-    try:
-        method = getattr(self, method_name)
-    except AttributeError:
-        #
-        # Requested report is not supported.
-        #
-        log.err("Unsupported REPORT {%s}%s for resource %s (no method %s)"
-                % (namespace, name, self, method_name))
-
-        raise HTTPError(ErrorResponse(
-            responsecode.FORBIDDEN,
-            davxml.SupportedReport()
-        ))
-
-    yield method(request, doc.root_element)
-
-http_REPORT = deferredGenerator(http_REPORT)
Index: twisted/web2/dav/method/__init__.py
===================================================================
--- twisted/web2/dav/method/__init__.py	(revision 22823)
+++ twisted/web2/dav/method/__init__.py	(working copy)
@@ -1,42 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV methods.
-
-Modules in this package provide the implementation of
-twisted.web2.dav.static.DAVFile's dispatched methods.
-"""
-
-__all__ = [
-    "copymove",
-    "delete",
-    "lock",
-    "mkcol",
-    "propfind",
-    "proppatch",
-    "put",
-    "report",
-    "report_expand",
-]
Index: twisted/web2/dav/method/proppatch.py
===================================================================
--- twisted/web2/dav/method/proppatch.py	(revision 22823)
+++ twisted/web2/dav/method/proppatch.py	(working copy)
@@ -1,185 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_prop.PROP.test_PROPPATCH -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV-aware static resources.
-"""
-
-__all__ = ["http_PROPPATCH"]
-
-from twisted.python import log
-from twisted.python.failure import Failure
-from twisted.internet.defer import deferredGenerator, waitForDeferred
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-from twisted.web2.dav import davxml
-from twisted.web2.dav.http import MultiStatusResponse, PropertyStatusResponseQueue
-from twisted.web2.dav.util import davXMLFromStream
-
-def http_PROPPATCH(self, request):
-    """
-    Respond to a PROPPATCH request. (RFC 2518, section 8.2)
-    """
-    if not self.fp.exists():
-        log.err("File not found: %s" % (self.fp.path,))
-        raise HTTPError(responsecode.NOT_FOUND)
-
-    #
-    # Read request body
-    #
-    try:
-        doc = waitForDeferred(davXMLFromStream(request.stream))
-        yield doc
-        doc = doc.getResult()
-    except ValueError, e:
-        log.err("Error while handling PROPPATCH body: %s" % (e,))
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, str(e)))
-
-    if doc is None:
-        error = "Request XML body is required."
-        log.err(error)
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, error))
-
-    #
-    # Parse request
-    #
-    update = doc.root_element
-    if not isinstance(update, davxml.PropertyUpdate):
-        error = ("Request XML body must be a propertyupdate element."
-                 % (davxml.PropertyUpdate.sname(),))
-        log.err(error)
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, error))
-
-    responses = PropertyStatusResponseQueue("PROPPATCH", request.uri, responsecode.NO_CONTENT)
-    undoActions = []
-    gotError = False
-
-    try:
-        #
-        # Update properties
-        #
-        for setOrRemove in update.children:
-            assert len(setOrRemove.children) == 1
-
-            container = setOrRemove.children[0]
-
-            assert isinstance(container, davxml.PropertyContainer)
-
-            properties = container.children
-
-            def do(action, property):
-                """
-                Perform action(property, request) while maintaining an
-                undo queue.
-                """
-                has = waitForDeferred(self.hasProperty(property, request))
-                yield has
-                has = has.getResult()
-
-                if has:
-                    oldProperty = waitForDeferred(self.readProperty(property, request))
-                    yield oldProperty
-                    oldProperty.getResult()
-
-                    def undo():
-                        return self.writeProperty(oldProperty, request)
-                else:
-                    def undo():
-                        return self.removeProperty(property, request)
-
-                try:
-                    x = waitForDeferred(action(property, request))
-                    yield x
-                    x.getResult()
-                except ValueError, e:
-                    # Convert ValueError exception into HTTPError
-                    responses.add(
-                        Failure(exc_value=HTTPError(StatusResponse(responsecode.FORBIDDEN, str(e)))),
-                        property
-                    )
-                    yield False
-                    return
-                except:
-                    responses.add(Failure(), property)
-                    yield False
-                    return
-                else:
-                    responses.add(responsecode.OK, property)
-
-                    # Only add undo action for those that succeed because those that fail will not have changed               
-                    undoActions.append(undo)
-
-                    yield True
-                    return
-
-            do = deferredGenerator(do)
-
-            if isinstance(setOrRemove, davxml.Set):
-                for property in properties:
-                    ok = waitForDeferred(do(self.writeProperty, property))
-                    yield ok
-                    ok = ok.getResult()
-                    if not ok:
-                        gotError = True
-            elif isinstance(setOrRemove, davxml.Remove):
-                for property in properties:
-                    ok = waitForDeferred(do(self.removeProperty, property))
-                    yield ok
-                    ok = ok.getResult()
-                    if not ok:
-                        gotError = True
-            else:
-                raise AssertionError("Unknown child of PropertyUpdate: %s" % (setOrRemove,))
-    except:
-        #
-        # If there is an error, we have to back out whatever we have
-        # operations we have done because PROPPATCH is an
-        # all-or-nothing request.
-        # We handle the first one here, and then re-raise to handle the
-        # rest in the containing scope.
-        #
-        for action in undoActions:
-            x = waitForDeferred(action())
-            yield x
-            x.getResult()
-        raise
-
-    #
-    # If we had an error we need to undo any changes that did succeed and change status of
-    # those to 424 Failed Dependency.
-    #
-    if gotError:
-        for action in undoActions:
-            x = waitForDeferred(action())
-            yield x
-            x.getResult()
-        responses.error()
-
-    #
-    # Return response
-    #
-    yield MultiStatusResponse([responses.response()])
-
-http_PROPPATCH = deferredGenerator(http_PROPPATCH)
Index: twisted/web2/dav/method/copymove.py
===================================================================
--- twisted/web2/dav/method/copymove.py	(revision 22823)
+++ twisted/web2/dav/method/copymove.py	(working copy)
@@ -1,180 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_copy,twisted.web2.dav.test.test_move -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV COPY and MOVE methods.
-"""
-
-__all__ = ["http_COPY", "http_MOVE"]
-
-from twisted.python import log
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-from twisted.web2.filter.location import addLocation
-from twisted.web2.dav.idav import IDAVResource
-from twisted.web2.dav.fileop import copy, move
-
-# FIXME: This is circular
-import twisted.web2.dav.static
-
-def http_COPY(self, request):
-    """
-    Respond to a COPY request. (RFC 2518, section 8.8)
-    """
-    def doCopy(r):
-        destination, destination_uri, depth = r
-
-        # May need to add a location header
-        addLocation(request, destination_uri)
-
-        return copy(self.fp, destination.fp, destination_uri, depth)
-
-    d = prepareForCopy(self, request)
-    d.addCallback(doCopy)
-    return d
-
-def http_MOVE(self, request):
-    """
-    Respond to a MOVE request. (RFC 2518, section 8.9)
-    """
-    def doMove(r):
-        destination, destination_uri, depth = r
-
-        #
-        # RFC 2518, section 8.9 says that we must act as if the Depth header is set
-        # to infinity, and that the client must omit the Depth header or set it to
-        # infinity.
-        #
-        # This seems somewhat at odds with the notion that a bad request should be
-        # rejected outright; if the client sends a bad depth header, the client is
-        # broken, and section 8 suggests that a bad request should be rejected...
-        #
-        # Let's play it safe for now and ignore broken clients.
-        #
-        if self.fp.isdir() and depth != "infinity":
-            msg = "Client sent illegal depth header value for MOVE: %s" % (depth,)
-            log.err(msg)
-            raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, msg))
-
-        # May need to add a location header
-        addLocation(request, destination_uri)
-
-        return move(self.fp, request.uri, destination.fp, destination_uri, depth)
-
-    d = prepareForCopy(self, request)
-    d.addCallback(doMove)
-    return d
-
-def prepareForCopy(self, request):
-    #
-    # Get the depth
-    #
-
-    depth = request.headers.getHeader("depth", "infinity")
-
-    if depth not in ("0", "infinity"):
-        msg = ("Client sent illegal depth header value: %s" % (depth,))
-        log.err(msg)
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, msg))
-
-    #
-    # Verify this resource exists
-    #
-
-    if not self.exists():
-        log.err("File not found: %s" % (self.fp.path,))
-        raise HTTPError(StatusResponse(
-            responsecode.NOT_FOUND,
-            "Source resource %s not found." % (request.uri,)
-        ))
-
-    #
-    # Get the destination
-    #
-
-    destination_uri = request.headers.getHeader("destination")
-
-    if not destination_uri:
-        msg = "No destination header in %s request." % (request.method,)
-        log.err(msg)
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, msg))
-
-    d = request.locateResource(destination_uri)
-    d.addCallback(_prepareForCopy, destination_uri, request, depth)
-
-    return d
-
-def _prepareForCopy(destination, destination_uri, request, depth):
-    #
-    # Destination must be a DAV resource
-    #
-
-    try:
-        destination = IDAVResource(destination)
-    except TypeError:
-        log.err("Attempt to %s to a non-DAV resource: (%s) %s"
-                % (request.method, destination.__class__, destination_uri))
-        raise HTTPError(StatusResponse(
-            responsecode.FORBIDDEN,
-            "Destination %s is not a WebDAV resource." % (destination_uri,)
-        ))
-
-    #
-    # FIXME: Right now we don't know how to copy to a non-DAVFile resource.
-    # We may need some more API in IDAVResource.
-    # So far, we need: .exists(), .fp.parent()
-    #
-
-    if not isinstance(destination, twisted.web2.dav.static.DAVFile):
-        log.err("DAV copy between non-DAVFile DAV resources isn't implemented")
-        raise HTTPError(StatusResponse(
-            responsecode.NOT_IMPLEMENTED,
-            "Destination %s is not a DAVFile resource." % (destination_uri,)
-        ))
-
-    #
-    # Check for existing destination resource
-    #
-
-    overwrite = request.headers.getHeader("overwrite", True)
-
-    if destination.exists() and not overwrite:
-        log.err("Attempt to %s onto existing file without overwrite flag enabled: %s"
-                % (request.method, destination.fp.path))
-        raise HTTPError(StatusResponse(
-            responsecode.PRECONDITION_FAILED,
-            "Destination %s already exists." % (destination_uri,)
-        ))
-
-    #
-    # Make sure destination's parent exists
-    #
-
-    if not destination.fp.parent().isdir():
-        log.err("Attempt to %s to a resource with no parent: %s"
-                % (request.method, destination.fp.path))
-        raise HTTPError(StatusResponse(responsecode.CONFLICT, "No parent collection."))
-
-    return destination, destination_uri, depth
Index: twisted/web2/dav/method/propfind.py
===================================================================
--- twisted/web2/dav/method/propfind.py	(revision 22823)
+++ twisted/web2/dav/method/propfind.py	(working copy)
@@ -1,183 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_prop.PROP.test_PROPFIND -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV PROPFIND method
-"""
-
-__all__ = ["http_PROPFIND"]
-
-from twisted.python import log
-from twisted.python.failure import Failure
-from twisted.internet.defer import deferredGenerator, waitForDeferred
-from twisted.web2.http import HTTPError
-from twisted.web2 import responsecode
-from twisted.web2.http import StatusResponse
-from twisted.web2.dav import davxml
-from twisted.web2.dav.http import MultiStatusResponse, statusForFailure
-from twisted.web2.dav.util import normalizeURL, joinURL, davXMLFromStream
-
-def http_PROPFIND(self, request):
-    """
-    Respond to a PROPFIND request. (RFC 2518, section 8.1)
-    """
-    if not self.exists():
-        log.err("File not found: %s" % (self.fp.path,))
-        raise HTTPError(responsecode.NOT_FOUND)
-
-    #
-    # Read request body
-    #
-    try:
-        doc = waitForDeferred(davXMLFromStream(request.stream))
-        yield doc
-        doc = doc.getResult()
-    except ValueError, e:
-        log.err("Error while handling PROPFIND body: %s" % (e,))
-        raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, str(e)))
-
-    if doc is None:
-        # No request body means get all properties.
-        search_properties = "all"
-    else:
-        #
-        # Parse request
-        #
-        find = doc.root_element
-        if not isinstance(find, davxml.PropertyFind):
-            error = ("Non-%s element in PROPFIND request body: %s"
-                     % (davxml.PropertyFind.sname(), find))
-            log.err(error)
-            raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, error))
-
-        container = find.children[0]
-
-        if isinstance(container, davxml.AllProperties):
-            # Get all properties
-            search_properties = "all"
-        elif isinstance(container, davxml.PropertyName):
-            # Get names only
-            search_properties = "names"
-        elif isinstance(container, davxml.PropertyContainer):
-            properties = container.children
-            search_properties = [(p.namespace, p.name) for p in properties]
-        else:
-            raise AssertionError("Unexpected element type in %s: %s"
-                                 % (davxml.PropertyFind.sname(), container))
-
-    #
-    # Generate XML output stream
-    #
-    request_uri = request.uri
-    depth = request.headers.getHeader("depth", "infinity")
-
-    xml_responses = []
-
-    resources = [(self, None)]
-    resources.extend(self.findChildren(depth))
-
-    for resource, uri in resources:
-        if uri is None:
-            uri = normalizeURL(request_uri)
-            if self.isCollection() and not uri.endswith("/"): uri += "/"
-        else:
-            uri = joinURL(request_uri, uri)
-
-        resource_properties = waitForDeferred(resource.listProperties(request))
-        yield resource_properties
-        resource_properties = resource_properties.getResult()
-
-        if search_properties is "names":
-            properties_by_status = {
-                responsecode.OK: [propertyName(p) for p in resource_properties]
-            }
-        else:
-            properties_by_status = {
-                responsecode.OK        : [],
-                responsecode.NOT_FOUND : [],
-            }
-
-            if search_properties is "all":
-                properties_to_enumerate = waitForDeferred(resource.listAllprop(request))
-                yield properties_to_enumerate
-                properties_to_enumerate = properties_to_enumerate.getResult()
-            else:
-                properties_to_enumerate = search_properties
-
-            for property in properties_to_enumerate:
-                if property in resource_properties:
-                    try:
-                        resource_property = waitForDeferred(resource.readProperty(property, request))
-                        yield resource_property
-                        resource_property = resource_property.getResult()
-                    except:
-                        f = Failure()
-
-                        log.err("Error reading property %r for resource %s: %s" % (property, uri, f.value))
-
-                        status = statusForFailure(f, "getting property: %s" % (property,))
-                        if status not in properties_by_status:
-                            properties_by_status[status] = []
-                        properties_by_status[status].append(propertyName(property))
-                    else:
-                        properties_by_status[responsecode.OK].append(resource_property)
-                else:
-                    log.err("Can't find property %r for resource %s" % (property, uri))
-                    properties_by_status[responsecode.NOT_FOUND].append(propertyName(property))
-
-        propstats = []
-
-        for status in properties_by_status:
-            properties = properties_by_status[status]
-            if not properties: continue
-
-            xml_status    = davxml.Status.fromResponseCode(status)
-            xml_container = davxml.PropertyContainer(*properties)
-            xml_propstat  = davxml.PropertyStatus(xml_container, xml_status)
-
-            propstats.append(xml_propstat)
-
-        xml_resource = davxml.HRef(uri)
-        xml_response = davxml.PropertyStatusResponse(xml_resource, *propstats)
-
-        xml_responses.append(xml_response)
-
-    #
-    # Return response
-    #
-    yield MultiStatusResponse(xml_responses)
-
-http_PROPFIND = deferredGenerator(http_PROPFIND)
-
-##
-# Utilities
-##
-
-def propertyName(name):
-    property_namespace, property_name = name
-    class PropertyName (davxml.WebDAVEmptyElement):
-        namespace = property_namespace
-        name = property_name
-    return PropertyName()
Index: twisted/web2/dav/method/delete.py
===================================================================
--- twisted/web2/dav/method/delete.py	(revision 22823)
+++ twisted/web2/dav/method/delete.py	(working copy)
@@ -1,47 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_delete -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV DELETE method
-"""
-
-__all__ = ["http_DELETE"]
-
-from twisted.python import log
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError
-from twisted.web2.dav.fileop import delete
-
-def http_DELETE(self, request):
-    """
-    Respond to a DELETE request. (RFC 2518, section 8.6)
-    """
-    if not self.fp.exists():
-        log.err("File not found: %s" % (self.fp.path,))
-        raise HTTPError(responsecode.NOT_FOUND)
-
-    depth = request.headers.getHeader("depth", "infinity")
-
-    return delete(request.uri, self.fp, depth)
Index: twisted/web2/dav/method/mkcol.py
===================================================================
--- twisted/web2/dav/method/mkcol.py	(revision 22823)
+++ twisted/web2/dav/method/mkcol.py	(working copy)
@@ -1,83 +0,0 @@
-# -*- test-case-name: twisted.web2.dav.test.test_mkcol -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV MKCOL method
-"""
-
-__all__ = ["http_MKCOL"]
-
-from twisted.python import log
-from twisted.internet.defer import deferredGenerator, waitForDeferred
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-from twisted.web2.dav.fileop import mkcollection
-from twisted.web2.dav.util import noDataFromStream, parentForURL
-
-def http_MKCOL(self, request):
-    """
-    Respond to a MKCOL request. (RFC 2518, section 8.3)
-    """
-    parent = waitForDeferred(request.locateResource(parentForURL(request.uri)))
-    yield parent
-    parent = parent.getResult()
-
-    if self.fp.exists():
-        log.err("Attempt to create collection where file exists: %s"
-                % (self.fp.path,))
-        raise HTTPError(responsecode.NOT_ALLOWED)
-
-    if not parent.isCollection():
-        log.err("Attempt to create collection with non-collection parent: %s"
-                % (self.fp.path,))
-        raise HTTPError(StatusResponse(
-            responsecode.CONFLICT,
-            "Parent resource is not a collection."
-        ))
-
-    if not self.fp.parent().isdir():
-        log.err("Attempt to create collection with no parent directory: %s"
-                % (self.fp.path,))
-        raise HTTPError(StatusResponse(
-            responsecode.INTERNAL_SERVER_ERROR,
-            "The requested resource is not backed by a parent directory."
-        ))
-
-    #
-    # Read request body
-    #
-    x = waitForDeferred(noDataFromStream(request.stream))
-    yield x
-    try:
-        x.getResult()
-    except ValueError, e:
-        log.err("Error while handling MKCOL body: %s" % (e,))
-        raise HTTPError(responsecode.UNSUPPORTED_MEDIA_TYPE)
-
-    response = waitForDeferred(mkcollection(self.fp))
-    yield response
-    yield response.getResult()
-
-http_MKCOL = deferredGenerator(http_MKCOL)
Index: twisted/web2/dav/davxml.py
===================================================================
--- twisted/web2/dav/davxml.py	(revision 22823)
+++ twisted/web2/dav/davxml.py	(working copy)
@@ -1,65 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV XML Support.
-
-This module provides XML utilities for use with WebDAV.
-
-This API is considered private to static.py and is therefore subject to
-change.
-
-See RFC 2518: http://www.ietf.org/rfc/rfc2518.txt (WebDAV)
-See RFC 3253: http://www.ietf.org/rfc/rfc3253.txt (WebDAV + Versioning)
-See RFC 3744: http://www.ietf.org/rfc/rfc3744.txt (WebDAV ACLs)
-"""
-
-from twisted.web2.dav.element.parser import registerElements, WebDAVDocument, lookupElement
-from twisted.web2.dav.element.util import encodeXMLName, decodeXMLName
-
-#
-# Import all XML element definitions
-#
-
-from twisted.web2.dav.element.base    import *
-from twisted.web2.dav.element.rfc2518 import *
-from twisted.web2.dav.element.rfc3253 import *
-from twisted.web2.dav.element.rfc3744 import *
-
-#
-# Register all XML elements with the parser
-#
-
-import twisted.web2.dav.element.base
-import twisted.web2.dav.element.rfc2518
-import twisted.web2.dav.element.rfc3253
-import twisted.web2.dav.element.rfc3744
-
-__all__ = (
-    registerElements(twisted.web2.dav.element.base   ) +
-    registerElements(twisted.web2.dav.element.rfc2518) +
-    registerElements(twisted.web2.dav.element.rfc3253) +
-    registerElements(twisted.web2.dav.element.rfc3744) +
-    ["registerElements", "WebDAVDocument", "lookupElement", "encodeXMLName", "decodeXMLName"]
-)
Index: twisted/web2/dav/util.py
===================================================================
--- twisted/web2/dav/util.py	(revision 22823)
+++ twisted/web2/dav/util.py	(working copy)
@@ -1,199 +0,0 @@
-# -*- test-case-name: twisted.web2.test.test_util -*-
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-Utilities
-
-This API is considered private to static.py and is therefore subject to
-change.
-"""
-
-__all__ = [
-    "allDataFromStream",
-    "davXMLFromStream",
-    "noDataFromStream",
-    "normalizeURL",
-    "joinURL",
-    "parentForURL",
-    "bindMethods",
-]
-
-import urllib
-from urlparse import urlsplit, urlunsplit
-import posixpath # Careful; this module is not documented as public API
-
-from twisted.python import log
-from twisted.python.failure import Failure
-from twisted.internet.defer import succeed
-from twisted.web2.stream import readStream
-
-from twisted.web2.dav import davxml
-
-##
-# Reading request body
-##
-
-def allDataFromStream(stream, filter=None):
-    data = []
-    def gotAllData(_):
-        if not data: return None
-        result = "".join([str(x) for x in data])
-        if filter is None:
-            return result
-        else:
-            return filter(result)
-    return readStream(stream, data.append).addCallback(gotAllData)
-
-def davXMLFromStream(stream):
-    # FIXME:
-    #   This reads the request body into a string and then parses it.
-    #   A better solution would parse directly and incrementally from the
-    #   request stream.
-    if stream is None:
-        return succeed(None)
-
-    def parse(xml):
-        try:
-            return davxml.WebDAVDocument.fromString(xml)
-        except ValueError:
-            log.err("Bad XML:\n%s" % (xml,))
-            raise
-    return allDataFromStream(stream, parse)
-
-def noDataFromStream(stream):
-    def gotData(data):
-        if data: raise ValueError("Stream contains unexpected data.")
-    return readStream(stream, gotData)
-
-##
-# URLs
-##
-
-def normalizeURL(url):
-    """
-    Normalized a URL.
-    @param url: a URL.
-    @return: the normalized representation of C{url}.  The returned URL will
-        never contain a trailing C{"/"}; it is up to the caller to determine
-        whether the resource referred to by the URL is a collection and add a
-        trailing C{"/"} if so.
-    """
-    def cleanup(path):
-        # For some silly reason, posixpath.normpath doesn't clean up '//' at the
-        # start of a filename, so let's clean it up here.
-        if path[0] == "/":
-            count = 0
-            for char in path:
-                if char != "/": break
-                count += 1
-            path = path[count-1:]
-
-        return path
-
-    (scheme, host, path, query, fragment) = urlsplit(cleanup(url))
-
-    path = cleanup(posixpath.normpath(urllib.unquote(path)))
-
-    return urlunsplit((scheme, host, urllib.quote(path), query, fragment))
-
-def joinURL(*urls):
-    """
-    Appends URLs in series.
-    @param urls: URLs to join.
-    @return: the normalized URL formed by combining each URL in C{urls}.  The
-        returned URL will contain a trailing C{"/"} if and only if the last
-        given URL contains a trailing C{"/"}.
-    """
-    if len(urls) > 0 and len(urls[-1]) > 0 and urls[-1][-1] == "/":
-        trailing = "/"
-    else:
-        trailing = ""
-
-    url = normalizeURL("/".join([url for url in urls]))
-    if url == "/":
-        return "/"
-    else:
-        return url + trailing
-
-def parentForURL(url):
-    """
-    Extracts the URL of the containing collection resource for the resource
-    corresponding to a given URL.
-    @param url: an absolute (server-relative is OK) URL.
-    @return: the normalized URL of the collection resource containing the
-        resource corresponding to C{url}.  The returned URL will always contain
-        a trailing C{"/"}.
-    """
-    (scheme, host, path, query, fragment) = urlsplit(normalizeURL(url))
-
-    index = path.rfind("/")
-    if index is 0:
-        if path == "/":
-            return None
-        else:
-            path = "/"
-    else:
-        if index is -1:
-            raise ValueError("Invalid URL: %s" % (url,))
-        else:
-            path = path[:index] + "/"
-
-    return urlunsplit((scheme, host, path, query, fragment))
-
-##
-# Python magic
-##
-
-def unimplemented(obj):
-    """
-    Throw an exception signifying that the current method is unimplemented
-    and should not have been invoked.
-    """
-    import inspect
-    caller = inspect.getouterframes(inspect.currentframe())[1][3]
-    raise NotImplementedError("Method %s is unimplemented in subclass %s" % (caller, obj.__class__))
-
-def bindMethods(module, clazz, prefixes=("preconditions_", "http_", "report_")):
-    """
-    Binds all functions in the given module (as defined by that module's
-    C{__all__} attribute) which start with any of the given prefixes as methods
-    of the given class.
-    @param module: the module in which to search for functions.
-    @param clazz: the class to bind found functions to as methods.
-    @param prefixes: a sequence of prefixes to match found functions against.
-    """
-    for submodule_name in module.__all__:
-        try:
-            __import__(module.__name__ + "." + submodule_name)
-        except ImportError:
-            log.err("Unable to import module %s" % (module.__name__ + "." + submodule_name,))
-            Failure().raiseException()
-        submodule = getattr(module, submodule_name)
-        for method_name in submodule.__all__:
-            for prefix in prefixes:
-                if method_name.startswith(prefix):
-                    method = getattr(submodule, method_name)
-                    setattr(clazz, method_name, method)
-                    break
Index: twisted/web2/dav/fileop.py
===================================================================
--- twisted/web2/dav/fileop.py	(revision 22823)
+++ twisted/web2/dav/fileop.py	(working copy)
@@ -1,513 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV file operations
-
-This API is considered private to static.py and is therefore subject to
-change.
-"""
-
-__all__ = [
-    "delete",
-    "copy",
-    "move",
-    "put",
-    "mkcollection",
-]
-
-import os
-import urllib
-from urlparse import urlsplit
-
-from twisted.python import log
-from twisted.python.filepath import FilePath
-from twisted.python.failure import Failure
-from twisted.internet.defer import succeed, deferredGenerator, waitForDeferred
-from twisted.web2 import responsecode
-from twisted.web2.http import StatusResponse, HTTPError
-from twisted.web2.stream import FileStream, readIntoFile
-from twisted.web2.dav.http import ResponseQueue, statusForFailure
-
-def delete(uri, filepath, depth="infinity"):
-    """
-    Perform a X{DELETE} operation on the given URI, which is backed by the given
-    filepath.
-    @param filepath: the L{FilePath} to delete.
-    @param depth: the recursion X{Depth} for the X{DELETE} operation, which must
-        be "infinity".
-    @raise HTTPError: (containing a response with a status code of
-        L{responsecode.BAD_REQUEST}) if C{depth} is not "infinity".
-    @raise HTTPError: (containing an appropriate response) if the
-        delete operation fails.  If C{filepath} is a directory, the response
-        will be a L{MultiStatusResponse}.
-    @return: a deferred response with a status code of L{responsecode.NO_CONTENT}
-        if the X{DELETE} operation succeeds.
-    """
-    #
-    # Remove the file(s)
-    #
-    # FIXME: defer
-    if filepath.isdir():
-        #
-        # RFC 2518, section 8.6 says that we must act as if the Depth header is
-        # set to infinity, and that the client must omit the Depth header or set
-        # it to infinity, meaning that for collections, we will delete all
-        # members.
-        #
-        # This seems somewhat at odds with the notion that a bad request should
-        # be rejected outright; if the client sends a bad depth header, the
-        # client is broken, and RFC 2518, section 8 suggests that a bad request
-        # should be rejected...
-        #
-        # Let's play it safe for now and ignore broken clients.
-        #
-
-        if depth != "infinity":
-            msg = ("Client sent illegal depth header value for DELETE: %s" % (depth,))
-            log.err(msg)
-            raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, msg))
-
-        #
-        # Recursive delete
-        #
-        # RFC 2518, section 8.6 says that if we get an error deleting a resource
-        # other than the collection in the request-URI, that we must respond
-        # with a multi-status response containing error statuses for each
-        # resource that we fail to delete.  It also says we should not return
-        # no-content (success) status, which means that we should continue after
-        # errors, rather than aborting right away.  This is interesting in that
-        # it's different from how most operating system tools act (eg. rm) when
-        # recursive filsystem deletes fail.
-        #
-
-        uri_path = urllib.unquote(urlsplit(uri)[2])
-        if uri_path[-1] == "/":
-            uri_path = uri_path[:-1]
-
-        log.msg("Deleting directory %s" % (filepath.path,))
-
-        # NOTE: len(uri_path) is wrong if os.sep is not one byte long... meh.
-        request_basename = filepath.path[:-len(uri_path)]
-        request_basename_len = len(request_basename)
-
-        errors = ResponseQueue(request_basename, "DELETE", responsecode.NO_CONTENT)
-
-        # FIXME: defer this
-        for dir, subdirs, files in os.walk(filepath.path, topdown=False):
-            for filename in files:
-                path = os.path.join(dir, filename)
-                try:
-                    os.remove(path)
-                except:
-                    errors.add(path, Failure())
-
-            for subdir in subdirs:
-                path = os.path.join(dir, subdir)
-                if os.path.islink(path):
-                    try:
-                        os.remove(path)
-                    except:
-                        errors.add(path, Failure())
-                else:
-                    try:
-                        os.rmdir(path)
-                    except:
-                        errors.add(path, Failure())
-
-        try:
-            os.rmdir(filepath.path)
-        except:
-            raise HTTPError(statusForFailure(
-                Failure(),
-                "deleting directory: %s" % (filepath.path,)
-            ))
-
-        response = errors.response()
-
-    else:
-        #
-        # Delete a file; much simpler, eh?
-        #
-        log.msg("Deleting file %s" % (filepath.path,))
-        try:
-            os.remove(filepath.path)
-        except:
-            raise HTTPError(statusForFailure(
-                Failure(),
-                "deleting file: %s" % (filepath.path,)
-            ))
-
-        response = responsecode.NO_CONTENT
-
-    # Restat filepath since we deleted the backing file
-    filepath.restat(False)
-
-    return succeed(response)
-
-def copy(source_filepath, destination_filepath, destination_uri, depth):
-    """
-    Perform a X{COPY} from the given source and destination filepaths.
-    This will perform a X{DELETE} on the destination if necessary; the caller
-    should check and handle the X{overwrite} header before calling L{copy} (as
-    in L{COPYMOVE.prepareForCopy}).
-    @param source_filepath: a L{FilePath} for the file to copy from.
-    @param destination_filepath: a L{FilePath} for the file to copy to.
-    @param destination_uri: the URI of the destination resource.
-    @param depth: the recursion X{Depth} for the X{COPY} operation, which must
-        be one of "0", "1", or "infinity".
-    @raise HTTPError: (containing a response with a status code of
-        L{responsecode.BAD_REQUEST}) if C{depth} is not "0", "1" or "infinity".
-    @raise HTTPError: (containing an appropriate response) if the operation
-        fails.  If C{source_filepath} is a directory, the response will be a
-        L{MultiStatusResponse}.
-    @return: a deferred response with a status code of L{responsecode.CREATED}
-        if the destination already exists, or L{responsecode.NO_CONTENT} if the
-        destination was created by the X{COPY} operation.
-    """
-    if source_filepath.isfile():
-        #
-        # Copy the file
-        #
-        log.msg("Copying file %s to %s" % (source_filepath.path, destination_filepath.path))
-
-        try:
-            source_file = source_filepath.open()
-        except:
-            raise HTTPError(statusForFailure(
-                Failure(),
-                "opening file for reading: %s" % (source_filepath.path,)
-            ))
-    
-        source_stream = FileStream(source_file)
-        response = waitForDeferred(put(source_stream, destination_filepath, destination_uri))
-        yield response
-        try:
-            response = response.getResult()
-        finally:
-            source_stream.close()
-            source_file.close()
-        checkResponse(response, "put", responsecode.NO_CONTENT, responsecode.CREATED)
-        yield response
-        return
-
-    elif source_filepath.isdir():
-        if destination_filepath.exists():
-            #
-            # Delete the destination
-            #
-            response = waitForDeferred(delete(destination_uri, destination_filepath))
-            yield response
-            response = response.getResult()
-            checkResponse(response, "delete", responsecode.NO_CONTENT)
-            success_code = responsecode.NO_CONTENT
-        else:
-            success_code = responsecode.CREATED
-
-        #
-        # Copy the directory
-        #
-        log.msg("Copying directory %s to %s" % (source_filepath.path, destination_filepath.path))
-
-        source_basename = source_filepath.path
-        destination_basename = destination_filepath.path
-
-        errors = ResponseQueue(source_basename, "COPY", success_code)
-
-        if destination_filepath.parent().isdir():
-            if os.path.islink(source_basename):
-                link_destination = os.readlink(source_basename)
-                if link_destination[0] != os.path.sep:
-                    link_destination = os.path.join(source_basename, link_destination)
-                try:
-                    os.symlink(destination_basename, link_destination)
-                except:
-                    errors.add(source_basename, Failure())
-            else:
-                try:
-                    os.mkdir(destination_basename)
-                except:
-                    raise HTTPError(statusForFailure(
-                        Failure(),
-                        "creating directory %s" % (destination_basename,)
-                    ))
-
-                if depth == "0": 
-                    yield success_code
-                    return
-        else:
-            raise HTTPError(StatusResponse(
-                responsecode.CONFLICT,
-                "Parent collection for destination %s does not exist" % (destination_uri,)
-            ))
-
-        #
-        # Recursive copy
-        #
-        # FIXME: When we report errors, do we report them on the source URI
-        # or on the destination URI?  We're using the source URI here.
-        #
-        # FIXME: defer the walk?
-
-        source_basename_len = len(source_basename)
-
-        def paths(basepath, subpath):
-            source_path = os.path.join(basepath, subpath)
-            assert source_path.startswith(source_basename)
-            destination_path = os.path.join(destination_basename, source_path[source_basename_len+1:])
-            return source_path, destination_path
-
-        for dir, subdirs, files in os.walk(source_filepath.path, topdown=True):
-            for filename in files:
-                source_path, destination_path = paths(dir, filename)
-                if not os.path.isdir(os.path.dirname(destination_path)):
-                    errors.add(source_path, responsecode.NOT_FOUND)
-                else:
-                    response = waitForDeferred(copy(FilePath(source_path), FilePath(destination_path), destination_uri, depth))
-                    yield response
-                    response = response.getResult()
-                    checkResponse(response, "copy", responsecode.NO_CONTENT)
-
-            for subdir in subdirs:
-                source_path, destination_path = paths(dir, subdir)
-                log.msg("Copying directory %s to %s" % (source_path, destination_path))
-
-                if not os.path.isdir(os.path.dirname(destination_path)):
-                    errors.add(source_path, responsecode.CONFLICT)
-                else:
-                    if os.path.islink(source_path):
-                        link_destination = os.readlink(source_path)
-                        if link_destination[0] != os.path.sep:
-                            link_destination = os.path.join(source_path, link_destination)
-                        try:
-                            os.symlink(destination_path, link_destination)
-                        except:
-                            errors.add(source_path, Failure())
-                    else:
-                        try:
-                            os.mkdir(destination_path)
-                        except:
-                            errors.add(source_path, Failure())
-
-        yield errors.response()
-        return
-    else:
-        log.err("Unable to COPY to non-file: %s" % (source_filepath.path,))
-        raise HTTPError(StatusResponse(
-            responsecode.FORBIDDEN,
-            "The requested resource exists but is not backed by a regular file."
-        ))
-
-copy = deferredGenerator(copy)
-
-def move(source_filepath, source_uri, destination_filepath, destination_uri, depth):
-    """
-    Perform a X{MOVE} from the given source and destination filepaths.
-    This will perform a X{DELETE} on the destination if necessary; the caller
-    should check and handle the X{overwrite} header before calling L{copy} (as
-    in L{COPYMOVE.prepareForCopy}).
-    Following the X{DELETE}, this will attempt an atomic filesystem move.  If
-    that fails, a X{COPY} operation followed by a X{DELETE} on the source will
-    be attempted instead.
-    @param source_filepath: a L{FilePath} for the file to copy from.
-    @param destination_filepath: a L{FilePath} for the file to copy to.
-    @param destination_uri: the URI of the destination resource.
-    @param depth: the recursion X{Depth} for the X{MOVE} operation, which must
-        be "infinity".
-    @raise HTTPError: (containing a response with a status code of
-        L{responsecode.BAD_REQUEST}) if C{depth} is not "infinity".
-    @raise HTTPError: (containing an appropriate response) if the operation
-        fails.  If C{source_filepath} is a directory, the response will be a
-        L{MultiStatusResponse}.
-    @return: a deferred response with a status code of L{responsecode.CREATED}
-        if the destination already exists, or L{responsecode.NO_CONTENT} if the
-        destination was created by the X{MOVE} operation.
-    """
-    log.msg("Moving %s to %s" % (source_filepath.path, destination_filepath.path))
-
-    #
-    # Choose a success status
-    #
-    if destination_filepath.exists():
-        #
-        # Delete the destination
-        #
-        response = waitForDeferred(delete(destination_uri, destination_filepath))
-        yield response
-        response = response.getResult()
-        checkResponse(response, "delete", responsecode.NO_CONTENT)
-
-        success_code = responsecode.NO_CONTENT
-    else:
-        success_code = responsecode.CREATED
-
-    #
-    # See if rename (which is atomic, and fast) works
-    #
-    try:
-        os.rename(source_filepath.path, destination_filepath.path)
-    except OSError:
-        pass
-    else:
-        # Restat source filepath since we moved it
-        source_filepath.restat(False)
-        yield success_code
-        return
-
-    #
-    # Do a copy, then delete the source
-    #
-
-    response = waitForDeferred(copy(source_filepath, destination_filepath, destination_uri, depth))
-    yield response
-    response = response.getResult()
-    checkResponse(response, "copy", responsecode.CREATED, responsecode.NO_CONTENT)
-
-    response = waitForDeferred(delete(source_uri, source_filepath))
-    yield response
-    response = response.getResult()
-    checkResponse(response, "delete", responsecode.NO_CONTENT)
-
-    yield success_code
-
-move = deferredGenerator(move)
-
-def put(stream, filepath, uri=None):
-    """
-    Perform a PUT of the given data stream into the given filepath.
-    @param stream: the stream to write to the destination.
-    @param filepath: the L{FilePath} of the destination file.
-    @param uri: the URI of the destination resource.
-        If the destination exists, if C{uri} is not C{None}, perform a
-        X{DELETE} operation on the destination, but if C{uri} is C{None},
-        delete the destination directly.
-        Note that whether a L{put} deletes the destination directly vs.
-        performing a X{DELETE} on the destination affects the response returned
-        in the event of an error during deletion.  Specifically, X{DELETE}
-        on collections must return a L{MultiStatusResponse} under certain
-        circumstances, whereas X{PUT} isn't required to do so.  Therefore,
-        if the caller expects X{DELETE} semantics, it must provide a valid
-        C{uri}.
-    @raise HTTPError: (containing an appropriate response) if the operation
-        fails.
-    @return: a deferred response with a status code of L{responsecode.CREATED}
-        if the destination already exists, or L{responsecode.NO_CONTENT} if the
-        destination was created by the X{PUT} operation.
-    """
-    log.msg("Writing to file %s" % (filepath.path,))
-
-    if filepath.exists():
-        if uri is None:
-            try:
-                if filepath.isdir():
-                    rmdir(filepath.path)
-                else:
-                    os.remove(filepath.path)
-            except:
-                raise HTTPError(statusForFailure(
-                    Failure(),
-                    "writing to file: %s" % (filepath.path,)
-                ))
-        else:
-            response = waitForDeferred(delete(uri, filepath))
-            yield response
-            response = response.getResult()
-            checkResponse(response, "delete", responsecode.NO_CONTENT)
-
-        success_code = responsecode.NO_CONTENT
-    else:
-        success_code = responsecode.CREATED
-
-    #
-    # Write the contents of the request stream to resource's file
-    #
-
-    try:
-        resource_file = filepath.open("w")
-    except:
-        raise HTTPError(statusForFailure(
-            Failure(),
-            "opening file for writing: %s" % (filepath.path,)
-        ))
-
-    try:
-        x = waitForDeferred(readIntoFile(stream, resource_file))
-        yield x
-        x.getResult()
-    except:
-        raise HTTPError(statusForFailure(
-            Failure(),
-            "writing to file: %s" % (filepath.path,)
-        ))
-
-    # Restat filepath since we modified the backing file
-    filepath.restat(False)
-    yield success_code
-
-put = deferredGenerator(put)
-
-def mkcollection(filepath):
-    """
-    Perform a X{MKCOL} on the given filepath.
-    @param filepath: the L{FilePath} of the collection resource to create.
-    @raise HTTPError: (containing an appropriate response) if the operation
-        fails.
-    @return: a deferred response with a status code of L{responsecode.CREATED}
-        if the destination already exists, or L{responsecode.NO_CONTENT} if the
-        destination was created by the X{MKCOL} operation.
-    """
-    try:
-        os.mkdir(filepath.path)
-        # Restat filepath because we modified it
-        filepath.restat(False)
-    except:
-        raise HTTPError(statusForFailure(
-            Failure(),
-            "creating directory in MKCOL: %s" % (filepath.path,)
-        ))
-
-    return succeed(responsecode.CREATED)
-
-def rmdir(dirname):
-    """
-    Removes the directory with the given name, as well as its contents.
-    @param dirname: the path to the directory to remove.
-    """
-    for dir, subdirs, files in os.walk(dirname, topdown=False):
-        for filename in files:
-            os.remove(os.path.join(dir, filename))
-        for subdir in subdirs:
-            path = os.path.join(dir, subdir)
-            if os.path.islink(path):
-                os.remove(path)
-            else:
-                os.rmdir(path)
-
-    os.rmdir(dirname)
-
-def checkResponse(response, method, *codes):
-    assert (
-        response in codes,
-        "%s() should have raised, but returned one of %r instead" % (method, codes)
-    )
Index: twisted/web2/dav/__init__.py
===================================================================
--- twisted/web2/dav/__init__.py	(revision 22823)
+++ twisted/web2/dav/__init__.py	(working copy)
@@ -1,50 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV support for Twisted Web2.
-
-See RFC 2616: http://www.ietf.org/rfc/rfc2616.txt (HTTP)
-See RFC 2518: http://www.ietf.org/rfc/rfc2518.txt (WebDAV)
-See RFC 3253: http://www.ietf.org/rfc/rfc3253.txt (WebDAV Versioning Extentions)
-See RFC 3744: http://www.ietf.org/rfc/rfc3744.txt (WebDAV Access Control Protocol)
-
-See also: http://skrb.org/ietf/http_errata.html (Errata to RFC 2616)
-"""
-
-__version__ = 'SVN-Trunk'
-version = __version__
-
-__all__ = [ 
-    "acl",
-    "fileop",
-    "davxml",
-    "http",
-    "idav",
-    "noneprops",
-    "resource",
-    "static",
-    "util",
-    "xattrprops",
-]
Index: twisted/web2/dav/acl.py
===================================================================
--- twisted/web2/dav/acl.py	(revision 22823)
+++ twisted/web2/dav/acl.py	(working copy)
@@ -1,133 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV ACL resources.
-"""
-
-__all__ = ["DAVPrincipalResource"]
-
-from zope.interface import implements
-from twisted.internet.defer import maybeDeferred
-from twisted.web2.dav import davxml
-from twisted.web2.dav.davxml import dav_namespace
-from twisted.web2.dav.idav import IDAVPrincipalResource
-from twisted.web2.dav.resource import DAVLeafResource
-from twisted.web2.dav.util import unimplemented
-
-class DAVPrincipalResource (DAVLeafResource):
-    """
-    Resource representing a WebDAV principal.  (RFC 3744, section 2)
-    """
-    implements(IDAVPrincipalResource)
-
-    ##
-    # WebDAV
-    ##
-
-    liveProperties = DAVLeafResource.liveProperties + (
-        (dav_namespace, "alternate-uri-set"),
-        (dav_namespace, "principal-url"    ),
-        (dav_namespace, "group-member-set" ),
-        (dav_namespace, "group-membership" ),
-    )
-
-    def davComplianceClasses(self):
-        return ("1",)
-
-    def isCollection(self):
-        return False
-
-    def findChildren(self, depth):
-        return ()
-
-    def readProperty(self, property, request):
-        def defer():
-            if type(property) is tuple:
-                qname = property
-                sname = "{%s}%s" % property
-            else:
-                qname = property.qname()
-                sname = property.sname()
-
-            namespace, name = qname
-
-            if namespace == dav_namespace:
-                if name == "alternate-uri-set":
-                    return davxml.AlternateURISet(*[davxml.HRef(u) for u in self.alternateURIs()])
-
-                if name == "principal-url":
-                    return davxml.PrincipalURL(davxml.HRef(self.principalURL()))
-
-                if name == "group-member-set":
-                    return davxml.GroupMemberSet(*[davxml.HRef(p) for p in self.groupMembers()])
-
-                if name == "group-membership":
-                    return davxml.GroupMemberSet(*[davxml.HRef(g) for g in self.groupMemberships()])
-
-            return super(DAVPrincipalResource, self).readProperty(qname, request)
-
-        return maybeDeferred(defer)
-
-    ##
-    # ACL
-    ##
-
-    def alternateURIs(self):
-        """
-        See L{IDAVPrincipalResource.alternateURIs}.
-
-        This implementation returns C{()}.  Subclasses should override this
-        method to provide alternate URIs for this resource if appropriate.
-        """
-        return ()
-
-    def principalURL(self):
-        """
-        See L{IDAVPrincipalResource.principalURL}.
-
-        This implementation raises L{NotImplementedError}.  Subclasses must
-        override this method to provide the principal URL for this resource.
-        """
-        unimplemented(self)
-
-    def groupMembers(self):
-        """
-        See L{IDAVPrincipalResource.groupMembers}.
-
-        This implementation returns C{()}, which is appropriate for non-group
-        principals.  Subclasses should override this method to provide member
-        URLs for this resource if appropriate.
-        """
-        return ()
-
-    def groupMemberships(self):
-        """
-        See L{IDAVPrincipalResource.groupMemberships}.
-
-        This implementation raises L{NotImplementedError}.  Subclasses must
-        override this method to provide the group URLs for this resource.
-        """
-        unimplemented(self)
-  
Index: twisted/web2/dav/http.py
===================================================================
--- twisted/web2/dav/http.py	(revision 22823)
+++ twisted/web2/dav/http.py	(working copy)
@@ -1,300 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-HTTP Utilities
-"""
-
-__all__ = [
-    "ErrorResponse",
-    "MultiStatusResponse",
-    "ResponseQueue",
-    "PropertyStatusResponseQueue",
-    "statusForFailure",
-]
-
-import errno
-
-from twisted.python import log
-from twisted.python.failure import Failure
-from twisted.web2 import responsecode
-from twisted.web2.iweb import IResponse
-from twisted.web2.http import Response, HTTPError, StatusResponse
-from twisted.web2.http_headers import MimeType
-from twisted.web2.dav import davxml
-
-##
-# Generating and tweaking responses
-##
-
-class ErrorResponse (Response):
-    """
-    A L{Response} object which contains a status code and a L{davxml.Error}
-    element.
-    Renders itself as a DAV:error XML document.
-    """
-    error = None
-
-    def __init__(self, code, error):
-        """
-        @param code: a response code.
-        @param error: an L{davxml.WebDAVElement} identifying the error, or a
-            tuple C{(namespace, name)} with which to create an empty element
-            denoting the error.  (The latter is useful in the case of
-            preconditions ans postconditions, not all of which have defined
-            XML element classes.)
-        """
-        if type(error) is tuple:
-            xml_namespace, xml_name = error
-            class EmptyError (davxml.WebDAVEmptyElement):
-                namespace = xml_namespace
-                name      = xml_name
-            error = EmptyError()
-
-        output = davxml.Error(error).toxml()
-
-        Response.__init__(self, code=code, stream=output)
-
-        self.headers.setHeader("content-type", MimeType("text", "xml"))
-
-        self.error = error
-
-    def __repr__(self):
-        return "<%s %s %s>" % (self.__class__.__name__, self.code, self.error.sname())
-
-class MultiStatusResponse (Response):
-    """
-    Multi-status L{Response} object.
-    Renders itself as a DAV:multi-status XML document.
-    """
-    def __init__(self, xml_responses):
-        """
-        @param xml_responses: an interable of davxml.Response objects.
-        """
-        multistatus = davxml.MultiStatus(*xml_responses)
-        output = multistatus.toxml()
-
-        Response.__init__(self, code=responsecode.MULTI_STATUS,
-                          stream=davxml.MultiStatus(*xml_responses).toxml())
-
-        self.headers.setHeader("content-type", MimeType("text", "xml"))
-
-class ResponseQueue (object):
-    """
-    Stores a list of (typically error) responses for use in a
-    L{MultiStatusResponse}.
-    """
-    def __init__(self, path_basename, method, success_response):
-        """
-        @param path_basename: the base path for all responses to be added to the 
-            queue.
-            All paths for responses added to the queue must start with
-            C{path_basename}, which will be stripped from the beginning of each
-            path to determine the response's URI.
-        @param method: the name of the method generating the queue.
-        @param success_response: the response to return in lieu of a
-            L{MultiStatusResponse} if no responses are added to this queue.
-        """
-        self.responses         = []
-        self.path_basename     = path_basename
-        self.path_basename_len = len(path_basename)
-        self.method            = method
-        self.success_response  = success_response
-
-    def add(self, path, what):
-        """
-        Add a response.
-        @param path: a path, which must be a subpath of C{path_basename} as
-            provided to L{__init__}.
-        @param what: a status code or a L{Failure} for the given path.
-        """
-        assert path.startswith(self.path_basename), "%s does not start with %s" % (path, self.path_basename)
-
-        if type(what) is int:
-            code    = what
-            error   = None
-            message = responsecode.RESPONSES[code]
-        elif isinstance(what, Failure):
-            code    = statusForFailure(what)
-            error   = errorForFailure(what)
-            message = messageForFailure(what)
-        else:
-            raise AssertionError("Unknown data type: %r" % (what,))
-
-        if code > 400: # Error codes only
-            log.err("Error during %s for %s: %s" % (self.method, path, message))
-
-        uri = path[self.path_basename_len:]
-
-        children = []
-        children.append(davxml.HRef(uri))
-        children.append(davxml.Status.fromResponseCode(code))
-        if error is not None:
-            children.append(error)
-        if message is not None:
-            children.append(davxml.ResponseDescription(message))
-        self.responses.append(davxml.StatusResponse(*children))
-
-    def response(self):
-        """
-        Generate a L{MultiStatusResponse} with the responses contained in the
-        queue or, if no such responses, return the C{success_response} provided
-        to L{__init__}.
-        @return: the response.
-        """
-        if self.responses:
-            return MultiStatusResponse(self.responses)
-        else:
-            return self.success_response
-
-class PropertyStatusResponseQueue (object):
-    """
-    Stores a list of propstat elements for use in a L{Response}
-    in a L{MultiStatusResponse}.
-    """
-    def __init__(self, method, uri, success_response):
-        """
-        @param method:           the name of the method generating the queue.
-        @param uri:              the href for the response.
-        @param success_response: the status to return if no
-            L{PropertyStatus} are added to this queue.
-        """
-        self.method            = method
-        self.propstats         = [davxml.HRef(uri)]
-        self.success_response  = success_response
-
-    def add(self, what, property):
-        """
-        Add a response.
-        @param what: a status code or a L{Failure} for the given path.
-        @param property: the property whose status is being reported.
-        """
-        if type(what) is int:
-            code    = what
-            error   = None
-            message = responsecode.RESPONSES[code]
-        elif isinstance(what, Failure):
-            code    = statusForFailure(what)
-            error   = errorForFailure(what)
-            message = messageForFailure(what)
-        else:
-            raise AssertionError("Unknown data type: %r" % (what,))
-
-        if len(property.children) > 0:
-            # Re-instantiate as empty element.
-            property = property.__class__()
-
-        if code > 400: # Error codes only
-            log.err("Error during %s for %s: %s" % (self.method, property, message))
-
-        children = []
-        children.append(davxml.PropertyContainer(property))
-        children.append(davxml.Status.fromResponseCode(code))
-        if error is not None:
-            children.append(error)
-        if message is not None:
-            children.append(davxml.ResponseDescription(message))
-        self.propstats.append(davxml.PropertyStatus(*children))
-
-    def error(self):
-        """
-        Convert any 2xx codes in the propstat responses to 424 Failed Dependency.
-        """
-        for propstat in self.propstats:
-            # Check the status
-            changed_status = False
-            for index, child in enumerate(propstat.children):
-                if isinstance(child, davxml.Status) and (child.code / 100 == 2):
-                    # Change the code
-                    propstat.children[index] = davxml.Status.fromResponseCode(
-                        responsecode.FAILED_DEPENDENCY
-                    )
-                    changed_status = True
-                elif changed_status and isinstance(child, davxml.ResponseDescription):
-                    propstat.children[index] = davxml.ResponseDescription(
-                        responsecode.RESPONSES[responsecode.FAILED_DEPENDENCY]
-                    )
-
-    def response(self):
-        """
-        Generate a response from the responses contained in the queue or, if
-        there are no such responses, return the C{success_response} provided to
-        L{__init__}.
-        @return: a L{davxml.PropertyStatusResponse}.
-        """
-        if len(self.propstats) == 1:
-            self.propstats.append(davxml.Status.fromResponseCode(self.success_response))
-        return davxml.PropertyStatusResponse(*self.propstats)
-
-##
-# Exceptions and response codes
-##
-
-def statusForFailure(failure, what=None):
-    """
-    @param failure: a L{Failure}.
-    @param what: a decription of what was going on when the failure occurred.
-        If what is not C{None}, emit a cooresponding message via L{log.err}.
-    @return: a response code cooresponding to the given C{failure}.
-    """
-    def msg(err):
-        if what is not None:
-            log.msg("%s while %s" % (err, what))
-
-    if failure.check(IOError, OSError):
-        e = failure.value[0]
-        if e == errno.EACCES or e == errno.EPERM:
-            msg("Permission denied")
-            return responsecode.FORBIDDEN
-        elif e == errno.ENOSPC:
-            msg("Out of storage space")
-            return responsecode.INSUFFICIENT_STORAGE_SPACE
-        elif e == errno.ENOENT:
-            msg("Not found")
-            return responsecode.NOT_FOUND
-        else:
-            failure.raiseException()
-    elif failure.check(NotImplementedError):
-        msg("Unimplemented error")
-        return responsecode.NOT_IMPLEMENTED
-    elif failure.check(HTTPError):
-        code = IResponse(failure.value.response).code
-        msg("%d response" % (code,))
-        return code
-    else:
-        failure.raiseException()
-
-def errorForFailure(failure):
-    if failure.check(HTTPError) and isinstance(failure.value.response, ErrorResponse):
-        return davxml.Error(failure.value.response.error)
-    else:
-        return None
-
-def messageForFailure(failure):
-    if failure.check(HTTPError):
-        if isinstance(failure.value.response, ErrorResponse):
-            return None
-        if isinstance(failure.value.response, StatusResponse):
-            return failure.value.response.description
-    return str(failure)
Index: twisted/web2/dav/element/base.py
===================================================================
--- twisted/web2/dav/element/base.py	(revision 22823)
+++ twisted/web2/dav/element/base.py	(working copy)
@@ -1,581 +0,0 @@
-##
-# Copyright (c) 2007 Twisted Matrix Laboratories.
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV XML base classes.
-
-This module provides XML utilities for use with WebDAV.
-
-See RFC 2518: http://www.ietf.org/rfc/rfc2518.txt (WebDAV)
-"""
-
-__all__ = [
-    "dav_namespace",
-    "WebDAVElement",
-    "PCDATAElement",
-    "WebDAVOneShotElement",
-    "WebDAVUnknownElement",
-    "WebDAVEmptyElement",
-    "WebDAVTextElement",
-    "WebDAVDateTimeElement",
-    "DateTimeHeaderElement",
-]
-
-import string
-import StringIO
-import xml.dom.minidom
-
-import datetime
-
-from twisted.python import log
-from twisted.web2.http_headers import parseDateTime
-from twisted.web2.dav.element.util import PrintXML, decodeXMLName
-
-##
-# Base XML elements
-##
-
-dav_namespace = "DAV:"
-
-class WebDAVElement (object):
-    """
-    WebDAV XML element. (RFC 2518, section 12)
-    """
-    namespace          = dav_namespace # Element namespace (class variable)
-    name               = None          # Element name (class variable)
-    allowed_children   = None          # Types & count limits on child elements
-    allowed_attributes = None          # Allowed attribute names
-    hidden             = False         # Don't list in PROPFIND with <allprop>
-    protected          = False         # See RFC 3253 section 1.4.1
-    unregistered       = False         # Subclass of factory; doesn't register
-
-    def qname(self):
-        return (self.namespace, self.name)
-
-    def sname(self):
-        return "{%s}%s" % (self.namespace, self.name)
-
-    qname = classmethod(qname)
-    sname = classmethod(sname)
-
-    def __init__(self, *children, **attributes):
-        super(WebDAVElement, self).__init__()
-
-        if self.allowed_children is None:
-            raise NotImplementedError("WebDAVElement subclass %s is not implemented."
-                                      % (self.__class__.__name__,))
-
-        #
-        # Validate that children are of acceptable types
-        #
-        allowed_children = dict([
-            (child_type, list(limits))
-            for child_type, limits
-            in self.allowed_children.items()
-        ])
-
-        my_children = []
-
-        for child in children:
-            if child is None:
-                continue
-
-            if isinstance(child, (str, unicode)):
-                child = PCDATAElement(child)
-
-            assert isinstance(child, (WebDAVElement, PCDATAElement)), "Not an element: %r" % (child,)
-
-            for allowed, (min, max) in allowed_children.items():
-                if type(allowed) == type and isinstance(child, allowed):
-                    qname = allowed
-                elif child.qname() == allowed:
-                    qname = allowed
-                else:
-                    continue
-
-                if min is not None and min > 0:
-                    min -= 1
-                if max is not None:
-                    assert max > 0, "Too many children of type %s for %s" % (child.sname(), self.sname())
-                    max -= 1
-                allowed_children[qname] = (min, max)
-                my_children.append(child)
-                break
-            else:
-                if not (isinstance(child, PCDATAElement) and child.isWhitespace()):
-                    log.msg("Child of type %s is unexpected and therefore ignored in %s element"
-                            % (child.sname(), self.sname()))
-
-        for qname, (min, max) in allowed_children.items():
-            if min != 0:
-                raise ValueError("Not enough children of type {%s}%s for %s"
-                                 % (qname[0], qname[1], self.sname()))
-
-        self.children = tuple(my_children)
-
-        #
-        # Validate that attributes have known names
-        #
-        my_attributes = {}
-
-        if self.allowed_attributes:
-            for name in attributes:
-                if name in self.allowed_attributes:
-                    my_attributes[name] = attributes[name]
-                else:
-                    log.msg("Attribute %s is unexpected and therefore ignored in %s element"
-                            % (name, self.sname()))
-
-            for name, required in self.allowed_attributes.items():
-                if required and name not in my_attributes:
-                    raise ValueError("Attribute %s is required in %s element"
-                                     % (name, self.sname()))
-
-        elif not isinstance(self, WebDAVUnknownElement):
-            if attributes:
-                log.msg("Attributes %s are unexpected and therefore ignored in %s element"
-                        % (attributes.keys(), self.sname()))
-
-        self.attributes = my_attributes
-
-    def __str__(self):
-        return self.sname()
-
-    def __repr__(self):
-        if hasattr(self, "attributes") and hasattr(self, "children"):
-            return "<%s %r: %r>" % (self.sname(), self.attributes, self.children)
-        else:
-            return "<%s>" % (self.sname())
-
-    def __eq__(self, other):
-        if isinstance(other, WebDAVElement):
-            return (
-                self.name       == other.name       and
-                self.namespace  == other.namespace  and
-                self.attributes == other.attributes and
-                self.children   == other.children
-            )
-        else:
-            return NotImplemented
-
-    def __ne__(self, other):
-        return not self.__eq__(other)
-
-    def __contains__(self, child):
-        return child in self.children
-
-    def writeXML(self, output):
-        document = xml.dom.minidom.Document()
-        self.addToDOM(document, None)
-        PrintXML(document, stream=output)
-
-    def toxml(self):
-        output = StringIO.StringIO()
-        self.writeXML(output)
-        return output.getvalue()
-
-    def element(self, document):
-        element = document.createElementNS(self.namespace, self.name)
-        if hasattr(self, "attributes"):
-            for name, value in self.attributes.items():
-                namespace, name = decodeXMLName(name)
-                attribute = document.createAttributeNS(namespace, name)
-                attribute.nodeValue = value
-                element.setAttributeNodeNS(attribute)
-        return element
-
-    def addToDOM(self, document, parent):
-        element = self.element(document)
-
-        if parent is None:
-            document.appendChild(element)
-        else:
-            parent.appendChild(element)
-
-        for child in self.children:
-            if child:
-                try:
-                    child.addToDOM(document, element)
-                except:
-                    log.err("Unable to add child %r of element %s to DOM" % (child, self))
-                    raise
-
-    def childrenOfType(self, child_type):
-        """
-        Returns a list of children with the same qname as the given type.
-        """
-        if type(child_type) is tuple:
-            qname = child_type
-        else:
-            qname = child_type.qname()
-
-        return [ c for c in self.children if c.qname() == qname ]
-
-    def childOfType(self, child_type):
-        """
-        Returns a child of the given type, if any, or None.
-        Raises ValueError if more than one is found.
-        """
-        found = None
-        for child in self.childrenOfType(child_type):
-            if found:
-                raise ValueError("Multiple %s elements found in %s" % (child_type.sname(), self.toxml()))
-            found = child
-        return found
-
-class PCDATAElement (object):
-    def sname(self): return "#PCDATA"
-
-    qname = classmethod(sname)
-    sname = classmethod(sname)
-
-    def __init__(self, data):
-        super(PCDATAElement, self).__init__()
-
-        if data is None:
-            data = ""
-        elif type(data) is unicode:
-            data = data.encode("utf-8")
-        else:
-            assert type(data) is str, ("PCDATA must be a string: %r" % (data,))
-
-        self.data = data
-
-    def __str__(self):
-        return str(self.data)
-
-    def __repr__(self):
-        return "<%s: %r>" % (self.__class__.__name__, self.data)
-
-    def __add__(self, other):
-        if isinstance(other, PCDATAElement):
-            return self.__class__(self.data + other.data)
-        else:
-            return self.__class__(self.data + other)
-
-    def __eq__(self, other):
-        if isinstance(other, PCDATAElement):
-            return self.data == other.data
-        elif type(other) in (str, unicode):
-            return self.data == other
-        else:
-            return NotImplemented
-
-    def __ne__(self, other):
-        return not self.__eq__(other)
-
-    def isWhitespace(self):
-        for char in str(self):
-            if char not in string.whitespace:
-                return False
-        return True
-
-    def element(self, document):
-        return document.createTextNode(self.data)
-
-    def addToDOM(self, document, parent):
-        try:
-            parent.appendChild(self.element(document))
-        except TypeError:
-            log.err("Invalid PCDATA: %r" % (self.data,))
-            raise
-
-class WebDAVOneShotElement (WebDAVElement):
-    """
-    Element with exactly one WebDAVEmptyElement child and no attributes.
-    """
-    __singletons = {}
-
-    def __new__(clazz, *children):
-        child = None
-        for next in children:
-            if isinstance(next, WebDAVEmptyElement):
-                if child is not None:
-                    raise ValueError("%s must have exactly one child, not %r"
-                                     % (clazz.__name__, children))
-                child = next
-            elif isinstance(next, PCDATAElement):
-                pass
-            else:
-                raise ValueError("%s child is not a WebDAVEmptyElement instance: %s"
-                                 % (clazz.__name__, next))
-
-        if clazz not in WebDAVOneShotElement.__singletons:
-            WebDAVOneShotElement.__singletons[clazz] = {
-                child: WebDAVElement.__new__(clazz)
-            }
-        elif child not in WebDAVOneShotElement.__singletons[clazz]:
-            WebDAVOneShotElement.__singletons[clazz][child] = (
-                WebDAVElement.__new__(clazz)
-            )
-
-        return WebDAVOneShotElement.__singletons[clazz][child]
-
-class WebDAVUnknownElement (WebDAVElement):
-    """
-    Placeholder for unknown element tag names.
-    """
-    allowed_children = {
-        WebDAVElement: (0, None),
-        PCDATAElement: (0, None),
-    }
-
-class WebDAVEmptyElement (WebDAVElement):
-    """
-    WebDAV element with no contents.
-    """
-    __singletons = {}
-
-    def __new__(clazz, *args, **kwargs):
-        assert not args
-
-        if kwargs:
-            return WebDAVElement.__new__(clazz)
-        else:
-            if clazz not in WebDAVEmptyElement.__singletons:
-                WebDAVEmptyElement.__singletons[clazz] = (WebDAVElement.__new__(clazz))
-            return WebDAVEmptyElement.__singletons[clazz]
-
-    allowed_children = {}
-
-    children = ()
-
-
-    def __hash__(self):
-        """
-        Define a hash method, so that an empty element can serve as dictionary
-        keys. It's mainly useful to define singletons with
-        L{WebDAVOneShotElement}.
-        """
-        return hash((self.name, self.namespace))
-
-
-
-class WebDAVTextElement (WebDAVElement):
-    """
-    WebDAV element containing PCDATA.
-    """
-    def fromString(clazz, string):
-        if string is None:
-            return clazz()
-        elif isinstance(string, (str, unicode)):
-            return clazz(PCDATAElement(string))
-        else:
-            return clazz(PCDATAElement(str(string)))
-
-    fromString = classmethod(fromString)
-
-    allowed_children = { PCDATAElement: (0, None) }
-
-    def __str__(self):
-        return "".join([c.data for c in self.children])
-
-    def __repr__(self):
-        content = str(self)
-        if content:
-            return "<%s: %r>" % (self.sname(), content)
-        else:
-            return "<%s>" % (self.sname(),)
-
-    def __eq__(self, other):
-        if isinstance(other, WebDAVTextElement):
-            return str(self) == str(other)
-        elif type(other) in (str, unicode):
-            return str(self) == other
-        else:
-            return NotImplemented
-
-class WebDAVDateTimeElement (WebDAVTextElement):
-    """
-    WebDAV date-time element. (RFC 2518, section 23.2)
-    """
-    def fromDate(clazz, date):
-        """
-        date may be a datetime.datetime instance, a POSIX timestamp
-        (integer value, such as returned by time.time()), or an ISO
-        8601-formatted (eg. "2005-06-13T16:14:11Z") date/time string.
-        """
-        def isoformat(date):
-            if date.utcoffset() is None:
-                return date.isoformat() + "Z"
-            else:
-                return date.isoformat()
-
-        if type(date) is int:
-            date = isoformat(datetime.datetime.fromtimestamp(date))
-        elif type(date) is str:
-            pass
-        elif type(date) is unicode:
-            date = date.encode("utf-8")
-        elif isinstance(date, datetime.datetime):
-            date = isoformat(date)
-        else:
-            raise ValueError("Unknown date type: %r" % (date,))
-
-        return clazz(PCDATAElement(date))
-
-    fromDate = classmethod(fromDate)
-
-    def __init__(self, *children, **attributes):
-        super(WebDAVDateTimeElement, self).__init__(*children, **attributes)
-        self.datetime() # Raise ValueError if the format is wrong
-
-    def __eq__(self, other):
-        if isinstance(other, WebDAVDateTimeElement):
-            return self.datetime() == other.datetime()
-        else:
-            return NotImplemented
-
-    def datetime(self):
-        s = str(self)
-        if not s:
-            return None
-        else:
-            return parse_date(s)
-
-class DateTimeHeaderElement (WebDAVTextElement):
-    """
-    WebDAV date-time element for elements that substitute for HTTP
-    headers. (RFC 2068, section 3.3.1)
-    """
-    def fromDate(clazz, date):
-        """
-        date may be a datetime.datetime instance, a POSIX timestamp
-        (integer value, such as returned by time.time()), or an RFC
-        2068 Full Date (eg. "Mon, 23 May 2005 04:52:22 GMT") string.
-        """
-        def format(date):
-            #
-            # FIXME: strftime() is subject to localization nonsense; we need to
-            # ensure that we're using the correct localization, or don't use
-            # strftime().
-            #
-            return date.strftime("%a, %d %b %Y %H:%M:%S GMT")
-
-        if type(date) is int:
-            date = format(datetime.datetime.fromtimestamp(date))
-        elif type(date) is str:
-            pass
-        elif type(date) is unicode:
-            date = date.encode("utf-8")
-        elif isinstance(date, datetime.datetime):
-            if date.tzinfo:
-                raise NotImplementedError("I need to normalize to UTC")
-            date = format(date)
-        else:
-            raise ValueError("Unknown date type: %r" % (date,))
-
-        return clazz(PCDATAElement(date))
-
-    fromDate = classmethod(fromDate)
-
-    def __init__(self, *children, **attributes):
-        super(DateTimeHeaderElement, self).__init__(*children, **attributes)
-        self.datetime() # Raise ValueError if the format is wrong
-
-    def __eq__(self, other):
-        if isinstance(other, WebDAVDateTimeElement):
-            return self.datetime() == other.datetime()
-        else:
-            return NotImplemented
-
-    def datetime(self):
-        s = str(self)
-        if not s:
-            return None
-        else:
-            return parseDateTime(s)
-
-##
-# Utilities
-##
-
-class FixedOffset (datetime.tzinfo):
-    """
-    Fixed offset in minutes east from UTC.
-    """
-    def __init__(self, offset, name=None):
-        super(FixedOffset, self).__init__()
-
-        self._offset = datetime.timedelta(minutes=offset)
-        self._name   = name
-
-    def utcoffset(self, dt): return self._offset
-    def tzname   (self, dt): return self._name
-    def dst      (self, dt): return datetime.timedelta(0)
-
-def parse_date(date):
-    """
-    Parse an ISO 8601 date and return a corresponding datetime.datetime object.
-    """
-    # See http://www.iso.org/iso/en/prods-services/popstds/datesandtime.html
-
-    global regex_date
-
-    if regex_date is None:
-        import re
-
-        regex_date = re.compile(
-            "^" +
-              "(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})T" +
-              "(?P<hour>\d{2}):(?P<minute>\d{2}):(?P<second>\d{2})(?:.(?P<subsecond>\d+))*" +
-              "(?:Z|(?P<offset_sign>\+|-)(?P<offset_hour>\d{2}):(?P<offset_minute>\d{2}))" +
-            "$"
-        )
-
-    match = regex_date.match(date)
-    if match is not None:
-        subsecond = match.group("subsecond")
-        if subsecond is None:
-            subsecond = 0
-        else:
-            subsecond = int(subsecond)
-
-        offset_sign = match.group("offset_sign")
-        if offset_sign is None:
-            offset = FixedOffset(0)
-        else:
-            offset_hour   = int(match.group("offset_hour"  ))
-            offset_minute = int(match.group("offset_minute"))
-
-            delta = (offset_hour * 60) + offset_minute
-
-            if   offset_sign == "+": offset = FixedOffset(0 - delta)
-            elif offset_sign == "-": offset = FixedOffset(0 + delta)
-
-        return datetime.datetime(
-            int(match.group("year"  )),
-            int(match.group("month" )),
-            int(match.group("day"   )),
-            int(match.group("hour"  )),
-            int(match.group("minute")),
-            int(match.group("second")),
-            subsecond,
-            offset
-        )
-    else:
-        raise ValueError("Invalid ISO 8601 date format: %r" % (date,))
-
-regex_date = None
Index: twisted/web2/dav/element/rfc2518.py
===================================================================
--- twisted/web2/dav/element/rfc2518.py	(revision 22823)
+++ twisted/web2/dav/element/rfc2518.py	(working copy)
@@ -1,576 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-RFC 2518 (WebDAV) XML Elements
-
-This module provides XML element definitions for use with WebDAV.
-
-See RFC 2518: http://www.ietf.org/rfc/rfc2518.txt
-"""
-
-from twisted.web2 import responsecode
-from twisted.web2.dav.element.base import *
-from twisted.web2.http_headers import MimeType
-
-##
-# Section 12
-##
-
-class ActiveLock (WebDAVElement):
-    """
-    Describes a lock on a resource. (RFC 2518, section 12.1)
-    """
-    name = "activelock"
-
-    allowed_children = {
-        (dav_namespace, "lockscope"): (1, 1),
-        (dav_namespace, "locktype" ): (1, 1),
-        (dav_namespace, "depth"    ): (1, 1),
-        (dav_namespace, "owner"    ): (0, 1),
-        (dav_namespace, "timeout"  ): (0, 1),
-        (dav_namespace, "locktoken"): (0, 1),
-    }
-
-class Depth (WebDAVTextElement):
-    """
-    The value of the depth header. (RFC 2518, section 12.1.1)
-    """
-    name = "depth"
-
-    def __init__(self, *children, **attributes):
-        super(Depth, self).__init__(*children, **attributes)
-
-        depth = str(self)
-        if depth not in ("0", "1", "infinity"):
-            raise ValueError("Invalid depth: %s" % (depth,))
-
-class LockToken (WebDAVElement):
-    """
-    The lock token associated with a lock. (RFC 2518, section 12.1.2)
-    """
-    name = "locktoken"
-
-    allowed_children = { (dav_namespace, "href"): (1, None) }
-
-class Timeout (WebDAVTextElement):
-    """
-    The timeout associated with a lock. (RFC 2518, section 12.1.3)
-    """
-    name = "timeout"
-
-class Collection (WebDAVEmptyElement):
-    """
-    Identifies the associated resource as a collection. (RFC 2518, section 12.2)
-    """
-    name = "collection"
-
-class HRef (WebDAVTextElement):
-    """
-    Identifies the content of the element as a URI. (RFC 2518, section 12.3)
-    """
-    name = "href"
-
-class Link (WebDAVElement):
-    """
-    Identifies the property as a link and contains the source and
-    destination of that link. (RFC 2518, section 12.4)
-    """
-    name = "link"
-
-    allowed_children = {
-        (dav_namespace, "src"): (1, None),
-        (dav_namespace, "dst"): (1, None),
-    }
-
-class LinkDestination (WebDAVTextElement):
-    """
-    Indicates the destination of a link. (RFC 2518, section 12.4.1)
-    """
-    name = "dst"
-
-class LinkSource (WebDAVTextElement):
-    """
-    Indicates the source of a link. (RFC 2518, section 12.4.2)
-    """
-    name = "src"
-
-class LockEntry (WebDAVElement):
-    """
-    Defines the types of lock that can be used with the
-    resource. (RFC 2518, section 12.5)
-    """
-    name = "lockentry"
-
-    allowed_children = {
-        (dav_namespace, "lockscope"): (1, 1),
-        (dav_namespace, "locktype" ): (1, 1),
-    }
-
-class LockInfo (WebDAVElement):
-    """
-    Used with a LOCK method to specify the type of lock that the
-    client wishes to have created. (RFC 2518, section 12.6)
-    """
-    name = "lockinfo"
-
-    allowed_children = {
-        (dav_namespace, "lockscope"): (1, 1),
-        (dav_namespace, "locktype" ): (1, 1),
-        (dav_namespace, "owner"    ): (0, 1),
-    }
-
-class LockScope (WebDAVOneShotElement):
-    """
-    Specifies whether a lock is an exclusive lock or a shared
-    lock. (RFC 2518, section 12.7)
-    """
-    name = "lockscope"
-
-    allowed_children = {
-        (dav_namespace, "exclusive"): (0, 1),
-        (dav_namespace, "shared"   ): (0, 1),
-    }
-
-class Exclusive (WebDAVEmptyElement):
-    """
-    Indicates an exclusive lock. (RFC 2518, section 12.7.1)
-    """
-    name = "exclusive"
-
-LockScope.exclusive = LockScope(Exclusive())
-
-class Shared (WebDAVEmptyElement):
-    """
-    Indicates a shared lock. (RFC 2518, section 12.7.2)
-    """
-    name = "shared"
-
-LockScope.shared = LockScope(Shared())
-
-class LockType (WebDAVOneShotElement):
-    """
-    Specifies the access type of a lock. (RFC 2518, section 12.8)
-    """
-    name = "locktype"
-
-    allowed_children = { (dav_namespace, "write"): (0, 1) }
-
-class Write (WebDAVEmptyElement):
-    """
-    Indicates a write lock. (RFC 2518, section 12.8.1)
-    Controls methods that lock a resource or modify the content, dead
-    properties, or (in the case of a collection) membership of a resource.
-    (RFC 3744, section 3.2)
-    """
-    name = "write"
-
-LockType.write = LockType(Write())
-
-class MultiStatus (WebDAVElement):
-    """
-    Contains multiple Responses. (RFC 2518, section 12.9)
-    """
-    name = "multistatus"
-
-    allowed_children = {
-        (dav_namespace, "response"           ): (0, None),
-        (dav_namespace, "responsedescription"): (0, 1),
-    }
-
-class Response (WebDAVElement):
-    """
-    Holds a single response describing the effect of a method on a
-    resource and/or its properties. (RFC 2518, section 12.9.1)
-    """
-    name = "response"
-
-    allowed_children = {
-        (dav_namespace, "href"               ): (1, None),
-        (dav_namespace, "status"             ): (1, 1),
-        (dav_namespace, "propstat"           ): (1, None),
-        (dav_namespace, "error"              ): (0, 1),        # 2518bis
-        (dav_namespace, "responsedescription"): (0, 1),
-    }
-
-    def __new__(clazz, *children):
-        if clazz is not Response: return WebDAVElement.__new__(clazz)
-
-        resource_count = 0
-        status_count   = 0
-        propstat_count = 0
-
-        for child in children:
-            if   isinstance(child, HRef          ): resource_count += 1
-            elif isinstance(child, Status        ): status_count   += 1
-            elif isinstance(child, PropertyStatus): propstat_count += 1
-
-        if resource_count < 1:
-            raise ValueError("%s element must have at least one %s."
-                             % (clazz.sname(), HRef.sname()))
-
-        if status_count is 0:
-            if propstat_count is 0:
-                raise ValueError("%s element must have one of %s or %s"
-                                 % (clazz.sname(), Status.sname(), PropertyStatus.sname()))
-
-            if resource_count > 1:
-                raise ValueError("%s element with %s may only have one %s"
-                                 % (clazz.sname(), PropertyStatus.sname(), HRef.sname()))
-
-            return PropertyStatusResponse.__new__(PropertyStatusResponse, *children)
-
-        if status_count > 1:
-            raise ValueError("%s element may only have one %s" % (clazz.sname(), Status.sname()))
-
-        return StatusResponse.__new__(StatusResponse, *children)
-
-class StatusResponse (Response):
-    """
-    Specialized derivative of Response for resource status.
-    """
-    unregistered = True
-
-    allowed_children = {
-        (dav_namespace, "href"               ): (1, None),
-        (dav_namespace, "status"             ): (1, 1),
-        (dav_namespace, "error"              ): (0, 1),        # 2518bis
-        (dav_namespace, "responsedescription"): (0, 1),
-    }
-
-class PropertyStatusResponse (Response):
-    """
-    Specialized derivative of Response for property status.
-    """
-    unregistered = True
-
-    allowed_children = {
-        (dav_namespace, "href"               ): (1, 1),
-        (dav_namespace, "propstat"           ): (1, None),
-        (dav_namespace, "error"              ): (0, 1),        # 2518bis
-        (dav_namespace, "responsedescription"): (0, 1),
-    }
-
-class PropertyStatus (WebDAVElement):
-    """
-    Groups together a Property and Status element that is associated
-    with a particular DAV:href element. (RFC 2518, section 12.9.1.1)
-    """
-    name = "propstat"
-
-    allowed_children = {
-        (dav_namespace, "prop"               ): (1, 1),
-        (dav_namespace, "status"             ): (1, 1),
-        (dav_namespace, "error"              ): (0, 1),        # 2518bis
-        (dav_namespace, "responsedescription"): (0, 1),
-    }
-
-class Status (WebDAVTextElement):
-    """
-    Holds a single HTTP status line. (RFC 2518, section 12.9.1.2)
-    """
-    name = "status"
-
-    def fromResponseCode(clazz, code):
-        """
-        code must be an integer response code in
-        twisted.web2.responsecode.RESPONSES.keys()
-        """
-        if code not in responsecode.RESPONSES:
-            raise ValueError("Invalid response code: %r" % (code,))
-
-        return clazz(PCDATAElement("HTTP/1.1 %d %s" % (code, responsecode.RESPONSES[code])))
-
-    fromResponseCode = classmethod(fromResponseCode)
-
-    def __init__(self, *children, **attributes):
-        super(Status, self).__init__(*children, **attributes)
-
-        status = str(self)
-        if not status.startswith("HTTP/1.1 "):
-            raise ValueError("Invalid WebDAV status: %s" % (status,))
-
-        code = int(status[9:12])
-        if code not in responsecode.RESPONSES:
-            raise ValueError("Invalid status code: %s" % (code,))
-
-        self.code = code
-
-class ResponseDescription (WebDAVTextElement):
-    """
-    Contains a message that can be displayed to the user explaining the nature
-    of the response. (RFC 2518, section 12.9.2)
-    """
-    name = "responsedescription"
-
-class Owner (WebDAVElement):
-    """
-    Property which provides information about the principal taking out a lock.
-    (RFC 2518, section 12.10)
-    Property which identifies a principal as being the owner principal of a
-    resource. (RFC 3744, section 5.1)
-    Note that RFC 2518 allows any content, while RFC 3744 expect zero or one
-    DAV:href element.
-    """
-    name = "owner"
-    hidden = True
-    #protected = True # may be protected, per RFC 3744, section 5.2
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-class PropertyContainer (WebDAVElement):
-    """
-    Contains properties related to a resource. (RFC 2518, section 12.11)
-    """
-    name = "prop"
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-class PropertyBehavior (WebDAVElement):
-    """
-    Specifies how properties are handled during a COPY or MOVE. (RFC 2518,
-    section 12.12)
-    """
-    name = "propertybehavior"
-
-    allowed_children = {
-        (dav_namespace, "omit"     ): (0, 1),
-        (dav_namespace, "keepalive"): (0, 1),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(PropertyBehavior, self).__init__(*children, **attributes)
-
-        if len(self.children) != 1:
-            raise ValueError(
-                "Exactly one of DAV:omit, DAV:keepalive required for %s, got: %s"
-                % (self.sname(), self.children)
-            )
-
-        self.behavior = children[0]
-
-class KeepAlive (WebDAVElement):
-    """
-    Specifies requirements for the copying/moving or live properties. (RFC 2518,
-    section 12.12.1)
-    """
-    name = "keepalive"
-
-    allowed_children = {
-        (dav_namespace, "href"): (0, None),
-        PCDATAElement: (0, 1),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(KeepAlive, self).__init__(*children, **attributes)
-
-        type = None
-
-        for child in self.children:
-            if type is None:
-                type = child.qname()
-            elif child.qname() != type:
-                raise ValueError(
-                    "Only one of DAV:href or PCDATA allowed for %s, got: %s"
-                    % (self.sname(), self.children)
-                )
-
-        if type == "#PCDATA":
-            if str(self) != "*":
-                raise ValueError("Invalid keepalive value: %r", (str(self),))
-
-class Omit (WebDAVEmptyElement):
-    """
-    Instructs the server that it should use best effort to copy properties. (RFC
-    2518, section 12.12.2)
-    """
-    name = "omit"
-
-class PropertyUpdate (WebDAVElement):
-    """
-    Contains a request to alter the properties on a resource. (RFC 2518, section
-    12.13)
-    """
-    name = "propertyupdate"
-
-    allowed_children = {
-        (dav_namespace, "remove"): (0, None),
-        (dav_namespace, "set"   ): (0, None),
-    }
-
-class Remove (WebDAVElement):
-    """
-    Lists the DAV properties to be removed from a resource. (RFC 2518, section
-    12.13.1)
-    """
-    name = "remove"
-
-    allowed_children = { (dav_namespace, "prop"): (1, 1) }
-
-class Set (WebDAVElement):
-    """
-    Lists the DAV properties to be set for a resource. (RFC 2518, section
-    12.13.2)
-    """
-    name = "set"
-
-    allowed_children = { (dav_namespace, "prop"): (1, 1) }
-
-class PropertyFind (WebDAVElement):
-    """
-    Specifies the properties to be returned from a PROPFIND
-    method. (RFC 2518, section 12.14)
-    """
-    name = "propfind"
-
-    allowed_children = {
-        (dav_namespace, "allprop" ): (0, 1),
-        (dav_namespace, "propname"): (0, 1),
-        (dav_namespace, "prop"    ): (0, 1),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(PropertyFind, self).__init__(*children, **attributes)
-
-        if len(self.children) != 1:
-            raise ValueError(
-                "Exactly one of DAV:allprop, DAV:propname or DAV:prop is required for %s, got: %r"
-                % (self.sname(), self.children)
-            )
-
-class AllProperties (WebDAVEmptyElement):
-    """
-    Specifies that all property names and values on the resource are
-    to be returned. (RFC 2518, section 12.14.1)
-    """
-    name = "allprop"
-
-class PropertyName (WebDAVEmptyElement):
-    """
-    Specifies that only a list of property names on the resource are
-    to be returned. (RFC 2518, section 12.14.2)
-    """
-    name = "propname"
-
-##
-# Section 13
-##
-
-class CreationDate (WebDAVDateTimeElement):
-    """
-    Records the time and date that the resource was created. (RFC 2518, section
-    13.1)
-    """
-    name = "creationdate"
-    # MAY be protected as per RFC2518bis.  We may make this more flexible later.
-    protected = True
-
-class DisplayName (WebDAVTextElement):
-    """
-    Provides a name for the resource that is suitable for presentation
-    to a user. (RFC 2518, section 13.2)
-    """
-    name = "displayname"
-
-class GETContentLanguage (WebDAVTextElement):
-    """
-    Contains the Content-Language header returned by a GET without
-    accept headers. (RFC 2518, section 13.3)
-    """
-    name = "getcontentlanguage"
-
-class GETContentLength (WebDAVTextElement):
-    """
-    Contains the Content-Length header returned by a GET without
-    accept headers. (RFC 2518, section 13.4)
-    """
-    name = "getcontentlength"
-    protected = True
-
-class GETContentType (WebDAVTextElement):
-    """
-    Contains the Content-Type header returned by a GET without
-    accept headers. (RFC 2518, section 13.5)
-    """
-    name = "getcontenttype"
-
-    def mimeType(self):
-        return MimeType.fromString(str(self))
-
-class GETETag (WebDAVTextElement):
-    """
-    Contains the ETag header returned by a GET without
-    accept headers. (RFC 2518, section 13.6)
-    """
-    name = "getetag"
-    protected = True
-
-class GETLastModified (DateTimeHeaderElement):
-    """
-    Contains the Last-Modified header returned by a GET without accept
-    headers. (RFC 2518, section 13.7)
-    """
-    name = "getlastmodified"
-    protected = True
-
-class LockDiscovery (WebDAVElement):
-    """
-    Describes the active locks on a resource. (RFC 2518, section 13.8)
-    """
-    name = "lockdiscovery"
-    protected = True
-
-    allowed_children = { (dav_namespace, "activelock"): (0, None) }
-
-class ResourceType (WebDAVElement):
-    """
-    Specifies the nature of the resource. (RFC 2518, section 13.9)
-    """
-    name = "resourcetype"
-    protected = True
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-ResourceType.collection = ResourceType(Collection())
-ResourceType.empty      = ResourceType()
-
-class Source (WebDAVElement):
-    """
-    The destination of the source link identifies the resource that
-    contains the unprocessed source of the link's source. (RFC 2518, section
-    13.10)
-    """
-    name = "source"
-
-    allowed_children = { (dav_namespace, "link"): (0, None) }
-
-class SupportedLock (WebDAVElement):
-    """
-    Provides a listing of the lock capabilities supported by the
-    resource. (RFC 2518, section 13.11)
-    """
-    name = "supportedlock"
-    protected = True
-
-    allowed_children = { (dav_namespace, "lockentry"): (0, None) }
Index: twisted/web2/dav/element/parser.py
===================================================================
--- twisted/web2/dav/element/parser.py	(revision 22823)
+++ twisted/web2/dav/element/parser.py	(working copy)
@@ -1,226 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV XML parsing.
-
-This module provides XML utilities for use with WebDAV.
-
-See RFC 2518: http://www.ietf.org/rfc/rfc2518.txt (WebDAV)
-"""
-
-__all__ = [
-    "registerElements",
-    "WebDAVContentHandler",
-    "WebDAVDocument",
-]
-
-import StringIO
-import xml.dom.minidom
-import xml.sax
-
-from twisted.web2.dav.element.base import *
-from twisted.web2.dav.element.util import PrintXML, encodeXMLName
-
-##
-# Parsing
-##
-
-def registerElements(module):
-    """
-    Register XML elements defined in the given module with the parser.
-    """
-    element_names = []
-
-    for element_class_name in dir(module):
-        element_class = getattr(module, element_class_name)
-
-        if type(element_class) is type and issubclass(element_class, WebDAVElement):
-            if element_class.namespace is None: continue
-            if element_class.name is None: continue
-            if element_class.unregistered: continue
-
-            qname = element_class.namespace, element_class.name
-
-            if qname in elements_by_tag_name:
-                raise AssertionError(
-                    "Attempting to register qname %s multiple times: (%r, %r)"
-                    % (qname, elements_by_tag_name[qname], element_class)
-                )
-
-            if not (qname in elements_by_tag_name and issubclass(element_class, elements_by_tag_name[qname])):
-                elements_by_tag_name[qname] = element_class
-                element_names.append(element_class.__name__)
-
-    return element_names
-
-def lookupElement(qname):
-    """
-    Return the element class for the element with the given qname.
-    """
-    return elements_by_tag_name[qname]
-
-elements_by_tag_name = {}
-
-class WebDAVContentHandler (xml.sax.handler.ContentHandler):
-    def setDocumentLocator(self, locator): self.locator = locator
-    locator = None
-
-    def location(self):
-        return "line %d, column %d" % (self.locator.getLineNumber(), self.locator.getColumnNumber())
-
-    def startDocument(self):
-        self.stack = [{
-            "name"       : None,
-            "class"      : None,
-            "attributes" : None,
-            "children"   : [],
-        }]
-
-    def endDocument(self):
-        top = self.stack[-1]
-
-        assert top["name"] is None
-        assert top["class"] is None
-        assert top["attributes"] is None
-        assert len(top["children"]) is 1, "Must have exactly one root element, got %d" % len(top["children"])
-
-        self.dom = WebDAVDocument(top["children"][0])
-
-    def startElementNS(self, name, qname, attributes):
-        attributes_dict = {}
-
-        if attributes.getLength() is not 0:
-            for attr_name in attributes.getNames():
-                attributes_dict[encodeXMLName(attr_name)] = attributes.getValue(attr_name)
-
-        tag_namespace, tag_name = name
-
-        if (name not in elements_by_tag_name):
-            class UnknownElement (WebDAVUnknownElement):
-                namespace = tag_namespace
-                name      = tag_name
-            element_class = UnknownElement
-        else:
-            element_class = elements_by_tag_name[name]
-
-        self.stack.append({
-            "name"       : name,
-            "class"      : element_class,
-            "attributes" : attributes_dict,
-            "children"   : [],
-        })
-
-    def endElementNS(self, name, qname):
-        # Pop the current element from the stack...
-        top = self.stack[-1]
-        del(self.stack[-1])
-
-        assert top["name"] == name, "Last item on stack is %s while closing %s" % (top["name"], name)
-
-        # ...then instantiate the element and add it to the parent's list of
-        # children.
-        try:
-            element = top["class"](*top["children"], **top["attributes"])
-        except ValueError, e:
-            e.args = ("%s at %s" % (e.args[0], self.location()),) + e.args[1:]
-            raise # Re-raises modified e, but preserves traceback
-
-        self.stack[-1]["children"].append(element)
-
-    def characters(self, content):
-        self.stack[-1]["children"].append(PCDATAElement(content))
-
-    def ignorableWhitespace(self, whitespace):
-        self.characters(self, whitespace)
-
-    def startElement(self, name, attributes):
-        raise AssertionError("startElement() should not be called by namespace-aware parser")
-
-    def endElement(self, name):
-        raise AssertionError("endElement() should not be called by namespace-aware parser")
-
-    def processingInstruction(self, target, data):
-        raise AssertionError("processing instructions are not allowed")
-
-    def skippedEntity(self, name):
-        raise AssertionError("skipped entities are not allowed")
-
-class WebDAVDocument (object):
-    """
-    WebDAV XML document.
-    """
-    def _parse(source_is_string):
-        def parse(source):
-            handler = WebDAVContentHandler()
-            parser  = xml.sax.make_parser()
-
-            parser.setContentHandler(handler)
-            parser.setFeature(xml.sax.handler.feature_namespaces, True)
-
-            if source_is_string: source = StringIO.StringIO(source)
-
-            try:
-                parser.parse(source)
-            except xml.sax.SAXParseException, e:
-                raise ValueError(e)
-
-            return handler.dom
-
-        return parse
-        
-    fromStream = staticmethod(_parse(False))
-    fromString = staticmethod(_parse(True ))
-
-    def __init__(self, root_element):
-        """
-        root_element must be a WebDAVElement instance.
-        """
-        super(WebDAVDocument, self).__init__()
-
-        if not isinstance(root_element, WebDAVElement):
-            raise ValueError("Not a WebDAVElement: %r" % (obj,))
-
-        self.root_element = root_element
-
-    def __str__(self):
-        output = StringIO.StringIO()
-        self.writeXML(output)
-        return output.getvalue()
-
-    def __eq__(self, other):
-        if isinstance(other, WebDAVDocument):
-            return self.root_element == other.root_element
-        else:
-            return NotImplemented
-
-    def writeXML(self, output):
-        document = xml.dom.minidom.Document()
-        self.root_element.addToDOM(document, None)
-        PrintXML(document, stream=output)
-
-    def toxml(self):
-        output = StringIO.StringIO()
-        self.writeXML(output)
-        return output.getvalue()
Index: twisted/web2/dav/element/rfc3744.py
===================================================================
--- twisted/web2/dav/element/rfc3744.py	(revision 22823)
+++ twisted/web2/dav/element/rfc3744.py	(working copy)
@@ -1,661 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-RFC 3744 (WebDAV Access Control Protocol) XML Elements
-
-This module provides XML element definitions for use with WebDAV.
-
-See RFC 3744: http://www.ietf.org/rfc/rfc3744.txt
-"""
-
-from twisted.web2.dav.element.base import *
-
-##
-# Section 3 (Privileges)
-##
-
-class Read (WebDAVEmptyElement):
-    """
-    Privilege which controls methods that return information about the state
-    of a resource, including the resource's properties. (RFC 3744, section
-    3.1)
-    """
-    name = "read"
-
-# For DAV:write element (RFC 3744, section 3.2) see Write class above.
-
-class WriteProperties (WebDAVEmptyElement):
-    """
-    Privilege which controls methods that modify the dead properties of a
-    resource. (RFC 3744, section 3.3)
-    """
-    name = "write-properties"
-
-class WriteContent (WebDAVEmptyElement):
-    """
-    Privilege which controls methods that modify the content of an existing
-    resource. (RFC 3744, section 3.4)
-    """
-    name = "write-content"
-
-class Unlock (WebDAVEmptyElement):
-    """
-    Privilege which controls the use of the UNLOCK method by a principal other
-    than the lock owner. (RFC 3744, section 3.5)
-    """
-    name = "unlock"
-
-class ReadACL (WebDAVEmptyElement):
-    """
-    Privilege which controls the use of the PROPFIND method to retrieve the
-    DAV:acl property of a resource. (RFC 3744, section 3.6)
-    """
-    name = "read-acl"
-
-class ReadCurrentUserPrivilegeSet (WebDAVEmptyElement):
-    """
-    Privilege which controls the use of the PROPFIND method to retrieve the
-    DAV:current-user-privilege-set property of a resource. (RFC 3744, section
-    3.7)
-    """
-    name = "read-current-user-privilege-set"
-
-class WriteACL (WebDAVEmptyElement):
-    """
-    Privilege which controls the use of the ACL method to modify the DAV:acl
-    property of a resource. (RFC 3744, section 3.8)
-    """
-    name = "write-acl"
-
-class Bind (WebDAVEmptyElement):
-    """
-    Privilege which allows a method to add a new member URL from the a
-    collection resource. (RFC 3744, section 3.9)
-    """
-    name = "bind"
-
-class Unbind (WebDAVEmptyElement):
-    """
-    Privilege which allows a method to remove a member URL from the a collection
-    resource. (RFC 3744, section 3.10)
-    """
-    name = "unbind"
-
-class All (WebDAVEmptyElement):
-    """
-    Aggregate privilege that contains the entire set of privileges that can be
-    applied to a resource. (RFC 3744, section 3.11)
-    Principal which matches all users. (RFC 3744, section 5.5.1)
-    """
-    name = "all"
-
-##
-# Section 4 (Principal Properties)
-##
-
-class Principal (WebDAVElement):
-    """
-    Indicates a principal resource type. (RFC 3744, section 4)
-    Identifies the principal to which an ACE applies. (RFC 3744, section 5.5.1)
-    """
-    name = "principal"
-
-    allowed_children = {
-        (dav_namespace, "href"           ): (0, 1),
-        (dav_namespace, "all"            ): (0, 1),
-        (dav_namespace, "authenticated"  ): (0, 1),
-        (dav_namespace, "unauthenticated"): (0, 1),
-        (dav_namespace, "property"       ): (0, 1),
-        (dav_namespace, "self"           ): (0, 1),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(Principal, self).__init__(*children, **attributes)
-
-        if len(self.children) > 1:
-            raise ValueError(
-                "Exactly one of DAV:href, DAV:all, DAV:authenticated, "
-                "DAV:unauthenticated, DAV:property or DAV:self is required for "
-                "%s, got: %r"
-                % (self.sname(), self.children)
-            )
-
-class AlternateURISet (WebDAVElement):
-    """
-    Property which contains the URIs of network resources with additional
-    descriptive information about the principal. (RFC 3744, section 4.1)
-    """
-    name = "alternate-uri-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "href"): (0, None) }
-
-class PrincipalURL (WebDAVElement):
-    """
-    Property which contains the URL that must be used to identify this principal
-    in an ACL request. (RFC 3744, section 4.2)
-    """
-    name = "principal-url"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "href"): (0, 1) }
-
-class GroupMemberSet (WebDAVElement):
-    """
-    Property which identifies the principals that are direct members of a group
-    principal.
-    (RFC 3744, section 4.3)
-    """
-    name = "group-member-set"
-    hidden = True
-
-    allowed_children = { (dav_namespace, "href"): (0, None) }
-
-class GroupMembership (WebDAVElement):
-    """
-    Property which identifies the group principals in which a principal is
-    directly a member. (RFC 3744, section 4.4)
-    """
-    name = "group-membership"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "href"): (0, None) }
-
-##
-# Section 5 (Access Control Properties)
-##
-
-# For DAV:owner element (RFC 3744, section 5.1) see Owner class above.
-
-class Group (WebDAVElement):
-    """
-    Property which identifies a particular principal as being the group
-    principal of a resource. (RFC 3744, section 5.2)
-    """
-    name = "group"
-    hidden = True
-    #protected = True # may be protected, per RFC 3744, section 5.2
-
-    allowed_children = { (dav_namespace, "href"): (0, 1) }
-
-class SupportedPrivilegeSet (WebDAVElement):
-    """
-    Property which identifies the privileges defined for a resource. (RFC 3744,
-    section 5.3)
-    """
-    name = "supported-privilege-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "supported-privilege"): (0, None) }
-
-class SupportedPrivilege (WebDAVElement):
-    """
-    Identifies a privilege defined for a resource. (RFC 3744, section 5.3)
-    """
-    name = "supported-privilege"
-
-    allowed_children = {
-        (dav_namespace, "privilege"          ): (1, 1),
-        (dav_namespace, "abstract"           ): (0, 1),
-        (dav_namespace, "description"        ): (1, 1),
-        (dav_namespace, "supported-privilege"): (0, None),
-    }
-
-class Privilege (WebDAVElement):
-    """
-    Identifies a privilege. (RFC 3744, sections 5.3 and 5.5.1)
-    """
-    name = "privilege"
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-class Abstract (WebDAVElement):
-    """
-    Identifies a privilege as abstract. (RFC 3744, section 5.3)
-    """
-    name = "abstract"
-
-class Description (WebDAVTextElement):
-    """
-    A human-readable description of what privilege controls access to. (RFC
-    3744, sections 5.3 and 9.5)
-    """
-    name = "description"
-    allowed_attributes = { "xml:lang": True }
-
-class CurrentUserPrivilegeSet (WebDAVElement):
-    """
-    Property which contains the exact set of privileges (as computer by the
-    server) granted to the currently authenticated HTTP user. (RFC 3744, section
-    5.4)
-    """
-    name = "current-user-privilege-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "privilege"): (0, None) }
-
-# For DAV:privilege element (RFC 3744, section 5.4) see Privilege class above.
-
-class ACL (WebDAVElement):
-    """
-    Property which specifies the list of access control entries which define
-    what privileges are granted to which users for a resource. (RFC 3744,
-    section 5.5)
-    """
-    name = "acl"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "ace"): (0, None) }
-
-class ACE (WebDAVElement):
-    """
-    Specifies the list of access control entries which define what privileges
-    are granted to which users for a resource. (RFC 3744, section 5.5)
-    """
-    name = "ace"
-
-    allowed_children = {
-        (dav_namespace, "principal"): (0, 1),
-        (dav_namespace, "invert"   ): (0, 1),
-        (dav_namespace, "grant"    ): (0, 1),
-        (dav_namespace, "deny"     ): (0, 1),
-        (dav_namespace, "protected"): (0, 1),
-        (dav_namespace, "inherited"): (0, 1),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(ACE, self).__init__(*children, **attributes)
-
-        self.principal  = None
-        self.invert     = None
-        self.allow      = None
-        self.privileges = None
-        self.inherited  = None
-        self.protected  = False
-
-        for child in self.children:
-            namespace, name = child.qname()
-
-            assert namespace == dav_namespace
-
-            if name in ("principal", "invert"):
-                if self.principal is not None:
-                    raise ValueError(
-                        "Only one of DAV:principal or DAV:invert allowed in %s, got: %s"
-                        % (self.sname(), self.children)
-                    )
-                if name == "invert":
-                    self.invert    = True
-                    self.principal = child.children[0]
-                else:
-                    self.invert    = False
-                    self.principal = child
-
-            elif name in ("grant", "deny"):
-                if self.allow is not None:
-                    raise ValueError(
-                        "Only one of DAV:grant or DAV:deny allowed in %s, got: %s"
-                        % (self.sname(), self.children)
-                    )
-                self.allow      = (name == "grant")
-                self.privileges = child.children
-
-            elif name == "inherited":
-                self.inherited = str(child.children[0])
-
-            elif name == "protected":
-                self.protected = True
-
-        if self.principal is None:
-            raise ValueError(
-                "One of DAV:principal or DAV:invert is required in %s, got: %s"
-                % (self.sname(), self.children)
-            )
-        assert self.invert is not None
-
-        if self.allow is None:
-            raise ValueError(
-                "One of DAV:grant or DAV:deny is required in %s, got: %s"
-                % (self.sname(), self.children)
-            )
-        assert self.privileges is not None
-
-# For DAV:principal element (RFC 3744, section 5.5.1) see Principal class above.
-
-# For DAV:all element (RFC 3744, section 5.5.1) see All class above.
-
-class Authenticated (WebDAVEmptyElement):
-    """
-    Principal which matches authenticated users. (RFC 3744, section 5.5.1)
-    """
-    name = "authenticated"
-
-class Unauthenticated (WebDAVEmptyElement):
-    """
-    Principal which matches unauthenticated users. (RFC 3744, section 5.5.1)
-    """
-    name = "unauthenticated"
-
-# For DAV:property element (RFC 3744, section 5.5.1) see Property class above.
-
-class Self (WebDAVEmptyElement):
-    """
-    Principal which matches a user if a resource is a principal and the user
-    matches the resource. (RFC 3744, sections 5.5.1 and 9.3)
-    """
-    name = "self"
-
-class Invert (WebDAVEmptyElement):
-    """
-    Principal which matches a user if the user does not match the principal
-    contained by this principal. (RFC 3744, section 5.5.1)
-    """
-    name = "invert"
-
-    allowed_children = { (dav_namespace, "principal"): (1, 1) }
-
-class Grant (WebDAVElement):
-    """
-    Grants the contained privileges to a principal. (RFC 3744, section 5.5.2)
-    """
-    name = "grant"
-
-    allowed_children = { (dav_namespace, "privilege"): (1, None) }
-
-class Deny (WebDAVElement):
-    """
-    Denies the contained privileges to a principal. (RFC 3744, section 5.5.2)
-    """
-    name = "deny"
-
-    allowed_children = { (dav_namespace, "privilege"): (1, None) }
-
-# For DAV:privilege element (RFC 3744, section 5.5.2) see Privilege class above.
-
-class Protected (WebDAVEmptyElement):
-    """
-    Identifies an ACE as protected. (RFC 3744, section 5.5.3)
-    """
-    name = "protected"
-
-class Inherited (WebDAVElement):
-    """
-    Indicates that an ACE is inherited from the resource indentified by the
-    contained DAV:href element. (RFC 3744, section 5.5.4)
-    """
-    name = "inherited"
-
-    allowed_children = { (dav_namespace, "href"): (1, 1) }
-
-class ACLRestrictions (WebDAVElement):
-    """
-    Property which defines the types of ACLs supported by this server, to avoid
-    clients needlessly getting errors. (RFC 3744, section 5.6)
-    """
-    name = "acl-restrictions"
-    hidden = True
-    protected = True
-
-    allowed_children = {
-        (dav_namespace, "grant-only"        ): (0, 1),
-        (dav_namespace, "no-invert"         ): (0, 1),
-        (dav_namespace, "deny-before-grant" ): (0, 1),
-        (dav_namespace, "required-principal"): (0, 1),
-    }
-
-class GrantOnly (WebDAVEmptyElement):
-    """
-    Indicates that ACEs with deny clauses are not allowed. (RFC 3744, section
-    5.6.1)
-    """
-    name = "grant-only"
-
-class NoInvert (WebDAVEmptyElement):
-    """
-    Indicates that ACEs with the DAV:invert element are not allowed. (RFC 3744,
-    section 5.6.2)
-    """
-    name = "no-invert"
-
-class DenyBeforeGrant (WebDAVEmptyElement):
-    """
-    Indicates that all deny ACEs must precede all grant ACEs. (RFC 3744, section
-    5.6.3)
-    """
-    name = "deny-before-grant"
-
-class RequiredPrincipal (WebDAVElement):
-    """
-    Indicates which principals must have an ACE defined in an ACL. (RFC 3744,
-    section 5.6.4)
-    """
-    name = "required-principal"
-
-    allowed_children = {
-        (dav_namespace, "all"            ): (0, 1),
-        (dav_namespace, "authenticated"  ): (0, 1),
-        (dav_namespace, "unauthenticated"): (0, 1),
-        (dav_namespace, "self"           ): (0, 1),
-        (dav_namespace, "href"           ): (0, None),
-        (dav_namespace, "property"       ): (0, None),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(RequiredPrincipal, self).__init__(*children, **attributes)
-
-        type = None
-
-        for child in self.children:
-            if type is None:
-                type = child.qname()
-            elif child.qname() != type:
-                raise ValueError(
-                    "Only one of DAV:all, DAV:authenticated, DAV:unauthenticated, "
-                    "DAV:self, DAV:href or DAV:property allowed for %s, got: %s"
-                    % (self.sname(), self.children)
-                )
-
-class InheritedACLSet (WebDAVElement):
-    """
-    Property which contains a set of URLs that identify other resources that
-    also control the access to this resource. (RFC 3744, section 5.7)
-    """
-    name = "inherited-acl-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "href"): (0, None) }
-
-class PrincipalCollectionSet (WebDAVElement):
-    """
-    Property which contains a set of URLs that identify the root collections
-    that contain the principals that are available on the server that implements
-    a resource. (RFC 3744, section 5.8)
-    """
-    name = "principal-collection-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "href"): (0, None) }
-
-##
-# Section 7 (Access Control and existing methods)
-##
-
-class NeedPrivileges (WebDAVElement):
-    """
-    Error which indicates insufficient privileges. (RFC 3744, section 7.1.1)
-    """
-    name = "need-privileges"
-
-    allowed_children = { (dav_namespace, "resource"): (0, None) }
-
-class Resource (WebDAVElement):
-    """
-    Identifies which resource had insufficient privileges. (RFC 3744, section
-    7.1.1)
-    """
-    name = "resource"
-
-    allowed_children = {
-        (dav_namespace, "href"     ): (1, 1),
-        (dav_namespace, "privilege"): (1, 1),
-    }
-
-##
-# Section 9 (Access Control Reports)
-##
-
-class ACLPrincipalPropSet (WebDAVElement):
-    """
-    Report which returns, for all principals in the DAV:acl property (of the
-    resource identified by the Request-URI) that are identified by http(s) URLs
-    or by a DAV:property principal, the value of the properties specified in the
-    REPORT request body. (RFC 3744, section 9.2)
-    """
-    name = "acl-principal-prop-set"
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-    def __init__(self, *children, **attributes):
-        super(ACLPrincipalPropSet, self).__init__(*children, **attributes)
-
-        prop = False
-        
-        for child in self.children:
-            if child.qname() == (dav_namespace, "prop"):
-                if prop:
-                    raise ValueError(
-                        "Only one DAV:prop allowed for %s, got: %s"
-                        % (self.sname(), self.children)
-                    )
-                prop = True
-
-class PrincipalMatch (WebDAVElement):
-    """
-    Report used to identify all members (at any depth) of the collection
-    identified by the Request-URI that are principals and that match the current
-    user. (RFC 3744, section 9.3)
-    """
-    name = "principal-match"
-
-    allowed_children = {
-        (dav_namespace, "principal-property"): (0, 1),
-        (dav_namespace, "self"              ): (0, 1),
-        (dav_namespace, "prop"              ): (0, 1),
-    }
-
-    def __init__(self, *children, **attributes):
-        super(PrincipalMatch, self).__init__(*children, **attributes)
-
-        principalPropertyOrSelf = False
-
-        for child in self.children:
-            namespace, name = child.qname()
-
-            if name in ("principal-property", "self"):
-                if principalPropertyOrSelf:
-                    raise ValueError(
-                        "Only one of DAV:principal-property or DAV:self allowed in %s, got: %s"
-                        % (self.sname(), self.children)
-                    )
-                principalPropertyOrSelf = True
-
-        if not principalPropertyOrSelf:
-            raise ValueError(
-                "One of DAV:principal-property or DAV:self is required in %s, got: %s"
-                % (self.sname(), self.children)
-            )
-
-class PrincipalProperty (WebDAVElement):
-    """
-    Identifies a property. (RFC 3744, section 9.3)
-    """
-    name = "principal-property"
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-# For DAV:self element (RFC 3744, section 9.3) see Self class above.
-
-class PrincipalPropertySearch (WebDAVElement):
-    """
-    Report which performs a search for all principals whose properties contain
-    character data that matches the search criteria specified in the request.
-    (RFC 3744, section 9.4)
-    """
-    name = "principal-property-search"
-
-    allowed_children = {
-        (dav_namespace, "property-search"                  ): (1, None),
-        (dav_namespace, "prop"                             ): (0, 1),
-        (dav_namespace, "apply-to-principal-collection-set"): (0, 1),
-    }
-
-class PropertySearch (WebDAVElement):
-    """
-    Contains a DAV:prop element enumerating the properties to be searched and a
-    DAV:match element, containing the search string. (RFC 3744, section 9.4)
-    """
-    name = "property-search"
-
-    allowed_children = {
-        (dav_namespace, "prop" ): (1, 1),
-        (dav_namespace, "match"): (1, 1),
-    }
-
-class Match (WebDAVTextElement):
-    """
-    Contains a search string. (RFC 3744, section 9.4)
-    """
-    name = "match"
-
-class PrincipalSearchPropertySet (WebDAVElement):
-    """
-    Report which identifies those properties that may be searched using the
-    DAV:principal-property-search report. (RFC 3744, section 9.5)
-    """
-    name = "principal-search-property-set"
-
-    allowed_children = { (dav_namespace, "principal-search-property"): (0, None) }
-
-class PrincipalSearchProperty (WebDAVElement):
-    """
-    Contains exactly one searchable property, and a description of the property.
-    (RFC 3744, section 9.5)
-    """
-    name = "principal-search-property"
-
-    allowed_children = {
-        (dav_namespace, "prop"       ): (1, 1),
-        (dav_namespace, "description"): (1, 1),
-    }
-
-# For DAV:description element (RFC 3744, section 9.5) see Description class above.
Index: twisted/web2/dav/element/util.py
===================================================================
--- twisted/web2/dav/element/util.py	(revision 22823)
+++ twisted/web2/dav/element/util.py	(working copy)
@@ -1,72 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV XML utilities.
-
-This module provides XML utilities for use with WebDAV.
-
-See RFC 2518: http://www.ietf.org/rfc/rfc2518.txt (WebDAV)
-"""
-
-__all__ = [
-    "PrintXML",
-    "encodeXMLName",
-    "decodeXMLName",
-]
-
-try:
-    import xml.dom.ext as ext
-except ImportError:
-    import twisted.web2.dav.element.xmlext as ext
-
-def PrintXML(document, stream):
-    document.normalize()
-    ext.Print(document, stream)
-    # For debugging, this is easier to read: (FIXME: disable for normal use)
-    #ext.PrettyPrint(document, stream)
-
-def encodeXMLName(name):
-    """
-    Encodes an XML (namespace, localname) pair into an ASCII string.
-    If namespace is None, returns localname encoded as UTF-8.
-    Otherwise, returns {namespace}localname encoded as UTF-8.
-    """
-    namespace, name = name
-    if namespace is None: return name.encode("utf-8")
-    return (u"{%s}%s" % (namespace, name)).encode("utf-8")
-
-def decodeXMLName(name):
-    """
-    Decodes an XML (namespace, localname) pair from an ASCII string as encoded
-    by encodeXMLName().
-    """
-    if name[0] is not "{": return (None, name.decode("utf-8"))
-
-    index = name.find("}")
-
-    if (index is -1 or not len(name) > index):
-        raise ValueError("Invalid encoded name: %r" % (name,))
-
-    return (name[1:index].decode("utf-8"), name[index+1:].decode("utf-8"))
Index: twisted/web2/dav/element/__init__.py
===================================================================
--- twisted/web2/dav/element/__init__.py	(revision 22823)
+++ twisted/web2/dav/element/__init__.py	(working copy)
@@ -1,38 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV XML Glue.
-
-Modules in this package provide the implementation of twisted.web2.dav.davxml.
-"""
-
-__all__ = [
-    "base",
-    "parser",
-    "util",
-    "rfc2518",
-    "rfc3253",
-    "rfc3744",
-]
Index: twisted/web2/dav/element/xmlext.py
===================================================================
--- twisted/web2/dav/element/xmlext.py	(revision 22823)
+++ twisted/web2/dav/element/xmlext.py	(working copy)
@@ -1,430 +0,0 @@
-########################################################################
-#
-# File Name:            __init__.py
-#
-#
-"""
-WWW: http://4suite.com/4DOM         e-mail: support@4suite.com
-
-Copyright (c) 2000 Fourthought Inc, USA.   All Rights Reserved.
-See  http://4suite.com/COPYRIGHT  for license and copyright information
-"""
-
-"""Some Helper functions: 4DOM/PyXML-specific Extensions to the DOM,
-and DOM-related utilities."""
-
-__all__ = [ "Print", "PrettyPrint" ]
-
-import sys,string
-import re
-
-from xml.dom import Node
-from xml.dom import XML_NAMESPACE, XMLNS_NAMESPACE, DOMException
-
-def Print(root, stream=sys.stdout, encoding='UTF-8'):
-    if not hasattr(root, "nodeType"):
-        return
-    nss = SeekNss(root)
-    visitor = PrintVisitor(stream, encoding, nsHints=nss)
-    PrintWalker(visitor, root).run()
-    return
-
-def PrettyPrint(root, stream=sys.stdout, encoding='UTF-8', indent='  ',
-                preserveElements=None):
-    if not hasattr(root, "nodeType"):
-        return
-    nss_hints = SeekNss(root)
-    preserveElements = preserveElements or []
-    owner_doc = root.ownerDocument or root
-    if hasattr(owner_doc, 'getElementsByName'):
-        #We don't want to insert any whitespace into HTML inline elements
-        preserveElements = preserveElements + HTML_4_TRANSITIONAL_INLINE
-    visitor = PrintVisitor(stream, encoding, indent,
-                                   preserveElements, nss_hints)
-    PrintWalker(visitor, root).run()
-    stream.write('\n')
-    return
-
-def GetAllNs(node):
-    #The xml namespace is implicit
-    nss = {'xml': XML_NAMESPACE}
-    if node.nodeType == Node.ATTRIBUTE_NODE and node.ownerElement:
-        return GetAllNs(node.ownerElement)
-    if node.nodeType == Node.ELEMENT_NODE:
-        if node.namespaceURI:
-            nss[node.prefix] = node.namespaceURI
-        for attr in node.attributes.values():
-            if attr.namespaceURI == XMLNS_NAMESPACE:
-                if attr.localName == 'xmlns':
-                    nss[None] = attr.value
-                else:
-                    nss[attr.localName] = attr.value
-            elif attr.namespaceURI:
-                nss[attr.prefix] = attr.namespaceURI
-    if node.parentNode:
-        #Inner NS/Prefix mappings take precedence over outer ones
-        parent_nss = GetAllNs(node.parentNode)
-        parent_nss.update(nss)
-        nss = parent_nss
-    return nss
-
-def SeekNss(node, nss=None):
-    '''traverses the tree to seek an approximate set of defined namespaces'''
-    nss = nss or {}
-    for child in node.childNodes:
-        if child.nodeType == Node.ELEMENT_NODE:
-            if child.namespaceURI:
-                nss[child.prefix] = child.namespaceURI
-            for attr in child.attributes.values():
-                if attr.namespaceURI == XMLNS_NAMESPACE:
-                    if attr.localName == 'xmlns':
-                        nss[None] = attr.value
-                    else:
-                        nss[attr.localName] = attr.value
-                elif attr.namespaceURI:
-                    nss[attr.prefix] = attr.namespaceURI
-            SeekNss(child, nss)
-    return nss
-
-class PrintVisitor:
-    def __init__(self, stream, encoding, indent='', plainElements=None,
-                 nsHints=None, isXhtml=0, force8bit=0):
-        self.stream = stream
-        self.encoding = encoding
-        # Namespaces
-        self._namespaces = [{}]
-        self._nsHints = nsHints or {}
-        # PrettyPrint
-        self._indent = indent
-        self._depth = 0
-        self._inText = 0
-        self._plainElements = plainElements or []
-        # HTML support
-        self._html = None
-        self._isXhtml = isXhtml
-        self.force8bit = force8bit
-        return
-
-    def _write(self, text):
-        if self.force8bit:
-            obj = strobj_to_utf8str(text, self.encoding)
-        else:
-            obj = utf8_to_code(text, self.encoding)
-        self.stream.write(obj)
-        return
-
-    def _tryIndent(self):
-        if not self._inText and self._indent:
-            self._write('\n' + self._indent*self._depth)
-        return
-
-    def visit(self, node):
-        if self._html is None:
-            # Set HTMLDocument flag here for speed
-            self._html = hasattr(node.ownerDocument, 'getElementsByName')
-
-        nodeType = node.nodeType
-        if node.nodeType == Node.ELEMENT_NODE:
-            return self.visitElement(node)
-
-        elif node.nodeType == Node.ATTRIBUTE_NODE:
-            return self.visitAttr(node)
-
-        elif node.nodeType == Node.TEXT_NODE:
-            return self.visitText(node)
-
-        elif node.nodeType == Node.CDATA_SECTION_NODE:
-            return self.visitCDATASection(node)
-
-        elif node.nodeType == Node.ENTITY_REFERENCE_NODE:
-            return self.visitEntityReference(node)
-
-        elif node.nodeType == Node.ENTITY_NODE:
-            return self.visitEntity(node)
-
-        elif node.nodeType == Node.PROCESSING_INSTRUCTION_NODE:
-            return self.visitProcessingInstruction(node)
-
-        elif node.nodeType == Node.COMMENT_NODE:
-            return self.visitComment(node)
-
-        elif node.nodeType == Node.DOCUMENT_NODE:
-            return self.visitDocument(node)
-
-        elif node.nodeType == Node.DOCUMENT_TYPE_NODE:
-            return self.visitDocumentType(node)
-
-        elif node.nodeType == Node.DOCUMENT_FRAGMENT_NODE:
-            return self.visitDocumentFragment(node)
-
-        elif node.nodeType == Node.NOTATION_NODE:
-            return self.visitNotation(node)
-
-        # It has a node type, but we don't know how to handle it
-        raise Exception("Unknown node type: %s" % repr(node))
-
-    def visitNodeList(self, node, exclude=None):
-        for curr in node:
-            curr is not exclude and self.visit(curr)
-        return
-
-    def visitNamedNodeMap(self, node):
-        for item in node.values():
-            self.visit(item)
-        return
-
-    def visitAttr(self, node):
-        if node.namespaceURI == XMLNS_NAMESPACE:
-            # Skip namespace declarations
-            return
-        self._write(' ' + node.name)
-        value = node.value
-        if value or not self._html:
-            text = TranslateCdata(value, self.encoding)
-            text, delimiter = TranslateCdataAttr(text)
-            self.stream.write("=%s%s%s" % (delimiter, text, delimiter))
-        return
-
-    def visitProlog(self):
-        self._write("<?xml version='1.0' encoding='%s'?>" % (
-            self.encoding or 'utf-8'
-            ))
-        self._inText = 0
-        return
-
-    def visitDocument(self, node):
-        not self._html and self.visitProlog()
-        node.doctype and self.visitDocumentType(node.doctype)
-        self.visitNodeList(node.childNodes, exclude=node.doctype)
-        return
-
-    def visitDocumentFragment(self, node):
-        self.visitNodeList(node.childNodes)
-        return
-
-    def visitElement(self, node):
-        self._namespaces.append(self._namespaces[-1].copy())
-        inline = node.tagName in self._plainElements
-        not inline and self._tryIndent()
-        self._write('<%s' % node.tagName)
-        if self._isXhtml or not self._html:
-            namespaces = ''
-            if self._isXhtml:
-                nss = {'xml': XML_NAMESPACE, None: XHTML_NAMESPACE}
-            else:
-                nss = GetAllNs(node)
-            if self._nsHints:
-                self._nsHints.update(nss)
-                nss = self._nsHints
-                self._nsHints = {}
-            del nss['xml']
-            for prefix in nss.keys():
-                if not self._namespaces[-1].has_key(prefix) or self._namespaces[-1][prefix] != nss[prefix]:
-                    nsuri, delimiter = TranslateCdataAttr(nss[prefix])
-                    if prefix:
-                        xmlns = " xmlns:%s=%s%s%s" % (prefix, delimiter,nsuri,delimiter)
-                    else:
-                        xmlns = " xmlns=%s%s%s" % (delimiter,nsuri,delimiter)
-                    namespaces = namespaces + xmlns
-
-                self._namespaces[-1][prefix] = nss[prefix]
-            self._write(namespaces)
-        for attr in node.attributes.values():
-            self.visitAttr(attr)
-        if len(node.childNodes):
-            self._write('>')
-            self._depth = self._depth + 1
-            self.visitNodeList(node.childNodes)
-            self._depth = self._depth - 1
-            if not self._html or (node.tagName not in HTML_FORBIDDEN_END):
-                not (self._inText and inline) and self._tryIndent()
-                self._write('</%s>' % node.tagName)
-        elif not self._html:
-            self._write('/>')
-        elif node.tagName not in HTML_FORBIDDEN_END:
-            self._write('></%s>' % node.tagName)
-        else:
-            self._write('>')
-        del self._namespaces[-1]
-        self._inText = 0
-        return
-
-    def visitText(self, node):
-        text = node.data
-        if self._indent:
-            text = string.strip(text) and text
-        if text:
-            if self._html:
-                text = TranslateHtmlCdata(text, self.encoding)
-            else:
-                text = TranslateCdata(text, self.encoding)
-            self.stream.write(text)
-            self._inText = 1
-        return
-
-    def visitDocumentType(self, doctype):
-        if not doctype.systemId and not doctype.publicId: return
-        self._tryIndent()
-        self._write('<!DOCTYPE %s' % doctype.name)
-        if doctype.systemId and '"' in doctype.systemId:
-            system = "'%s'" % doctype.systemId
-        else:
-            system = '"%s"' % doctype.systemId
-        if doctype.publicId and '"' in doctype.publicId:
-            # We should probably throw an error
-            # Valid characters:  <space> | <newline> | <linefeed> |
-            #                    [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
-            public = "'%s'" % doctype.publicId
-        else:
-            public = '"%s"' % doctype.publicId
-        if doctype.publicId and doctype.systemId:
-            self._write(' PUBLIC %s %s' % (public, system))
-        elif doctype.systemId:
-            self._write(' SYSTEM %s' % system)
-        if doctype.entities or doctype.notations:
-            self._write(' [')
-            self._depth = self._depth + 1
-            self.visitNamedNodeMap(doctype.entities)
-            self.visitNamedNodeMap(doctype.notations)
-            self._depth = self._depth - 1
-            self._tryIndent()
-            self._write(']>')
-        else:
-            self._write('>')
-        self._inText = 0
-        return
-
-    def visitEntity(self, node):
-        """Visited from a NamedNodeMap in DocumentType"""
-        self._tryIndent()
-        self._write('<!ENTITY %s' % (node.nodeName))
-        node.publicId and self._write(' PUBLIC %s' % node.publicId)
-        node.systemId and self._write(' SYSTEM %s' % node.systemId)
-        node.notationName and self._write(' NDATA %s' % node.notationName)
-        self._write('>')
-        return
-
-    def visitNotation(self, node):
-        """Visited from a NamedNodeMap in DocumentType"""
-        self._tryIndent()
-        self._write('<!NOTATION %s' % node.nodeName)
-        node.publicId and self._write(' PUBLIC %s' % node.publicId)
-        node.systemId and self._write(' SYSTEM %s' % node.systemId)
-        self._write('>')
-        return
-
-    def visitCDATASection(self, node):
-        self._tryIndent()
-        self._write('<![CDATA[%s]]>' % (node.data))
-        self._inText = 0
-        return
-
-    def visitComment(self, node):
-        self._tryIndent()
-        self._write('<!--%s-->' % (node.data))
-        self._inText = 0
-        return
-
-    def visitEntityReference(self, node):
-        self._write('&%s;' % node.nodeName)
-        self._inText = 1
-        return
-
-    def visitProcessingInstruction(self, node):
-        self._tryIndent()
-        self._write('<?%s %s?>' % (node.target, node.data))
-        self._inText = 0
-        return
-
-class PrintWalker:
-    def __init__(self, visitor, startNode):
-        self.visitor = visitor
-        self.start_node = startNode
-        return
-
-    def step(self):
-        """There is really no step to printing.  It prints the whole thing"""
-        self.visitor.visit(self.start_node)
-        return
-
-    def run(self):
-        return self.step()
-
-ILLEGAL_LOW_CHARS = '[\x01-\x08\x0B-\x0C\x0E-\x1F]'
-SURROGATE_BLOCK = '[\xF0-\xF7][\x80-\xBF][\x80-\xBF][\x80-\xBF]'
-ILLEGAL_HIGH_CHARS = '\xEF\xBF[\xBE\xBF]'
-#Note: Prolly fuzzy on this, but it looks as if characters from the surrogate block are allowed if in scalar form, which is encoded in UTF8 the same was as in surrogate block form
-XML_ILLEGAL_CHAR_PATTERN = re.compile('%s|%s'%(ILLEGAL_LOW_CHARS, ILLEGAL_HIGH_CHARS))
-
-g_utf8TwoBytePattern = re.compile('([\xC0-\xC3])([\x80-\xBF])')
-g_cdataCharPattern = re.compile('[&<]|]]>')
-g_charToEntity = {
-        '&': '&amp;',
-        '<': '&lt;',
-        ']]>': ']]&gt;',
-        }
-
-# Slightly modified to not use types.Unicode
-import codecs
-def utf8_to_code(text, encoding):
-    encoder = codecs.lookup(encoding)[0] # encode,decode,reader,writer
-    if type(text) is not unicode:
-        text = unicode(text, "utf-8")
-    return encoder(text)[0] # result,size
-def strobj_to_utf8str(text, encoding):
-    if string.upper(encoding) not in ["UTF-8", "ISO-8859-1", "LATIN-1"]:
-        raise ValueError("Invalid encoding: %s"%encoding)
-    encoder = codecs.lookup(encoding)[0] # encode,decode,reader,writer
-    if type(text) is not unicode:
-        text = unicode(text, "utf-8")
-    #FIXME
-    return str(encoder(text)[0])
-
-def TranslateCdataAttr(characters):
-    '''Handles normalization and some intelligence about quoting'''
-    if not characters:
-        return '', "'"
-    if "'" in characters:
-        delimiter = '"'
-        new_chars = re.sub('"', '&quot;', characters)
-    else:
-        delimiter = "'"
-        new_chars = re.sub("'", '&apos;', characters)
-    #FIXME: There's more to normalization
-    #Convert attribute new-lines to character entity
-    # characters is possibly shorter than new_chars (no entities)
-    if "\n" in characters:
-        new_chars = re.sub('\n', '&#10;', new_chars)
-    return new_chars, delimiter
-
-#Note: Unicode object only for now
-def TranslateCdata(characters, encoding='UTF-8', prev_chars='', markupSafe=0,
-                   charsetHandler=utf8_to_code):
-    """
-    charsetHandler is a function that takes a string or unicode object as the
-    first argument, representing the string to be procesed, and an encoding
-    specifier as the second argument.  It must return a string or unicode
-    object
-    """
-    if not characters:
-        return ''
-    if not markupSafe:
-        if g_cdataCharPattern.search(characters):
-            new_string = g_cdataCharPattern.subn(
-                lambda m, d=g_charToEntity: d[m.group()],
-                characters)[0]
-        else:
-            new_string = characters
-        if prev_chars[-2:] == ']]' and characters[0] == '>':
-            new_string = '&gt;' + new_string[1:]
-    else:
-        new_string = characters
-    #Note: use decimal char entity rep because some browsers are broken
-    #FIXME: This will bomb for high characters.  Should, for instance, detect
-    #The UTF-8 for 0xFFFE and put out &#xFFFE;
-    if XML_ILLEGAL_CHAR_PATTERN.search(new_string):
-        new_string = XML_ILLEGAL_CHAR_PATTERN.subn(
-            lambda m: '&#%i;' % ord(m.group()),
-            new_string)[0]
-    new_string = charsetHandler(new_string, encoding)
-    return new_string
Index: twisted/web2/dav/element/rfc3253.py
===================================================================
--- twisted/web2/dav/element/rfc3253.py	(revision 22823)
+++ twisted/web2/dav/element/rfc3253.py	(working copy)
@@ -1,196 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-RFC 3253 (Versioning Extensions to WebDAV) XML Elements
-
-This module provides XML element definitions for use with WebDAV.
-
-See RFC 3253: http://www.ietf.org/rfc/rfc3253.txt
-"""
-
-from twisted.web2.dav.element.base import *
-
-##
-# Section 1
-##
-
-class Error (WebDAVElement):
-    """
-    Specifies an error condition. (RFC 3253, section 1.6)
-    """
-    # FIXME: RFC 3253 doesn't quite seem to define this element...
-    # FIXME: Move when we update to RFC 2518bis
-    name = "error"
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-##
-# Section 3
-##
-
-class Comment (WebDAVTextElement):
-    """
-    Property used to track a brief comment about a resource that is suitable for
-    presentation to a user. On a version, can be used to indicate why that
-    version was created. (RFC 3253, section 3.1.1)
-    """
-    name = "comment"
-    hidden = True
-
-class CreatorDisplayName (WebDAVTextElement):
-    """
-    Property which contains a description of the creator of the resource that is
-    suitable for presentation to a user. (RFC 3253, section 3.1.2)
-    """
-    name = "creator-displayname"
-    hidden = True
-
-class SupportedMethod (WebDAVElement):
-    """
-    Property which identifies a method that is supported by a resource. A method
-    is supported by a resource if there is some state of that resource for which
-    an application of that method will successfully satisfy all postconditions
-    of that method, including any additional postconditions added by the
-    features supported by that resource. (RFC 3253, section 3.1.3)
-    """
-    name = "supported-method"
-    hidden = True
-
-    allowed_children = { WebDAVElement: (0, None) }
-    allowed_attributes = { "name": True }
-
-class SupportedMethodSet (WebDAVElement):
-    """
-    Property which identifies the methods that are supported by a resource. (RFC
-    3253, section 3.1.3)
-    """
-    name = "supported-method-set"
-    protected = True
-    hidden = True
-
-    allowed_children = { (dav_namespace, "supported-method"): (0, None) }
-
-class SupportedLiveProperty (WebDAVElement):
-    """
-    Property which identifies a live property that is supported by a resource. A
-    live property is supported by a resource if that property has the semantics
-    defined for that property.  The value of this property must identify all
-    live properties defined by this document that are supported by the resource
-    and should identify all live properties that are supported by the resource.
-    (RFC 3253, section 3.1.4)
-    """
-    name = "supported-live-property"
-
-    # FIXME: Where is the name element defined?
-    allowed_children = { (dav_namespace, "name"): (1, 1) }
-
-class SupportedLivePropertySet (WebDAVElement):
-    """
-    Property which identifies the live properties that are supported by a
-    resource. (RFC 3253, section 3.1.4)
-    """
-    name = "supported-live-property-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "supported-live-property"): (0, None) }
-
-class Report (WebDAVElement):
-    """
-    A report. (RFC 3253, section 3.1.5)
-    """
-    # FIXME: Section 3.1.5 is pretty low on information.  Where else do we look?
-    name = "report"
-
-    allowed_children = { WebDAVElement: (0, None) }
-
-class SupportedReport (WebDAVElement):
-    """
-    Identifies a report that is supported by the resource.  (RFC 3253, section
-    3.1.5)
-    """
-    name = "supported-report"
-
-    #
-    # FIXME:
-    #
-    #   RFC 3253, section 3.1.5 defines supported-report as:
-    #
-    #     <!ELEMENT supported-report report>
-    #
-    #   Which means that a report child element is required.  However, section
-    # 3.6 defined a precondition with the same name (DAV:supported-report),
-    # which means that, according to section 1.6.1, this XML must be issued if
-    # the precondition fails:
-    #
-    #     <?xml version="1.0"?>
-    #     <D:error xmlns:D="DAV:">
-    #      <D:supported-report/>
-    #     </D:error>
-    #
-    #   Which is a problem because here we use supported-report with no
-    # children.
-    #
-    #   Absent any better guidance, we'll allow no children for this element for
-    # the time being.
-    #
-    allowed_children = { (dav_namespace, "report"): (0, 1) }
-
-class SupportedReportSet (WebDAVElement):
-    """
-    Property which identifies the reports that are supported by the resource.
-    (RFC 3253, section 3.1.5)
-    """
-    name = "supported-report-set"
-    hidden = True
-    protected = True
-
-    allowed_children = { (dav_namespace, "supported-report"): (0, None) }
-
-class ExpandProperty (WebDAVElement):
-    """
-    Report which provides a mechanism for retrieving in one request the
-    properties from resources identified by DAV:href property values.
-    (RFC 3253, section 3.8)
-    """
-    name = "expand-property"
-
-    allowed_children = { (dav_namespace, "property"): (0, None) }
-
-class Property (WebDAVElement):
-    """
-    Identifies a property by name. (RFC 3253, section 3.8)
-    Principal which matches a user if the value of the identified property of a
-    resource contains at most one DAV:href element, the value of that element
-    identifies a principal, and the user matches that principal. (RFC 3744,
-    section 5.5.1)
-    """
-    name = "property"
-
-    allowed_children = { (dav_namespace, "property"): (0, None) }
-    allowed_attributes = {
-        "name"      : True,
-        "namespace" : False,
-    }
Index: twisted/web2/dav/idav.py
===================================================================
--- twisted/web2/dav/idav.py	(revision 22823)
+++ twisted/web2/dav/idav.py	(working copy)
@@ -1,157 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-web2.dav interfaces.
-"""
-
-__all__ = [ "IDAVResource" ]
-
-from twisted.web2.iweb import IResource
-
-class IDAVResource(IResource):
-    """
-    WebDAV resource.
-    """
-    def isCollection():
-        """
-        Checks whether this resource is a collection resource.
-        @return: C{True} if this resource is a collection resource, C{False}
-            otherwise.
-        """
-
-    def findChildren(depth):
-        """
-        Returns an iterable of child resources for the given depth.
-        Because resources do not know their request URIs, chidren are returned
-        as tuples C{(resource, uri)}, where C{resource} is the child resource
-        and C{uri} is a URL path relative to this resource.
-        @param depth: the search depth (one of C{"0"}, C{"1"}, or C{"infinity"})
-        @return: an iterable of tuples C{(resource, uri)}.
-        """
-
-    def hasProperty(property, request):
-        """
-        Checks whether the given property is defined on this resource.
-        @param property: an empty L{davxml.WebDAVElement} instance or a qname
-            tuple.
-        @param request: the request being processed.
-        @return: a deferred value of C{True} if the given property is set on
-            this resource, or C{False} otherwise.
-        """
-
-    def readProperty(property, request):
-        """
-        Reads the given property on this resource.
-        @param property: an empty L{davxml.WebDAVElement} class or instance, or
-            a qname tuple.
-        @param request: the request being processed.
-        @return: a deferred L{davxml.WebDAVElement} instance
-            containing the value of the given property.
-        @raise HTTPError: (containing a response with a status code of
-            L{responsecode.CONFLICT}) if C{property} is not set on this
-            resource.
-        """
-
-    def writeProperty(property, request):
-        """
-        Writes the given property on this resource.
-        @param property: a L{davxml.WebDAVElement} instance.
-        @param request: the request being processed.
-        @return: an empty deferred which fires when the operation is completed.
-        @raise HTTPError: (containing a response with a status code of
-            L{responsecode.CONFLICT}) if C{property} is a read-only property.
-        """
-
-    def removeProperty(property, request):
-        """
-        Removes the given property from this resource.
-        @param property: a L{davxml.WebDAVElement} instance or a qname tuple.
-        @param request: the request being processed.
-        @return: an empty deferred which fires when the operation is completed.
-        @raise HTTPError: (containing a response with a status code of
-            L{responsecode.CONFLICT}) if C{property} is a read-only property or
-            if the property does not exist.
-        """
-
-    def listProperties(request):
-        """
-        @param request: the request being processed.
-        @return: a deferred iterable of qnames for all properties defined for
-            this resource.
-        """
-
-    def principalCollections():
-        """
-        Provides the URIs of collection resources which contain principal
-        resources which may be used in access control entries on this resource.
-        (RFC 3744, section 5.8)
-        @return: a sequence of URIs referring to collection resources which
-            implement the C{DAV:principal-property-search} C{REPORT}.
-        """
-
-    def accessControlList():
-        """
-        @return: the L{davxml.ACL} element containing the access control list
-            for this resource.
-        """
-
-    def supportedPrivileges():
-        """
-        @return: a sequence of the access control privileges which are
-            supported by this resource.
-        """
-
-class IDAVPrincipalResource (IDAVResource):
-    """
-    WebDAV principal resource.  (RFC 3744, section 2)
-    """
-    def alternateURIs():
-        """
-        Provides the URIs of network resources with additional descriptive
-        information about the principal, for example, a URI to an LDAP record.
-        (RFC 3744, section 4.1)
-        @return: a iterable of URIs.
-        """
-
-    def principalURL():
-        """
-        Provides the URL which must be used to identify this principal in ACL
-        requests.  (RFC 3744, section 4.2)
-        @return: a URL.
-        """
-
-    def groupMembers():
-        """
-        Provides the principal URLs of principals that are direct members of
-        this (group) principal.  (RFC 3744, section 4.3)
-        @return: a iterable of principal URLs.
-        """
-
-    def groupMemberships():
-        """
-        Provides the URLs of the group principals in which the principal is
-        directly a member.  (RFC 3744, section 4.4)
-        @return: a iterable of group principal URLs.
-        """
Index: twisted/web2/dav/noneprops.py
===================================================================
--- twisted/web2/dav/noneprops.py	(revision 22823)
+++ twisted/web2/dav/noneprops.py	(working copy)
@@ -1,65 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-Empty DAV property store.
-
-This API is considered private to static.py and is therefore subject to
-change.
-"""
-
-__all__ = ["NonePropertyStore"]
-
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-
-class NonePropertyStore (object):
-    """
-    DAV property store which contains no properties and does not allow
-    properties to be set.
-    """
-    __singleton = None
-
-    def __new__(clazz, resource):
-        if NonePropertyStore.__singleton is None:
-            NonePropertyStore.__singleton = object.__new__(clazz)
-        return NonePropertyStore.__singleton
-
-    def __init__(self, resource):
-        pass
-
-    def get(self, qname):
-        raise HTTPError(StatusResponse(responsecode.NOT_FOUND, "No such property: {%s}%s" % qname))
-
-    def set(self, property):
-        raise HTTPError(StatusResponse(responsecode.FORBIDDEN, "Permission denied for setting property: %s" % (property,)))
-
-    def delete(self, qname):
-        raise HTTPError(StatusResponse(responsecode.NOT_FOUND, "No such property: {%s}%s" % qname))
-
-    def contains(self, qname):
-        return False
-
-    def list(self):
-        return ()
Index: twisted/web2/dav/xattrprops.py
===================================================================
--- twisted/web2/dav/xattrprops.py	(revision 22823)
+++ twisted/web2/dav/xattrprops.py	(working copy)
@@ -1,142 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-DAV Property store using file system extended attributes.
-
-This API is considered private to static.py and is therefore subject to
-change.
-"""
-
-__all__ = ["xattrPropertyStore"]
-
-import urllib
-import sys
-
-import xattr
-
-if getattr(xattr, 'xattr', None) is None:
-    raise ImportError("wrong xattr package imported")
-
-from twisted.python import log
-from twisted.web2 import responsecode
-from twisted.web2.http import HTTPError, StatusResponse
-from twisted.web2.dav import davxml
-
-class xattrPropertyStore (object):
-    """
-
-    This implementation uses Bob Ippolito's xattr package, available from::
-
-        http://undefined.org/python/#xattr
-
-    Note that the Bob's xattr package is specific to Linux and Darwin, at least
-    presently.
-    """
-    #
-    # Dead properties are stored as extended attributes on disk.  In order to
-    # avoid conflicts with other attributes, prefix dead property names.
-    #
-    deadPropertyXattrPrefix = "WebDAV:"
- 
-    # Linux seems to require that attribute names use a "user." prefix.
-    # FIXME: Is is a system-wide thing, or a per-filesystem thing?
-    #   If the latter, how to we detect the file system?
-    if sys.platform == "linux2":
-        deadPropertyXattrPrefix = "user."
-
-    def _encode(clazz, name):
-        #
-        # FIXME: The xattr API in Mac OS 10.4.2 breaks if you have "/" in an
-        # attribute name (radar://4202440). We'll quote the strings to get rid
-        # of "/" characters for now.
-        #
-        result = list("{%s}%s" % name)
-        for i in range(len(result)):
-            c = result[i]
-            if c in "%/": result[i] = "%%%02X" % (ord(c),)
-        r = clazz.deadPropertyXattrPrefix + ''.join(result)
-        return r
-
-    def _decode(clazz, name):
-        name = urllib.unquote(name[len(clazz.deadPropertyXattrPrefix):])
-
-        index = name.find("}")
-    
-        if (index is -1 or not len(name) > index or not name[0] == "{"):
-            raise ValueError("Invalid encoded name: %r" % (name,))
-    
-        return (name[1:index], name[index+1:])
-
-    _encode = classmethod(_encode)
-    _decode = classmethod(_decode)
-
-    def __init__(self, resource):
-        self.resource = resource
-        self.attrs = xattr.xattr(self.resource.fp.path)
-
-    def get(self, qname):
-        try:
-            value = self.attrs[self._encode(qname)]
-        except KeyError:
-            raise HTTPError(StatusResponse(
-                responsecode.NOT_FOUND,
-                "No such property: {%s}%s" % qname
-            ))
-
-        doc = davxml.WebDAVDocument.fromString(value)
-
-        return doc.root_element
-
-    def set(self, property):
-        #log.msg("Writing property %s on file %s"
-        #        % (property.sname(), self.resource.fp.path))
-
-        self.attrs[self._encode(property.qname())] = property.toxml()
-
-        # Update the resource because we've modified it
-        self.resource.fp.restat()
-
-    def delete(self, qname):
-        #log.msg("Deleting property {%s}%s on file %s"
-        #        % (qname[0], qname[1], self.resource.fp.path))
-
-        try:
-            del(self.attrs[self._encode(qname)])
-        except KeyError:
-            # RFC 2518 Section 12.13.1 says that removal of
-            # non-existing property is not an error.
-            pass
-
-    def contains(self, qname):
-        try:
-            return self._encode(qname) in self.attrs
-        except TypeError:
-            return False
-
-    def list(self):
-        prefix     = self.deadPropertyXattrPrefix
-        prefix_len = len(prefix)
-
-        return [ self._decode(name) for name in self.attrs if name.startswith(prefix) ]
Index: twisted/web2/dav/resource.py
===================================================================
--- twisted/web2/dav/resource.py	(revision 22823)
+++ twisted/web2/dav/resource.py	(working copy)
@@ -1,523 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV resources.
-"""
-
-__all__ = [
-    "DAVPropertyMixIn",
-    "DAVResource",
-    "DAVLeafResource"
-]
-
-import urllib
-
-from zope.interface import implements
-from twisted.python import log
-from twisted.internet.defer import maybeDeferred, succeed
-from twisted.web2 import responsecode
-from twisted.web2.dav import davxml
-from twisted.web2.dav.davxml import dav_namespace, lookupElement
-from twisted.web2.dav.idav import IDAVResource
-from twisted.web2.dav.noneprops import NonePropertyStore
-from twisted.web2.dav.util import unimplemented
-from twisted.web2.http import HTTPError, RedirectResponse, StatusResponse
-from twisted.web2.http_headers import generateContentType
-from twisted.web2.iweb import IResponse
-from twisted.web2.resource import LeafResource
-from twisted.web2.static import MetaDataMixin, StaticRenderMixin
-
-twisted_dav_namespace = "http://twistedmatrix.com/xml_namespace/dav/"
-twisted_private_namespace = "http://twistedmatrix.com/xml_namespace/dav/private/"
-
-class DAVPropertyMixIn (MetaDataMixin):
-    """
-    Mix-in class which implements the DAV property access API in
-    L{IDAVResource}.
-
-    There are three categories of DAV properties, for the purposes of how this
-    class manages them.  A X{property} is either a X{live property} or a
-    X{dead property}, and live properties are split into two categories:
-
-     1. Dead properties.  There are properties that the server simply stores as
-        opaque data.  These are store in the X{dead property store}, which is
-        provided by subclasses via the L{deadProperties} method.
-
-     2. Live properties which are always computed.  These properties aren't
-        stored anywhere (by this class) but instead are derived from the resource
-        state or from data that is persisted elsewhere.  These are listed in the
-        L{liveProperties} attribute and are handled explicitly by the
-        L{readProperty} method.
-
-     3. Live properties may be acted on specially and are stored in the X{dead
-        property store}.  These are not listed in the L{liveProperties} attribute,
-        but may be handled specially by the property access methods.  For
-        example, L{writeProperty} might validate the data and refuse to write
-        data it deems inappropriate for a given property.
-
-    There are two sets of property access methods.  The first group
-    (L{hasProperty}, etc.) provides access to all properties.  They
-    automatically figure out which category a property falls into and act
-    accordingly.
-
-    The second group (L{hasDeadProperty}, etc.) accesses the dead property store
-    directly and bypasses any live property logic that exists in the first group
-    of methods.  These methods are used by the first group of methods, and there
-    are cases where they may be needed by other methods.  I{Accessing dead
-    properties directly should be done with caution.}  Bypassing the live
-    property logic means that values may not be the correct ones for use in
-    DAV requests such as PROPFIND, and may be bypassing security checks.  In
-    general, one should never bypass the live property logic as part of a client
-    request for property data.
-
-    Properties in the L{twisted_private_namespace} namespace are internal to the
-    server and should not be exposed to clients.  They can only be accessed via
-    the dead property store.
-    """
-    # Note:
-    #  The DAV:owner and DAV:group live properties are only meaningful if you
-    # are using ACL semantics (ie. Unix-like) which use them.  This (generic)
-    # class does not.
-
-    liveProperties = (
-        (dav_namespace, "resourcetype"              ),
-        (dav_namespace, "getetag"                   ),
-        (dav_namespace, "getcontenttype"            ),
-        (dav_namespace, "getcontentlength"          ),
-        (dav_namespace, "getlastmodified"           ),
-        (dav_namespace, "creationdate"              ),
-        (dav_namespace, "displayname"               ),
-        (dav_namespace, "supportedlock"             ),
-       #(dav_namespace, "supported-report-set"      ), # RFC 3253, section 3.1.5
-       #(dav_namespace, "owner"                     ), # RFC 3744, section 5.1
-       #(dav_namespace, "group"                     ), # RFC 3744, section 5.2
-       #(dav_namespace, "supported-privilege-set"   ), # RFC 3744, section 5.3
-       #(dav_namespace, "current-user-privilege-set"), # RFC 3744, section 5.4
-       #(dav_namespace, "acl"                       ), # RFC 3744, section 5.5
-        (dav_namespace, "acl-restrictions"          ), # RFC 3744, section 5.6
-       #(dav_namespace, "inherited-acl-set"         ), # RFC 3744, section 5.7
-       #(dav_namespace, "principal-collection-set"  ), # RFC 3744, section 5.8
-
-        (twisted_dav_namespace, "resource-class"),
-    )
-
-    def deadProperties(self):
-        """
-        Provides internal access to the WebDAV dead property store.  You
-        probably shouldn't be calling this directly if you can use the property
-        accessors in the L{IDAVResource} API instead.  However, a subclass must
-        override this method to provide it's own dead property store.
-
-        This implementation returns an instance of L{NonePropertyStore}, which
-        cannot store dead properties.  Subclasses must override this method if
-        they wish to store dead properties.
-
-        @return: a dict-like object from which one can read and to which one can
-            write dead properties.  Keys are qname tuples (ie. C{(namespace, name)})
-            as returned by L{davxml.WebDAVElement.qname()} and values are
-            L{davxml.WebDAVElement} instances.
-        """
-        if not hasattr(self, "_dead_properties"):
-            self._dead_properties = NonePropertyStore(self)
-        return self._dead_properties
-
-    def hasProperty(self, property, request):
-        """
-        See L{IDAVResource.hasProperty}.
-        """
-        if type(property) is tuple:
-            qname = property
-        else:
-            qname = property.qname()
-
-        if qname[0] == twisted_private_namespace:
-            return succeed(False)
-
-        return succeed(qname in self.liveProperties or self.deadProperties().contains(qname))
-
-    def readProperty(self, property, request):
-        """
-        See L{IDAVResource.readProperty}.
-        """
-        def defer():
-            if type(property) is tuple:
-                qname = property
-                sname = "{%s}%s" % property
-            else:
-                qname = property.qname()
-                sname = property.sname()
-
-            namespace, name = qname
-
-            if namespace == dav_namespace:
-                if name == "resourcetype":
-                    # Allow live property to be overriden by dead property
-                    if self.deadProperties().contains(qname):
-                        return self.deadProperties().get(qname)
-                    if self.isCollection():
-                        return davxml.ResourceType.collection
-                    return davxml.ResourceType.empty
-
-                if name == "getetag":
-                    return davxml.GETETag(self.etag().generate())
-
-                if name == "getcontenttype":
-                    mimeType = self.contentType()
-                    mimeType.params = None # WebDAV getcontenttype property does not include parameters
-                    return davxml.GETContentType(generateContentType(mimeType))
-
-                if name == "getcontentlength":
-                    return davxml.GETContentLength(str(self.contentLength()))
-
-                if name == "getlastmodified":
-                    return davxml.GETLastModified.fromDate(self.lastModified())
-
-                if name == "creationdate":
-                    return davxml.CreationDate.fromDate(self.creationDate())
-
-                if name == "displayname":
-                    return davxml.DisplayName(self.displayName())
-
-                if name == "supportedlock":
-                    return davxml.SupportedLock(
-                        davxml.LockEntry(davxml.LockScope.exclusive, davxml.LockType.write),
-                        davxml.LockEntry(davxml.LockScope.shared   , davxml.LockType.write),
-                    )
-
-                if name == "acl-restrictions":
-                    return davxml.ACLRestrictions()
-
-            if namespace == twisted_dav_namespace:
-                if name == "resource-class":
-                    class ResourceClass (davxml.WebDAVTextElement):
-                        namespace = twisted_dav_namespace
-                        name = "resource-class"
-                        hidden = False
-                    return ResourceClass(self.__class__.__name__)
-
-            if namespace == twisted_private_namespace:
-                raise HTTPError(StatusResponse(
-                    responsecode.FORBIDDEN,
-                    "Properties in the %s namespace are private to the server." % (sname,)
-                ))
-
-            return self.deadProperties().get(qname)
-
-        return maybeDeferred(defer)
-
-    def writeProperty(self, property, request):
-        """
-        See L{IDAVResource.writeProperty}.
-        """
-        assert isinstance(property, davxml.WebDAVElement)
-
-        def defer():
-            if property.protected:
-                raise HTTPError(StatusResponse(
-                    responsecode.FORBIDDEN,
-                    "Protected property %s may not be set." % (property.sname(),)
-                ))
-
-            if property.namespace == twisted_private_namespace:
-                raise HTTPError(StatusResponse(
-                    responsecode.FORBIDDEN,
-                    "Properties in the %s namespace are private to the server." % (property.sname(),)
-                ))
-
-            return self.deadProperties().set(property)
-
-        return maybeDeferred(defer)
-
-    def removeProperty(self, property, request):
-        """
-        See L{IDAVResource.removeProperty}.
-        """
-        def defer():
-            if type(property) is tuple:
-                qname = property
-                sname = "{%s}%s" % property
-            else:
-                qname = property.qname()
-                sname = property.sname()
-
-            if qname in self.liveProperties:
-                raise HTTPError(StatusResponse(
-                    responsecode.FORBIDDEN,
-                    "Live property %s cannot be deleted." % (sname,)
-                ))
-
-            if qname[0] == twisted_private_namespace:
-                raise HTTPError(StatusResponse(
-                    responsecode.FORBIDDEN,
-                    "Properties in the %s namespace are private to the server." % (sname,)
-                ))
-
-            return self.deadProperties().delete(qname)
-
-        return maybeDeferred(defer)
-
-    def listProperties(self, request):
-        """
-        See L{IDAVResource.listProperties}.
-        """
-        # FIXME: A set would be better here, that that's a python 2.4+ feature.
-        qnames = list(self.liveProperties)
-
-        for qname in self.deadProperties().list():
-            if (qname not in qnames) and (qname[0] != twisted_private_namespace):
-                qnames.append(qname)
-
-        return succeed(qnames)
-
-    def listAllprop(self, request):
-        """
-        Some DAV properties should not be returned to a C{DAV:allprop} query.
-        RFC 3253 defines several such properties.  This method computes a subset
-        of the property qnames returned by L{listProperties} by filtering out
-        elements whose class have the C{.hidden} attribute set to C{True}.
-        @return: a list of qnames of properties which are defined and are
-            appropriate for use in response to a C{DAV:allprop} query.   
-        """
-        def doList(allnames):
-            qnames = []
-
-            for qname in allnames:
-                try:
-                    if not lookupElement(qname).hidden:
-                        qnames.append(qname)
-                except KeyError:
-                    # Unknown element
-                    qnames.append(qname)
-
-            return qnames
-
-        d = self.listProperties(request)
-        d.addCallback(doList)
-        return d
-
-    def hasDeadProperty(self, property):
-        """
-        Same as L{hasProperty}, but bypasses the live property store and checks
-        directly from the dead property store.
-        """
-        if type(property) is tuple:
-            qname = property
-        else:
-            qname = property.qname()
-
-        return self.deadProperties().contains(qname)
-
-    def readDeadProperty(self, property):
-        """
-        Same as L{readProperty}, but bypasses the live property store and reads
-        directly from the dead property store.
-        """
-        if type(property) is tuple:
-            qname = property
-        else:
-            qname = property.qname()
-
-        return self.deadProperties().get(qname)
-
-    def writeDeadProperty(self, property):
-        """
-        Same as L{writeProperty}, but bypasses the live property store and
-        writes directly to the dead property store.
-        Note that this should not be used unless you know that you are writing
-        to an overrideable live property, as this bypasses the logic which
-        protects protected properties.  The result of writing to a
-        non-overrideable live property with this method is undefined; the value
-        in the dead property store may or may not be ignored when reading the
-        property with L{readProperty}.
-        """
-        self.deadProperties().set(property)
-
-    def removeDeadProperty(self, property):
-        """
-        Same as L{removeProperty}, but bypasses the live property store and acts
-        directly on the dead property store.
-        """
-        if self.hasDeadProperty(property):
-            if type(property) is tuple:
-                qname = property
-            else:
-                qname = property.qname()
-
-            self.deadProperties().delete(qname)
-
-    #
-    # Overrides some methods in MetaDataMixin in order to allow DAV properties
-    # to override the values of some HTTP metadata.
-    #
-    def contentType(self):
-        if self.hasDeadProperty((davxml.dav_namespace, "getcontenttype")):
-            return self.readDeadProperty((davxml.dav_namespace, "getcontenttype")).mimeType()
-        else:
-            return super(DAVPropertyMixIn, self).contentType()
-
-    def displayName(self):
-        if self.hasDeadProperty((davxml.dav_namespace, "displayname")):
-            return str(self.readDeadProperty((davxml.dav_namespace, "displayname")))
-        else:
-            return super(DAVPropertyMixIn, self).displayName()
-
-class DAVResource (DAVPropertyMixIn, StaticRenderMixin):
-    implements(IDAVResource)
-
-    ##
-    # DAV
-    ##
-
-    def davComplianceClasses(self):
-        """
-        This implementation raises L{NotImplementedError}.
-        @return: a sequence of strings denoting WebDAV compliance classes.  For
-            example, a DAV level 2 server might return ("1", "2").
-        """
-        unimplemented(self)
-
-    def isCollection(self):
-        """
-        See L{IDAVResource.isCollection}.
-
-        This implementation raises L{NotImplementedError}; a subclass must
-        override this method.
-        """
-        unimplemented(self)
-
-    def findChildren(self, depth):
-        """
-        See L{IDAVResource.findChildren}.
-
-        This implementation raises returns C{()} if C{depth} is C{0} and this
-        resource is a collection.  Otherwise, it raises L{NotImplementedError};
-        a subclass must override this method.
-        """
-        assert depth in ("0", "1", "infinity"), "Invalid depth: %s" % (depth,)
-        if depth == "0" or not self.isCollection():
-            return ()
-        else:
-            unimplemented(self)
-
-    ##
-    # ACL
-    ##
-
-    def principalCollections(self):
-        """
-        See L{IDAVResource.principalCollections}.
-
-        This implementation returns C{()}.
-        """
-        return ()
-
-    def accessControlList(self):
-        """
-        See L{IDAVResource.accessControlList}.
-
-        This implementation returns an ACL granting all privileges to all
-        principals.
-        """
-        return allACL
-
-    def supportedPrivileges(self):
-        """
-        See L{IDAVResource.supportedPrivileges}.
-
-        This implementation returns a supported privilege set containing only
-        the DAV:all privilege.
-        """
-        return allPrivilegeSet
-
-    ##
-    # HTTP
-    ##
-
-    def renderHTTP(self, request):
-
-        # FIXME: This is for testing with litmus; comment out when not in use
-        #litmus = request.headers.getRawHeaders("x-litmus")
-        #if litmus: log.msg("*** Litmus test: %s ***" % (litmus,))
-
-        # FIXME: Learn how to use twisted logging facility, wsanchez
-        protocol = "HTTP/%s.%s" % request.clientproto
-        log.msg("%s %s %s" % (request.method, urllib.unquote(request.uri), protocol))
-
-        #
-        # If this is a collection and the URI doesn't end in "/", redirect.
-        #
-        if self.isCollection() and request.uri[-1:] != "/":
-            return RedirectResponse(request.uri + "/")
-
-        def setHeaders(response):
-            response = IResponse(response)
-
-            response.headers.setHeader("dav", self.davComplianceClasses())
-
-            #
-            # If this is a collection and the URI doesn't end in "/", add a
-            # Content-Location header.  This is needed even if we redirect such
-            # requests (as above) in the event that this resource was created or
-            # modified by the request.
-            #
-            if self.isCollection() and request.uri[-1:] != "/":
-                response.headers.setHeader("content-location", request.uri + "/")
-
-            return response
-
-        def onError(f):
-            # If we get an HTTPError, run its response through setHeaders() as
-            # well.
-            f.trap(HTTPError)
-            return setHeaders(f.value.response)
-
-        d = maybeDeferred(super(DAVResource, self).renderHTTP, request)
-        return d.addCallbacks(setHeaders, onError)
-
-class DAVLeafResource (DAVResource, LeafResource):
-    """
-    DAV resource with no children.
-    """
-    def findChildren(self, depth):
-        return ()
-
-##
-# Utilities
-##
-
-allACL = davxml.ACL(
-    davxml.ACE(
-        davxml.Principal(davxml.All()),
-        davxml.Grant(davxml.Privilege(davxml.All())),
-        davxml.Protected()
-    )
-)
-
-allPrivilegeSet = davxml.SupportedPrivilegeSet(
-    davxml.SupportedPrivilege(
-        davxml.Privilege(davxml.All()),
-        davxml.Description("all privileges", **{"xml:lang": "en"})
-    )
-)
Index: twisted/web2/dav/static.py
===================================================================
--- twisted/web2/dav/static.py	(revision 22823)
+++ twisted/web2/dav/static.py	(working copy)
@@ -1,183 +0,0 @@
-##
-# Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-# 
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-#
-# DRI: Wilfredo Sanchez, wsanchez@apple.com
-##
-
-"""
-WebDAV-aware static resources.
-"""
-
-__all__ = ["DAVFile"]
-
-from twisted.python import log
-from twisted.web2.static import File
-from twisted.web2.dav import davxml
-from twisted.web2.dav.idav import IDAVResource
-from twisted.web2.dav.resource import DAVResource
-from twisted.web2.dav.util import bindMethods
-
-try:
-    from twisted.web2.dav.xattrprops import xattrPropertyStore as DeadPropertyStore
-except ImportError:
-    log.msg("No dead property store available; using nonePropertyStore.")
-    log.msg("Setting of dead properties will not be allowed.")
-    from twisted.web2.dav.noneprops import NonePropertyStore as DeadPropertyStore
-
-class DAVFile (DAVResource, File):
-    """
-    WebDAV-accessible File resource.
-
-    Extends twisted.web2.static.File to handle WebDAV methods.
-    """
-    def __init__(self, path,
-                 defaultType="text/plain",
-                 indexNames=None):
-        """
-        @param path: the path of the file backing this resource.
-        @param defaultType: the default mime type (as a string) for this
-            resource and (eg. child) resources derived from it.
-        @param indexNames: a sequence of index file names.
-        @param acl: an L{IDAVAccessControlList} with the .
-        """
-        super(DAVFile, self).__init__(path,
-                                      defaultType = defaultType,
-                                      ignoredExts = (),
-                                      processors  = None,
-                                      indexNames  = indexNames)
-
-    def __repr__(self):
-        return "<%s: %s>" % (self.__class__.__name__, self.fp.path)
-
-    ##
-    # WebDAV
-    ##
-
-    def davComplianceClasses(self):
-        return ("1",) # Add "2" when we have locking
-
-    def deadProperties(self):
-        if not hasattr(self, "_dead_properties"):
-            self._dead_properties = DeadPropertyStore(self)
-        return self._dead_properties
-
-    def isCollection(self):
-        """
-        See L{IDAVResource.isCollection}.
-        """
-        for child in self.listChildren(): return True
-        return self.fp.isdir()
-
-    def findChildren(self, depth):
-        """
-        See L{IDAVResource.findChildren}.
-        """
-        assert depth in ("0", "1", "infinity"), "Invalid depth: %s" % (depth,)
-        if depth != "0" and self.isCollection():
-            for name in self.listChildren():
-                try:
-                    child = IDAVResource(self.getChild(name))
-                except TypeError:
-                    child = None
-
-                if child is not None:
-                    if child.isCollection():
-                        yield (child, name + "/")
-                        if depth == "infinity":
-                            for grandchild in child.findChildren(depth):
-                                yield (grandchild[0], name + "/" + grandchild[1])
-                    else:
-                        yield (child, name)
-
-    ##
-    # ACL
-    ##
-
-    def supportedPrivileges(self):
-        if not hasattr(DAVFile, "_supportedPrivilegeSet"):
-            DAVFile._supportedPrivilegeSet = davxml.SupportedPrivilegeSet(
-                davxml.SupportedPrivilege(
-                    davxml.Privilege(davxml.All()),
-                    davxml.Description("all privileges", **{"xml:lang": "en"}),
-                    davxml.SupportedPrivilege(
-                        davxml.Privilege(davxml.Read()),
-                        davxml.Description("read resource", **{"xml:lang": "en"}),
-                    ),
-                    davxml.SupportedPrivilege(
-                        davxml.Privilege(davxml.Write()),
-                        davxml.Description("write resource", **{"xml:lang": "en"}),
-                        davxml.SupportedPrivilege(
-                            davxml.Privilege(davxml.WriteProperties()),
-                            davxml.Description("write resource properties", **{"xml:lang": "en"}),
-                        ),
-                        davxml.SupportedPrivilege(
-                            davxml.Privilege(davxml.WriteContent()),
-                            davxml.Description("write resource content", **{"xml:lang": "en"}),
-                        ),
-                        davxml.SupportedPrivilege(
-                            davxml.Privilege(davxml.Bind()),
-                            davxml.Description("add child resource", **{"xml:lang": "en"}),
-                        ),
-                        davxml.SupportedPrivilege(
-                            davxml.Privilege(davxml.Unbind()),
-                            davxml.Description("remove child resource", **{"xml:lang": "en"}),
-                        ),
-                    ),
-                    davxml.SupportedPrivilege(
-                        davxml.Privilege(davxml.Unlock()),
-                        davxml.Description("unlock resource without ownership", **{"xml:lang": "en"}),
-                    ),
-                    davxml.SupportedPrivilege(
-                        davxml.Privilege(davxml.ReadACL()),
-                        davxml.Description("read resource access control list", **{"xml:lang": "en"}),
-                    ),
-                    davxml.SupportedPrivilege(
-                        davxml.Privilege(davxml.WriteACL()),
-                        davxml.Description("write resource access control list", **{"xml:lang": "en"}),
-                    ),
-                    davxml.SupportedPrivilege(
-                        davxml.Privilege(davxml.ReadCurrentUserPrivilegeSet()),
-                        davxml.Description("read privileges for current principal", **{"xml:lang": "en"}),
-                    ),
-                ),
-            )
-        return DAVFile._supportedPrivilegeSet
-
-    ##
-    # Workarounds for issues with File
-    ##
-
-    def ignoreExt(self, ext):
-        """
-        Does nothing; doesn't apply to this subclass.
-        """
-        pass
-
-    def createSimilarFile(self, path):
-        return self.__class__(path, defaultType=self.defaultType, indexNames=self.indexNames[:])
-
-#
-# Attach method handlers to DAVFile
-#
-
-import twisted.web2.dav.method
-
-bindMethods(twisted.web2.dav.method, DAVFile)
Index: twisted/web2/tap.py
===================================================================
--- twisted/web2/tap.py	(revision 22823)
+++ twisted/web2/tap.py	(working copy)
@@ -7,7 +7,6 @@
 from twisted.plugin import IPlugin
 
 from twisted.web2 import static, iweb, log, server, channel, vhost
-from twisted.web2.dav import static as dav_static
 
 class Options(usage.Options):
     optParameters = [["port", "p", "8080",
@@ -35,10 +34,6 @@
 
     mktap web2 --path=/tmp/
 
-To serve a dav collection:
-
-    mktap web2 --dav=/tmp/
-
 To serve a dynamic resource:
 
     mktap web2 --class=fully.qualified.ClassName
@@ -191,34 +186,6 @@
         classObj = reflect.namedClass(className)
         self['root'].addHost(domain, iweb.IResource(classObj()))
 
-    def opt_vhost_dav(self, virtualHost):
-        """Specify a virtual host in the form of domain=path,
-        to have path served as a DAV collection at the root of
-        domain
-        """
-                
-        if (self['root'] and not \
-            isinstance(self['root'], vhost.NameVirtualHost)):
-
-            raise usage.UsageError("You can only use --vhost-static alone "
-                                   "or with --vhost-class and --vhost-path")
-
-        domain, path = virtualHost.split('=', 1)
-
-        if not self['root']:
-            self['root'] = vhost.NameVirtualHost()
-
-        self['root'].addHost(domain, dav_static.DAVFile(os.path.abspath(path)))
-
-    def opt_dav(self, path):
-        """A path that will be used to serve the root resource as a DAV Collection.
-        """
-
-        if self['root']:
-            raise usage.UsageError("You may only have one root resource")
-        
-        self['root'] = dav_static.DAVFile(os.path.abspath(path))
-    
     def postOptions(self):
         if self['https']:
             try:
