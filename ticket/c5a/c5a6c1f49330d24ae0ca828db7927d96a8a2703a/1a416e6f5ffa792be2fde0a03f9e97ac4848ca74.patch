diff --git a/twisted/web/test/test_wsgi.py b/twisted/web/test/test_wsgi.py
index 4e902e5..e7a003b 100644
--- a/twisted/web/test/test_wsgi.py
+++ b/twisted/web/test/test_wsgi.py
@@ -8,19 +8,20 @@ Tests for L{twisted.web.wsgi}.
 __metaclass__ = type
 
 from sys import exc_info
-from urllib import quote
-from thread import get_ident
-import StringIO, cStringIO, tempfile
+import tempfile
+import traceback
 
 from zope.interface.verify import verifyObject
 
+from twisted.python.compat import intToBytes, urlquote
 from twisted.python.log import addObserver, removeObserver, err
 from twisted.python.failure import Failure
+from twisted.python.threadable import getThreadID
 from twisted.python.threadpool import ThreadPool
 from twisted.internet.defer import Deferred, gatherResults
 from twisted.internet import reactor
 from twisted.internet.error import ConnectionLost
-from twisted.trial.unittest import TestCase
+from twisted.trial.unittest import TestCase, SkipTest
 from twisted.web import http
 from twisted.web.resource import IResource, Resource
 from twisted.web.server import Request, Site, version
@@ -28,6 +29,7 @@ from twisted.web.wsgi import WSGIResource
 from twisted.web.test.test_web import DummyChannel
 
 
+
 class SynchronousThreadPool:
     """
     A single-threaded implementation of part of the L{ThreadPool} interface.
@@ -96,11 +98,11 @@ class WSGIResourceTests(TestCase):
         self.assertRaises(
             RuntimeError,
             self.resource.getChildWithDefault,
-            "foo", Request(DummyChannel(), False))
+            b"foo", Request(DummyChannel(), False))
         self.assertRaises(
             RuntimeError,
             self.resource.putChild,
-            "foo", Resource())
+            b"foo", Resource())
 
 
 class WSGITestsMixin:
@@ -146,28 +148,40 @@ class WSGITestsMixin:
             object for this configuration and request (ie, the environment and
             start_response callable).
         """
+        def _toByteString(string):
+            # Twisted's HTTP implementation prefers byte strings. As a
+            # convenience for tests, string arguments are encoded to an
+            # ISO-8859-1 byte string (if not already) before being passed on.
+            if isinstance(string, bytes):
+                return string
+            else:
+                return string.encode('iso-8859-1')
+
         root = WSGIResource(
             self.reactor, self.threadpool, applicationFactory())
         resourceSegments.reverse()
         for seg in resourceSegments:
             tmp = Resource()
-            tmp.putChild(seg, root)
+            tmp.putChild(_toByteString(seg), root)
             root = tmp
 
         channel = channelFactory()
         channel.site = Site(root)
         request = requestFactory(channel, False)
         for k, v in headers:
-            request.requestHeaders.addRawHeader(k, v)
+            request.requestHeaders.addRawHeader(
+                _toByteString(k), _toByteString(v))
         request.gotLength(0)
         if body:
             request.content.write(body)
             request.content.seek(0)
-        uri = '/' + '/'.join([quote(seg, safe) for seg in requestSegments])
+        uri = '/' + '/'.join([urlquote(seg, safe) for seg in requestSegments])
         if query is not None:
-            uri += '?' + '&'.join(['='.join([quote(k, safe), quote(v, safe)])
+            uri += '?' + '&'.join(['='.join([urlquote(k, safe), urlquote(v, safe)])
                                    for (k, v) in query])
-        request.requestReceived(method, uri, 'HTTP/' + version)
+        request.requestReceived(
+            _toByteString(method), _toByteString(uri),
+            b'HTTP/' + _toByteString(version))
         return request
 
 
@@ -199,7 +213,7 @@ class WSGITestsMixin:
 
 
     def getContentFromResponse(self, response):
-        return response.split('\r\n\r\n', 1)[1]
+        return response.split(b'\r\n\r\n', 1)[1]
 
 
 
@@ -209,7 +223,8 @@ class EnvironTests(WSGITestsMixin, TestCase):
     object by L{twisted.web.wsgi.WSGIResource}.
     """
     def environKeyEqual(self, key, value):
-        def assertEnvironKeyEqual((environ, startResponse)):
+        def assertEnvironKeyEqual(result):
+            environ, startResponse = result
             self.assertEqual(environ[key], value)
         return assertEnvironKeyEqual
 
@@ -220,7 +235,8 @@ class EnvironTests(WSGITestsMixin, TestCase):
         parameter which is exactly of type C{dict}.
         """
         d = self.render('GET', '1.1', [], [''])
-        def cbRendered((environ, startResponse)):
+        def cbRendered(result):
+            environ, startResponse = result
             self.assertIdentical(type(environ), dict)
         d.addCallback(cbRendered)
         return d
@@ -265,7 +281,7 @@ class EnvironTests(WSGITestsMixin, TestCase):
         internal.addCallback(self.environKeyEqual('SCRIPT_NAME', '/foo'))
 
         unencoded = self.render(
-            'GET', '1.1', ['foo', '/', 'bar\xff'], ['foo', '/', 'bar\xff'])
+            'GET', '1.1', ['foo', '/', b'bar\xff'], ['foo', '/', b'bar\xff'])
         # The RFC says "(not URL-encoded)", even though that makes
         # interpretation of SCRIPT_NAME ambiguous.
         unencoded.addCallback(
@@ -302,7 +318,7 @@ class EnvironTests(WSGITestsMixin, TestCase):
         internalContainer = self.render('GET', '1.1', ['foo'], ['foo', ''])
         internalContainer.addCallback(self.environKeyEqual('PATH_INFO', '/'))
 
-        unencoded = self.render('GET', '1.1', [], ['foo', '/', 'bar\xff'])
+        unencoded = self.render('GET', '1.1', [], ['foo', '/', b'bar\xff'])
         unencoded.addCallback(
             self.environKeyEqual('PATH_INFO', '/foo///bar\xff'))
 
@@ -444,7 +460,8 @@ class EnvironTests(WSGITestsMixin, TestCase):
         """
         singleValue = self.render(
             'GET', '1.1', [], [''], None, [('foo', 'bar'), ('baz', 'quux')])
-        def cbRendered((environ, startResponse)):
+        def cbRendered(result):
+            environ, startResponse = result
             self.assertEqual(environ['HTTP_FOO'], 'bar')
             self.assertEqual(environ['HTTP_BAZ'], 'quux')
         singleValue.addCallback(cbRendered)
@@ -541,7 +558,8 @@ class EnvironTests(WSGITestsMixin, TestCase):
         self.addCleanup(removeObserver, events.append)
 
         errors = self.render('GET', '1.1', [], [''])
-        def cbErrors((environ, startApplication)):
+        def cbErrors(result):
+            environ, startApplication = result
             errors = environ['wsgi.errors']
             errors.write('some message\n')
             errors.writelines(['another\nmessage\n'])
@@ -600,7 +618,7 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.read} with no arguments returns the entire input
         stream.
         """
-        bytes = "some bytes are here"
+        bytes = b"some bytes are here"
         d = self._renderAndReturnReaderResult(lambda input: input.read(), bytes)
         d.addCallback(self.assertEqual, bytes)
         return d
@@ -612,9 +630,9 @@ class InputStreamTestMixin(WSGITestsMixin):
         from the input stream, as long as it is less than or equal to the total
         number of bytes available.
         """
-        bytes = "hello, world."
+        bytes = b"hello, world."
         d = self._renderAndReturnReaderResult(lambda input: input.read(3), bytes)
-        d.addCallback(self.assertEqual, "hel")
+        d.addCallback(self.assertEqual, b"hel")
         return d
 
 
@@ -624,7 +642,7 @@ class InputStreamTestMixin(WSGITestsMixin):
         total number of bytes in the input stream returns all bytes in the
         input stream.
         """
-        bytes = "some bytes are here"
+        bytes = b"some bytes are here"
         d = self._renderAndReturnReaderResult(
             lambda input: input.read(len(bytes) + 3), bytes)
         d.addCallback(self.assertEqual, bytes)
@@ -636,7 +654,7 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.read} a second time returns bytes starting from
         the position after the last byte returned by the previous read.
         """
-        bytes = "some bytes, hello"
+        bytes = b"some bytes, hello"
         def read(input):
             input.read(3)
             return input.read()
@@ -650,7 +668,7 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.read} with C{None} as an argument returns all
         bytes in the input stream.
         """
-        bytes = "the entire stream"
+        bytes = b"the entire stream"
         d = self._renderAndReturnReaderResult(
             lambda input: input.read(None), bytes)
         d.addCallback(self.assertEqual, bytes)
@@ -662,7 +680,7 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.read} with a negative integer as an argument
         returns all bytes in the input stream.
         """
-        bytes = "all of the input"
+        bytes = b"all of the input"
         d = self._renderAndReturnReaderResult(
             lambda input: input.read(-1), bytes)
         d.addCallback(self.assertEqual, bytes)
@@ -674,10 +692,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readline} with no argument returns one line from
         the input stream.
         """
-        bytes = "hello\nworld"
+        bytes = b"hello\nworld"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readline(), bytes)
-        d.addCallback(self.assertEqual, "hello\n")
+        d.addCallback(self.assertEqual, b"hello\n")
         return d
 
 
@@ -692,10 +710,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         supports readline with a size argument. If you use it, be aware your
         application may not be portable to other conformant WSGI servers.
         """
-        bytes = "goodbye\nworld"
+        bytes = b"goodbye\nworld"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readline(3), bytes)
-        d.addCallback(self.assertEqual, "goo")
+        d.addCallback(self.assertEqual, b"goo")
         return d
 
 
@@ -704,10 +722,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readline} with an integer which is greater than
         the number of bytes in the next line returns only the next line.
         """
-        bytes = "some lines\nof text"
+        bytes = b"some lines\nof text"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readline(20), bytes)
-        d.addCallback(self.assertEqual, "some lines\n")
+        d.addCallback(self.assertEqual, b"some lines\n")
         return d
 
 
@@ -716,12 +734,12 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readline} a second time returns the line
         following the line returned by the first call.
         """
-        bytes = "first line\nsecond line\nlast line"
+        bytes = b"first line\nsecond line\nlast line"
         def readline(input):
             input.readline()
             return input.readline()
         d = self._renderAndReturnReaderResult(readline, bytes)
-        d.addCallback(self.assertEqual, "second line\n")
+        d.addCallback(self.assertEqual, b"second line\n")
         return d
 
 
@@ -730,10 +748,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readline} with C{None} as an argument returns
         one line from the input stream.
         """
-        bytes = "this is one line\nthis is another line"
+        bytes = b"this is one line\nthis is another line"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readline(None), bytes)
-        d.addCallback(self.assertEqual, "this is one line\n")
+        d.addCallback(self.assertEqual, b"this is one line\n")
         return d
 
 
@@ -742,10 +760,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readline} with a negative integer as an argument
         returns one line from the input stream.
         """
-        bytes = "input stream line one\nline two"
+        bytes = b"input stream line one\nline two"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readline(-1), bytes)
-        d.addCallback(self.assertEqual, "input stream line one\n")
+        d.addCallback(self.assertEqual, b"input stream line one\n")
         return d
 
 
@@ -754,10 +772,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readlines} with no arguments returns a list of
         all lines from the input stream.
         """
-        bytes = "alice\nbob\ncarol"
+        bytes = b"alice\nbob\ncarol"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readlines(), bytes)
-        d.addCallback(self.assertEqual, ["alice\n", "bob\n", "carol"])
+        d.addCallback(self.assertEqual, [b"alice\n", b"bob\n", b"carol"])
         return d
 
 
@@ -767,13 +785,13 @@ class InputStreamTestMixin(WSGITestsMixin):
         returns a list of lines from the input stream with the argument serving
         as an approximate bound on the total number of bytes to read.
         """
-        bytes = "123\n456\n789\n0"
+        bytes = b"123\n456\n789\n0"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readlines(5), bytes)
         def cbLines(lines):
             # Make sure we got enough lines to make 5 bytes.  Anything beyond
             # that is fine too.
-            self.assertEqual(lines[:2], ["123\n", "456\n"])
+            self.assertEqual(lines[:2], [b"123\n", b"456\n"])
         d.addCallback(cbLines)
         return d
 
@@ -784,12 +802,12 @@ class InputStreamTestMixin(WSGITestsMixin):
         the total number of bytes in the input stream returns a list of all
         lines from the input.
         """
-        bytes = "one potato\ntwo potato\nthree potato"
+        bytes = b"one potato\ntwo potato\nthree potato"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readlines(100), bytes)
         d.addCallback(
             self.assertEqual,
-            ["one potato\n", "two potato\n", "three potato"])
+            [b"one potato\n", b"two potato\n", b"three potato"])
         return d
 
 
@@ -799,12 +817,12 @@ class InputStreamTestMixin(WSGITestsMixin):
         returns lines starting at the byte after the last byte returned by the
         C{read} call.
         """
-        bytes = "hello\nworld\nfoo"
+        bytes = b"hello\nworld\nfoo"
         def readlines(input):
             input.read(7)
             return input.readlines()
         d = self._renderAndReturnReaderResult(readlines, bytes)
-        d.addCallback(self.assertEqual, ["orld\n", "foo"])
+        d.addCallback(self.assertEqual, [b"orld\n", b"foo"])
         return d
 
 
@@ -813,10 +831,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readlines} with C{None} as an argument returns
         all lines from the input.
         """
-        bytes = "one fish\ntwo fish\n"
+        bytes = b"one fish\ntwo fish\n"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readlines(None), bytes)
-        d.addCallback(self.assertEqual, ["one fish\n", "two fish\n"])
+        d.addCallback(self.assertEqual, [b"one fish\n", b"two fish\n"])
         return d
 
 
@@ -825,10 +843,10 @@ class InputStreamTestMixin(WSGITestsMixin):
         Calling L{_InputStream.readlines} with a negative integer as an
         argument returns a list of all lines from the input.
         """
-        bytes = "red fish\nblue fish\n"
+        bytes = b"red fish\nblue fish\n"
         d = self._renderAndReturnReaderResult(
             lambda input: input.readlines(-1), bytes)
-        d.addCallback(self.assertEqual, ["red fish\n", "blue fish\n"])
+        d.addCallback(self.assertEqual, [b"red fish\n", b"blue fish\n"])
         return d
 
 
@@ -836,9 +854,9 @@ class InputStreamTestMixin(WSGITestsMixin):
         """
         Iterating over L{_InputStream} produces lines from the input stream.
         """
-        bytes = "green eggs\nand ham\n"
+        bytes = b"green eggs\nand ham\n"
         d = self._renderAndReturnReaderResult(lambda input: list(input), bytes)
-        d.addCallback(self.assertEqual, ["green eggs\n", "and ham\n"])
+        d.addCallback(self.assertEqual, [b"green eggs\n", b"and ham\n"])
         return d
 
 
@@ -848,22 +866,30 @@ class InputStreamTestMixin(WSGITestsMixin):
         produces lines from the input stream starting from the first byte after
         the last byte returned by the C{read} call.
         """
-        bytes = "green eggs\nand ham\n"
+        bytes = b"green eggs\nand ham\n"
         def iterate(input):
             input.read(3)
             return list(input)
         d = self._renderAndReturnReaderResult(iterate, bytes)
-        d.addCallback(self.assertEqual, ["en eggs\n", "and ham\n"])
+        d.addCallback(self.assertEqual, [b"en eggs\n", b"and ham\n"])
         return d
 
 
 
 class InputStreamStringIOTests(InputStreamTestMixin, TestCase):
     """
-    Tests for L{_InputStream} when it is wrapped around a L{StringIO.StringIO}.
+    Tests for L{_InputStream} when it is wrapped around a
+    L{StringIO.StringIO}.
+
+    This is only available in Python 2.
     """
     def getFileType(self):
-        return StringIO.StringIO
+        try:
+            from StringIO import StringIO
+        except ImportError:
+            raise SkipTest("StringIO.StringIO is not available.")
+        else:
+            return StringIO
 
 
 
@@ -871,9 +897,26 @@ class InputStreamCStringIOTests(InputStreamTestMixin, TestCase):
     """
     Tests for L{_InputStream} when it is wrapped around a
     L{cStringIO.StringIO}.
+
+    This is only available in Python 2.
     """
     def getFileType(self):
-        return cStringIO.StringIO
+        try:
+            from cStringIO import StringIO
+        except ImportError:
+            raise SkipTest("cStringIO.StringIO is not available.")
+        else:
+            return StringIO
+
+
+
+class InputStreamBytesIOTests(InputStreamTestMixin, TestCase):
+    """
+    Tests for L{_InputStream} when it is wrapped around an L{io.BytesIO}.
+    """
+    def getFileType(self):
+        from io import BytesIO
+        return BytesIO
 
 
 
@@ -908,7 +951,7 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def cbRendered(ignored):
             self.assertTrue(
                 channel.transport.written.getvalue().startswith(
-                    'HTTP/1.1 107 Strange message'))
+                    b'HTTP/1.1 107 Strange message'))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -939,13 +982,13 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         d, requestFactory = self.requestFactoryFactory()
         def cbRendered(ignored):
             response = channel.transport.written.getvalue()
-            headers, rest = response.split('\r\n\r\n', 1)
-            headerLines = headers.split('\r\n')[1:]
+            headers, rest = response.split(b'\r\n\r\n', 1)
+            headerLines = headers.split(b'\r\n')[1:]
             headerLines.sort()
             allExpectedHeaders = expectedHeaders + [
-                'Date: Tuesday',
-                'Server: ' + version,
-                'Transfer-Encoding: chunked']
+                b'Date: Tuesday',
+                b'Server: ' + version,
+                b'Transfer-Encoding: chunked']
             allExpectedHeaders.sort()
             self.assertEqual(headerLines, allExpectedHeaders)
 
@@ -965,7 +1008,7 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         """
         return self._headersTest(
             [('foo', 'bar'), ('baz', 'quux')],
-            ['Baz: quux', 'Foo: bar'])
+            [b'Baz: quux', b'Foo: bar'])
 
 
     def test_applicationProvidedContentType(self):
@@ -976,7 +1019,7 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         """
         return self._headersTest(
             [('content-type', 'monkeys are great')],
-            ['Content-Type: monkeys are great'])
+            [b'Content-Type: monkeys are great'])
 
 
     def test_applicationProvidedServerAndDate(self):
@@ -1006,13 +1049,13 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def applicationFactory():
             def application(environ, startResponse):
                 startResponse('200 OK', [('foo', 'bar'), ('baz', 'quux')])
-                yield ''
+                yield b''
                 record()
             return application
 
         d, requestFactory = self.requestFactoryFactory()
         def cbRendered(ignored):
-            self.assertEqual(intermediateValues, [''])
+            self.assertEqual(intermediateValues, [b''])
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1038,9 +1081,9 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def applicationFactory():
             def application(environ, startResponse):
                 startResponse('200 OK', [('foo', 'bar')])
-                yield ''
+                yield b''
                 record()
-                yield 'foo'
+                yield b'foo'
                 record()
             return application
 
@@ -1071,9 +1114,9 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def applicationFactory():
             def application(environ, startResponse):
                 startResponse('200 OK', [('content-length', '6')])
-                yield 'foo'
+                yield b'foo'
                 record()
-                yield 'bar'
+                yield b'bar'
                 record()
             return application
 
@@ -1081,10 +1124,10 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def cbRendered(ignored):
             self.assertEqual(
                 self.getContentFromResponse(intermediateValues[0]),
-                'foo')
+                b'foo')
             self.assertEqual(
                 self.getContentFromResponse(intermediateValues[1]),
-                'foobar')
+                b'foobar')
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1113,7 +1156,7 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def cbRendered(ignored):
             self.assertTrue(
                 channel.transport.written.getvalue().startswith(
-                    'HTTP/1.1 200 Bar\r\n'))
+                    b'HTTP/1.1 200 Bar\r\n'))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1141,7 +1184,7 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def cbRendered(ignored):
             self.assertTrue(
                 channel.transport.written.getvalue().startswith(
-                    'HTTP/1.1 100 Foo\r\n'))
+                    b'HTTP/1.1 100 Foo\r\n'))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1173,7 +1216,7 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def applicationFactory():
             def application(environ, startResponse):
                 startResponse('200 OK', [])
-                yield 'foo'
+                yield b'foo'
                 try:
                     startResponse('500 ERR', [], excInfo)
                 except:
@@ -1184,10 +1227,19 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def cbRendered(ignored):
             self.assertTrue(
                 channel.transport.written.getvalue().startswith(
-                    'HTTP/1.1 200 OK\r\n'))
+                    b'HTTP/1.1 200 OK\r\n'))
             self.assertEqual(reraised[0][0], excInfo[0])
             self.assertEqual(reraised[0][1], excInfo[1])
-            self.assertEqual(reraised[0][2].tb_next, excInfo[2])
+
+            # Show that the tracebacks end with the same stack frames.
+            tb1 = reraised[0][2].tb_next
+            tb2 = excInfo[2]
+            self.assertEqual(
+                # On Python 2 (str is bytes) we need to move back only one
+                # stack frame to skip. On Python 3 we need to move two frames.
+                traceback.extract_tb(tb1)[1 if str is bytes else 2],
+                traceback.extract_tb(tb2)[0]
+            )
 
         d.addCallback(cbRendered)
 
@@ -1212,9 +1264,9 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def applicationFactory():
             def application(environ, startResponse):
                 write = startResponse('100 Foo', [('content-length', '6')])
-                write('foo')
+                write(b'foo')
                 record()
-                write('bar')
+                write(b'bar')
                 record()
                 return iter(())
             return application
@@ -1223,10 +1275,10 @@ class StartResponseTests(WSGITestsMixin, TestCase):
         def cbRendered(ignored):
             self.assertEqual(
                 self.getContentFromResponse(intermediateValues[0]),
-                'foo')
+                b'foo')
             self.assertEqual(
                 self.getContentFromResponse(intermediateValues[1]),
-                'foobar')
+                b'foobar')
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1263,7 +1315,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
             def __iter__(self):
                 for i in range(3):
                     if self.open:
-                        yield str(i)
+                        yield intToBytes(i)
 
             def close(self):
                 self.open = False
@@ -1280,7 +1332,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
             self.assertEqual(
                 self.getContentFromResponse(
                     channel.transport.written.getvalue()),
-                '012')
+                b'012')
             self.assertFalse(result.open)
         d.addCallback(cbRendered)
 
@@ -1303,16 +1355,16 @@ class ApplicationTests(WSGITestsMixin, TestCase):
             def application(environ, startResponse):
                 def result():
                     for i in range(3):
-                        invoked.append(get_ident())
-                        yield str(i)
-                invoked.append(get_ident())
+                        invoked.append(getThreadID())
+                        yield intToBytes(i)
+                invoked.append(getThreadID())
                 startResponse('200 OK', [('content-length', '3')])
                 return result()
             return application
 
         d, requestFactory = self.requestFactoryFactory()
         def cbRendered(ignored):
-            self.assertNotIn(get_ident(), invoked)
+            self.assertNotIn(getThreadID(), invoked)
             self.assertEqual(len(set(invoked)), 1)
         d.addCallback(cbRendered)
 
@@ -1333,19 +1385,19 @@ class ApplicationTests(WSGITestsMixin, TestCase):
 
         class ThreadVerifier(Request):
             def write(self, bytes):
-                invoked.append(get_ident())
+                invoked.append(getThreadID())
                 return Request.write(self, bytes)
 
         def applicationFactory():
             def application(environ, startResponse):
                 write = startResponse('200 OK', [])
-                write('foo')
+                write(b'foo')
                 return iter(())
             return application
 
         d, requestFactory = self.requestFactoryFactory(ThreadVerifier)
         def cbRendered(ignored):
-            self.assertEqual(set(invoked), set([get_ident()]))
+            self.assertEqual(set(invoked), set([getThreadID()]))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1365,18 +1417,18 @@ class ApplicationTests(WSGITestsMixin, TestCase):
 
         class ThreadVerifier(Request):
             def write(self, bytes):
-                invoked.append(get_ident())
+                invoked.append(getThreadID())
                 return Request.write(self, bytes)
 
         def applicationFactory():
             def application(environ, startResponse):
                 startResponse('200 OK', [])
-                yield 'foo'
+                yield b'foo'
             return application
 
         d, requestFactory = self.requestFactoryFactory(ThreadVerifier)
         def cbRendered(ignored):
-            self.assertEqual(set(invoked), set([get_ident()]))
+            self.assertEqual(set(invoked), set([getThreadID()]))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1395,7 +1447,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
 
         class ThreadVerifier(Request):
             def setResponseCode(self, code, message):
-                invoked.append(get_ident())
+                invoked.append(getThreadID())
                 return Request.setResponseCode(self, code, message)
 
         def applicationFactory():
@@ -1406,7 +1458,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
 
         d, requestFactory = self.requestFactoryFactory(ThreadVerifier)
         def cbRendered(ignored):
-            self.assertEqual(set(invoked), set([get_ident()]))
+            self.assertEqual(set(invoked), set([getThreadID()]))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1431,7 +1483,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
 
         self.badIter = False
         def appIter():
-            yield "foo"
+            yield b"foo"
             self.badIter = True
             raise Exception("Should not have gotten here")
 
@@ -1466,7 +1518,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
 
             self.assertTrue(
                 channel.transport.written.getvalue().startswith(
-                    'HTTP/1.1 500 Internal Server Error'))
+                    b'HTTP/1.1 500 Internal Server Error'))
         d.addCallback(cbRendered)
 
         self.lowLevelRender(
@@ -1517,7 +1569,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
             self.assertEqual(len(errors), 1)
 
             response = channel.transport.written.getvalue()
-            self.assertTrue(response.startswith('HTTP/1.1 200 OK'))
+            self.assertTrue(response.startswith(b'HTTP/1.1 200 OK'))
             # Chunked transfer-encoding makes this a little messy.
             self.assertIn(responseContent, response)
         d.addErrback(ebRendered)
@@ -1541,7 +1593,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
         logged.
         """
         responseContent = (
-            'Some bytes, triggering the server to start sending the response')
+            b'Some bytes, triggering the server to start sending the response')
 
         def application(environ, startResponse):
             startResponse('200 OK', [])
@@ -1556,7 +1608,7 @@ class ApplicationTests(WSGITestsMixin, TestCase):
         raises an exception when called then the connection is still closed and
         the exception is logged.
         """
-        responseContent = 'foo'
+        responseContent = b'foo'
 
         class Application(object):
             def __init__(self, environ, startResponse):
diff --git a/twisted/web/topfiles/7993.feature b/twisted/web/topfiles/7993.feature
new file mode 100644
index 0000000..48c9b06
--- /dev/null
+++ b/twisted/web/topfiles/7993.feature
@@ -0,0 +1 @@
+twisted.web.wsgi has been ported to Python 3.
diff --git a/twisted/web/wsgi.py b/twisted/web/wsgi.py
index 0918c4d..5d8fac2 100644
--- a/twisted/web/wsgi.py
+++ b/twisted/web/wsgi.py
@@ -3,15 +3,16 @@
 
 """
 An implementation of
-U{Web Resource Gateway Interface<http://www.python.org/dev/peps/pep-0333/>}.
+U{Python Web Server Gateway Interface v1.0.1<http://www.python.org/dev/peps/pep-3333/>}.
 """
 
 __metaclass__ = type
 
 from sys import exc_info
 
-from zope.interface import implements
+from zope.interface import implementer
 
+from twisted.python.compat import reraise
 from twisted.python.log import msg, err
 from twisted.python.failure import Failure
 from twisted.web.resource import IResource
@@ -19,6 +20,94 @@ from twisted.web.server import NOT_DONE_YET
 from twisted.web.http import INTERNAL_SERVER_ERROR
 
 
+
+# PEP-3333 -- which has superseded PEP-333 -- states that, in both Python 2
+# and Python 3, text strings MUST be represented using the platform's native
+# string type, limited to characters defined in ISO-8859-1. Byte strings are
+# used only for values read from wsgi.input, passed to write() or yielded by
+# the application.
+#
+# Put another way:
+#
+# - In Python 2, all text strings and binary data are of type str/bytes and
+#   NEVER of type unicode. Whether the strings contain binary data or
+#   ISO-8859-1 text depends on context.
+#
+# - In Python 3, all text strings are of type str, and all binary data are of
+#   type bytes. Text MUST always be limited to that which can be encoded as
+#   ISO-8859-1, U+0000 to U+00FF inclusive.
+#
+# The following pair of functions -- _wsgiString() and _wsgiStringToBytes() --
+# are used to make Twisted's WSGI support compliant with the standard.
+if str is bytes:
+    def _wsgiString(string):  # Python 2.
+        """
+        Convert C{string} to an ISO-8859-1 byte string, if it is not already.
+
+        @type string: C{str}/C{bytes} or C{unicode}
+        @rtype: C{str}/C{bytes}
+
+        @raise UnicodeEncodeError: If C{string} contains non-ISO-8859-1 chars.
+        """
+        if isinstance(string, str):
+            return string
+        else:
+            return string.encode('iso-8859-1')
+
+    def _wsgiStringToBytes(string):  # Python 2.
+        """
+        Return C{string} if it is a byte string.
+
+        @type string: C{str}/C{bytes}
+        @rtype: C{str}/C{bytes}
+
+        @raise TypeError: If C{string} is not a byte string.
+        """
+        if isinstance(string, str):
+            return string
+        else:
+            raise TypeError(
+                "string must be str/bytes, not %r (%s)"
+                % (string, type(string).__name__))
+
+else:
+    def _wsgiString(string):  # Python 3.
+        """
+        Convert C{string} to a WSGI "bytes-as-unicode" string.
+
+        If it's a byte string, decode as ISO-8859-1. If it's a Unicode string,
+        round-trip it to bytes and back using ISO-8859-1 as the encoding.
+
+        @type string: C{str} or C{bytes}
+        @rtype: str
+
+        @raise UnicodeEncodeError: If C{string} contains non-ISO-8859-1 chars.
+        """
+        if isinstance(string, str):
+            return string.encode("iso-8859-1").decode('iso-8859-1')
+        else:
+            return string.decode("iso-8859-1")
+
+    def _wsgiStringToBytes(string):  # Python 3.
+        """
+        Convert C{string} from a WSGI "bytes-as-unicode" string to an
+        ISO-8859-1 byte string.
+
+        @type string: C{str}
+        @rtype: bytes
+
+        @raise UnicodeEncodeError: If C{string} contains non-ISO-8859-1 chars.
+        @raise TypeError: If C{string} is not a byte string.
+        """
+        if isinstance(string, str):
+            return string.encode("iso-8859-1")
+        else:
+            raise TypeError(
+                "string must be str, not %r (%s)"
+                % (string, type(string).__name__))
+
+
+
 class _ErrorStream:
     """
     File-like object instances of which are used as the value for the
@@ -30,14 +119,23 @@ class _ErrorStream:
     to expose more information in the events it logs, such as the application
     object which generated the message.
     """
-    def write(self, bytes):
+
+    def write(self, data):
         """
         Generate an event for the logging system with the given bytes as the
         message.
 
         This is called in a WSGI application thread, not the I/O thread.
+
+        @type data: str
+
+        @raise TypeError: If C{data} is not a native string.
         """
-        msg(bytes, system='wsgi', isError=True)
+        if not isinstance(data, str):
+            raise TypeError(
+                "write() argument must be str, not %r (%s)"
+                % (data, type(data).__name__))
+        msg(data, system='wsgi', isError=True)
 
 
     def writelines(self, iovec):
@@ -49,6 +147,8 @@ class _ErrorStream:
 
         @param iovec: A C{list} of C{'\\n'}-terminated C{str} which will be
             logged.
+
+        @raise TypeError: If C{iovec} contains any non-native strings.
         """
         self.write(''.join(iovec))
 
@@ -174,33 +274,36 @@ class _WSGIResponse:
         self.request.notifyFinish().addBoth(self._finished)
 
         if request.prepath:
-            scriptName = '/' + '/'.join(request.prepath)
+            scriptName = b'/' + b'/'.join(request.prepath)
         else:
-            scriptName = ''
+            scriptName = b''
 
         if request.postpath:
-            pathInfo = '/' + '/'.join(request.postpath)
+            pathInfo = b'/' + b'/'.join(request.postpath)
         else:
-            pathInfo = ''
+            pathInfo = b''
 
-        parts = request.uri.split('?', 1)
+        parts = request.uri.split(b'?', 1)
         if len(parts) == 1:
-            queryString = ''
+            queryString = b''
         else:
             queryString = parts[1]
 
+        # All keys and values need to be native strings, i.e. of type str in
+        # *both* Python 2 and Python 3, so says PEP-3333.
         self.environ = {
-            'REQUEST_METHOD': request.method,
-            'REMOTE_ADDR': request.getClientIP(),
-            'SCRIPT_NAME': scriptName,
-            'PATH_INFO': pathInfo,
-            'QUERY_STRING': queryString,
-            'CONTENT_TYPE': request.getHeader('content-type') or '',
-            'CONTENT_LENGTH': request.getHeader('content-length') or '',
-            'SERVER_NAME': request.getRequestHostname(),
-            'SERVER_PORT': str(request.getHost().port),
-            'SERVER_PROTOCOL': request.clientproto}
-
+            'REQUEST_METHOD': _wsgiString(request.method),
+            'REMOTE_ADDR': _wsgiString(request.getClientIP()),
+            'SCRIPT_NAME': _wsgiString(scriptName),
+            'PATH_INFO': _wsgiString(pathInfo),
+            'QUERY_STRING': _wsgiString(queryString),
+            'CONTENT_TYPE': _wsgiString(
+                request.getHeader(b'content-type') or ''),
+            'CONTENT_LENGTH': _wsgiString(
+                request.getHeader(b'content-length') or ''),
+            'SERVER_NAME': _wsgiString(request.getRequestHostname()),
+            'SERVER_PORT': _wsgiString(str(request.getHost().port)),
+            'SERVER_PROTOCOL': _wsgiString(request.clientproto)}
 
         # The application object is entirely in control of response headers;
         # disable the default Content-Type value normally provided by
@@ -208,11 +311,11 @@ class _WSGIResponse:
         self.request.defaultContentType = None
 
         for name, values in request.requestHeaders.getAllRawHeaders():
-            name = 'HTTP_' + name.upper().replace('-', '_')
+            name = 'HTTP_' + _wsgiString(name).upper().replace('-', '_')
             # It might be preferable for http.HTTPChannel to clear out
             # newlines.
-            self.environ[name] = ','.join([
-                    v.replace('\n', ' ') for v in values])
+            self.environ[name] = _wsgiString(
+                b','.join(values)).replace('\n', ' ')
 
         self.environ.update({
                 'wsgi.version': (1, 0),
@@ -254,24 +357,78 @@ class _WSGIResponse:
         This will be called in a non-I/O thread.
         """
         if self.started and excInfo is not None:
-            raise excInfo[0], excInfo[1], excInfo[2]
+            reraise(excInfo[1], excInfo[2])
+
+        # PEP-3333 mandates that status should be a native string.
+        if not isinstance(status, str):
+            raise TypeError(
+                "status must be str, not %r (%s)"
+                % (status, type(status).__name__))
+
+        # PEP-3333 mandates a plain list.
+        if not isinstance(headers, list):
+            raise TypeError(
+                "headers must be a list, not %r (%s)"
+                % (status, type(status).__name__))
+
+        # PEP-3333 mandates that each header should be a (str, str) tuple.
+        for header in headers:
+            is_okay = (
+                isinstance(header, tuple) and len(header) == 2 and
+                isinstance(header[0], str) and isinstance(header[1], str)
+            )
+            if not is_okay:
+                raise TypeError(
+                    "header must be (str, str) tuple, not %r"
+                    % (status, type(status).__name__))
+
         self.status = status
         self.headers = headers
         return self.write
 
 
-    def write(self, bytes):
+    def write(self, data):
         """
         The WSGI I{write} callable returned by the I{start_response} callable.
         The given bytes will be written to the response body, possibly flushing
         the status and headers first.
 
         This will be called in a non-I/O thread.
+
+        @raise TypeError: If C{data} is not a byte string.
         """
+        # Check that `data` is bytes now because we will not get any feedback
+        # from callFromThread() later on.
+        if not isinstance(data, bytes):
+            raise TypeError(
+                "write() argument must be bytes, not %r (%s)"
+                % (data, type(data).__name__))
+
         def wsgiWrite(started):
             if not started:
                 self._sendResponseHeaders()
-            self.request.write(bytes)
+            self.request.write(data)
+
+        # PEP-3333 states:
+        #
+        #   The server or gateway must transmit the yielded bytestrings to the
+        #   client in an unbuffered fashion, completing the transmission of
+        #   each bytestring before requesting another one.
+        #
+        # This write() method is used for the imperative and (indirectly) for
+        # the more familiar iterable-of-bytestrings WSGI mechanism, but offers
+        # no back-pressure, and so violates this part of PEP-3333.
+        #
+        # PEP-3333 also says that a server may:
+        #
+        #   Use a different thread to ensure that the block continues to be
+        #   transmitted while the application produces the next block.
+        #
+        # Which suggests that this is actually compliant with PEP-3333,
+        # because writes are done in the reactor thread.
+        #
+        # However, providing some back-pressure may nevertheless be a Good
+        # Thing at some point in the future.
         self.reactor.callFromThread(wsgiWrite, self.started)
         self.started = True
 
@@ -287,12 +444,13 @@ class _WSGIResponse:
         """
         code, message = self.status.split(None, 1)
         code = int(code)
-        self.request.setResponseCode(code, message)
+        self.request.setResponseCode(code, _wsgiStringToBytes(message))
 
         for name, value in self.headers:
             # Don't allow the application to control these required headers.
             if name.lower() not in ('server', 'date'):
-                self.request.responseHeaders.addRawHeader(name, value)
+                self.request.responseHeaders.addRawHeader(
+                    _wsgiStringToBytes(name), _wsgiStringToBytes(value))
 
 
     def start(self):
@@ -341,6 +499,7 @@ class _WSGIResponse:
 
 
 
+@implementer(IResource)
 class WSGIResource:
     """
     An L{IResource} implementation which delegates responsibility for all
@@ -354,7 +513,6 @@ class WSGIResource:
 
     @ivar _application: The WSGI application object.
     """
-    implements(IResource)
 
     # Further resource segments are left up to the WSGI application object to
     # handle.
