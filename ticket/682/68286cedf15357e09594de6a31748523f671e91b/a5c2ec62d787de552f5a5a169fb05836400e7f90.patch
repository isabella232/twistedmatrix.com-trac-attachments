diff --git a/twisted/names/dns.py b/twisted/names/dns.py
index 25f78de..6730ff6 100644
--- a/twisted/names/dns.py
+++ b/twisted/names/dns.py
@@ -47,6 +47,7 @@ __all__ = [
 import warnings
 
 import struct, random, types, socket
+import time
 
 try:
     import cStringIO as StringIO
@@ -83,6 +84,9 @@ NAPTR = 35
 A6 = 38
 DNAME = 39
 
+TKEY = 249
+TSIG = 250
+
 QUERY_TYPES = {
     A: 'A',
     NS: 'NS',
@@ -109,7 +113,10 @@ QUERY_TYPES = {
     SRV: 'SRV',
     NAPTR: 'NAPTR',
     A6: 'A6',
-    DNAME: 'DNAME'
+    DNAME: 'DNAME',
+
+    TKEY: 'TKEY',
+    TSIG: 'TSIG',
 }
 
 IXFR, AXFR, MAILB, MAILA, ALL_RECORDS = range(251, 256)
@@ -1457,7 +1464,190 @@ class Record_TXT(tputil.FancyEqMixin, tputil.FancyStrMixin):
     def __hash__(self):
         return hash(tuple(self.data))
 
+class Record_TSIG(tputil.FancyEqMixin, tputil.FancyStrMixin):
+    """
+    A TSIG signature over the request
+
+    @type mac: C{str}
+    @ivar mac: The signature
+
+    @type algorithm: L{Name}
+    @ivar algorithm: The TKEY algorithm
+
+    @type signed: C{int}
+    @ivar signed: Signature generation time - seconds since 1970
+
+    @type fudge: C{int}
+    @ivar fudge: Allowed clock skew
+
+    @type original_id: C{int}
+    @ivar original_id: ID of the original packet, if it changes
+
+    @type error: C{int}
+    @ivar error: TKEY error status
+
+    @type hashInput: C{str}
+    @ivar hashInput: Data to be input the MAC algorithm - comes from the
+        original packet header & payload prior to the RR. Only valid
+        on TSIG records built by the L{dns.Message} fromStr method
+    """
+
+    implements(IEncodable, IRecord)
+
+    TYPE = 250
+
+    showAttributes = compareAttributes = ('algorithm', 'signed', 'fudge', 'original_id', 'error', 'other', 'mac')
+
+    def __init__(self, mac='', algorithm='gss-tsig', signed=None, fudge=300, original_id=0, error=0, other='', ttl=None):
+        self.ttl = str2time(ttl)
+
+        self.algorithm = Name(algorithm)
+
+        if signed is None:
+            signed = int(time.time())
+        self.signed = signed
+        self.fudge = fudge
+
+        self.original_id = original_id
+        self.error = error
+        self.other = other
+        self.mac = mac
+
+        self.hashInput = None
+
+    _fmt = '!HIHH'
+    _fmtsize = struct.calcsize(_fmt)
+
+    def encode(self, strio, compDict=None):
+        self.algorithm.encode(strio, compDict)
+        strio.write(
+                struct.pack(self._fmt, 0, self.signed, self.fudge, len(self.mac))
+                )
+        strio.write(self.mac)
+        strio.write(
+                struct.pack('!HHH', self.original_id, self.error, len(self.other))
+                )
+        strio.write(self.other)
+
+    def decode(self, strio, length=None):
+        self.algorithm = Name()
+        self.algorithm.decode(strio)
+
+        r = struct.unpack(self._fmt, readPrecisely(strio, self._fmtsize))
+        _ignore, self.signed, self.fudge, maclen = r
+
+        self.mac = readPrecisely(strio, maclen)
+
+        self.original_id, self.error, otherlen = struct.unpack('!HHH', readPrecisely(strio, 6))
+        self.other = readPrecisely(strio, otherlen)
+
+    def signdata(self, rrheader):
+        """
+        Returns the data which must be signed by the TSIG algorithm. For
+        this to work, the record must either have been parsed from the
+        wire by L{Message.fromStr}, or generated by L{Message.makeTsig}
+        so that it has access to the wire encoding.
+
+        You must also supply the enclosing L{RRHeader} for access to the
+        name, cls and ttl attributes.
+
+        Pass this value through your TSIG mechanism and assign the result
+        to the .mac attribute of this object, and your signature is
+        complete.
+        """
+
+        strio = StringIO.StringIO()
+        strio.write(self.hashInput)
+
+        rrheader.name.encode(strio)
+        strio.write(
+                struct.pack('!HI', rrheader.cls, rrheader.ttl)
+                )
+
+        self.algorithm.encode(strio)
+        strio.write(
+                struct.pack('!HIHHH', 0, self.signed, self.fudge, self.error, len(self.other))
+                )
+        strio.write(self.other)
+
+        return strio.getvalue()
+
+class Record_TKEY(tputil.FancyEqMixin, tputil.FancyStrMixin):
+    """
+    A TKEY request or response
+
+    @type key: C{str}
+    @ivar key: The key payload - specific to the algorithm
 
+    @type algorithm: L{Name}
+    @ivar algorithm: The TKEY algorithm
+
+    @type inception: C{int}
+    @ivar inception: Key inception time - seconds since 1970
+
+    @type expiration: C{int}
+    @ivar expiration: Key expiration time - seconds since 1970
+
+    @type mode: C{int}
+    @ivar mode: TKEY mode - 1==HMAC-MD5, 3==GSSAPI
+
+    @type error: C{int}
+    @ivar error: TKEY error status
+    """
+
+    implements(IEncodable, IRecord)
+
+    TYPE = 249
+
+    showAttributes = compareAttributes = ('algorithm', 'inception', 'expiration', 'mode', 'error', 'key', 'other')
+
+    def __init__(self, key=None, algorithm='gss-tsig', inception=None, expiration=None, mode='gssapi', error=0, other='', ttl=None):
+        self.ttl = str2time(ttl)
+
+        self.algorithm = Name(algorithm)
+
+        if inception is None:
+            inception = int(time.time())
+        self.inception = inception
+
+        if expiration is None:
+            expiration = inception + 86400
+        self.expiration = expiration
+
+        if mode=='gssapi':
+            self.mode = 3
+        else:
+            self.mode = mode
+
+        self.error = error
+        self.key = key
+        self.other = other
+
+    _fmt = '!IIHHH'
+    _fmtsize = struct.calcsize(_fmt)
+
+    def encode(self, strio, compDict=None):
+        self.algorithm.encode(strio, compDict)
+        strio.write(
+                struct.pack(self._fmt, self.inception, self.expiration, self.mode, self.error, len(self.key))
+                )
+        strio.write(self.key)
+        strio.write(
+                struct.pack('!H', len(self.other))
+                )
+        strio.write(self.other)
+
+    def decode(self, strio, length=None):
+        self.algorithm = Name()
+        self.algorithm.decode(strio)
+
+        r = struct.unpack(self._fmt, readPrecisely(strio, self._fmtsize))
+        self.inception, self.expiration, self.mode, self.error, keylen = r
+
+        self.key = readPrecisely(strio, keylen)
+
+        otherlen, = struct.unpack('!H', readPrecisely(strio, 2))
+        self.other = readPrecisely(strio, otherlen)
 
 class Message:
     """
@@ -1562,11 +1752,44 @@ class Message:
 
     def parseRecords(self, list, num, strio):
         for i in range(num):
+            # track the record start position so that we can
+            # re-read to this point if it's a TSIG
+            spos = strio.tell()
+
             header = RRHeader()
             try:
                 header.decode(strio)
             except EOFError:
                 return
+
+            # if this is a TSIG record, then
+            # a. it should be the last in the packet FIXME: assert this?
+            # b. we want to save the data up to this point for hash verification
+            if header.type==TSIG:
+                # read the TSIG
+                t = header.payload = Record_TSIG(ttl=header.ttl)
+                header.payload.decode(strio, header.rdlength)
+
+                # note our position
+                pos = strio.tell()
+                strio.seek(0, 0)
+
+                # read the header, change for the values in the TSIG RR
+                hdr = readPrecisely(strio, self.headerSize)
+                id,b3,b4,n0,n1,n2,n3 = struct.unpack(self.headerFmt, hdr)
+                nhdr = struct.pack(self.headerFmt, t.original_id, b3, b4, n0, n1, n2, n3-1)
+
+                # read the rest of the payload up to the start of the TSIG
+                body = readPrecisely(strio, spos - self.headerSize)
+
+                # save the info
+                header.payload.hashInput = nhdr + body
+
+                # back to where we were...
+                strio.seek(0, pos)
+                list.append(header)
+                continue
+
             t = self.lookupRecordType(header.type)
             if not t:
                 continue
@@ -1616,7 +1839,42 @@ class Message:
         strio = StringIO.StringIO(str)
         self.decode(strio)
 
+    def makeTsig(self, name, type=TSIG, cls=ANY, request=None, ttl=0):
+        """
+        This function encodes the message to wire format, stores the wire
+        encoding, then appends a TSIG record to the additional field. The
+        TSIG record has hashInput set correctly.
+
+        If you are signing a reply to a valid-signature request, supply
+        the request to incorporate the request mac into the signature.
+
+        DO NOT MODIFY the request once this is done, except to set fields
+        on the TSIG record itself.
+
+        @return: An L{RRHeader} object, whose payload is a L{Record_TSIG}
+            populated with the correct data. See L{Record_TSIG.signdata}
+        @rtype: L{RRHeader}
+        """
+
+        hashInput = ''
+        if request and request.additional and request.additional[-1].type==TSIG:
+            rtsig = request.additional[-1].payload
+            hashInput += struct.pack('!H', len(rtsig.mac))
+            hashInput += rtsig.mac
+
+        hashInput += self.toStr()
+
+        tsig = Record_TSIG(original_id=self.id)
+        tsig.hashInput = hashInput
+
+        rr = RRHeader(name, type=type, cls=cls, payload=tsig, ttl=ttl)
+
+        self.additional.append(rr)
+
+        # prevent anyone adding anything more to additional - TSIG must come last
+        self.additional = tuple(self.additional)
 
+        return rr
 
 class DNSMixin(object):
     """
diff --git a/twisted/names/test/test_dns.py b/twisted/names/test/test_dns.py
index e8a059f..bfed086 100644
--- a/twisted/names/test/test_dns.py
+++ b/twisted/names/test/test_dns.py
@@ -11,6 +11,7 @@ try:
 except ImportError:
     from StringIO import StringIO
 
+import hmac
 import struct
 
 from twisted.python.failure import Failure
@@ -1214,3 +1215,259 @@ class EqualityTests(unittest.TestCase):
             dns.Record_TXT(['foo', 'bar'], 10),
             dns.Record_TXT(['foo', 'bar'], 10),
             dns.Record_TXT(['foo', 'bar'], 100))
+
+class TkeyTests(unittest.TestCase):
+    """
+    Tests for the TKEY RR
+    """
+
+    def _tkey(self, algorithm='a.b', inception=0, expiration=1, mode=2, error=3, key='k', other='o'):
+        d = ''
+        for p in algorithm.split('.'):
+            d += chr(len(p))
+            d += p
+        d += '\x00'
+
+        d += struct.pack('!IIHH', inception, expiration, mode, error)
+        d += struct.pack('!H', len(key))
+        d += key
+        d += struct.pack('!H', len(other))
+        d += other
+
+        return d
+
+    def test_tkey_decode(self):
+        fields = {
+                'algorithm': 'foo.bar',
+                'inception': 10000,
+                'expiration': 20000,
+                'mode': 2,
+                'key': 'keydata',
+                'other': 'otherdata',
+                'error': 99,
+                }
+        strio = StringIO(
+                self._tkey(**fields)
+                )
+        r = dns.Record_TKEY()
+        r.decode(strio)
+
+        self.assertEquals(r, dns.Record_TKEY(**fields))
+
+    def test_tkey_encode(self):
+        fields = {
+                'algorithm': 'foo.bar',
+                'inception': 10000,
+                'expiration': 20000,
+                'mode': 2,
+                'key': 'keydata',
+                'other': 'otherdata',
+                'error': 99,
+                }
+        strio = StringIO()
+        r = dns.Record_TKEY(**fields)
+        r.encode(strio)
+        v = strio.getvalue()
+
+        self.assertEquals(v, self._tkey(**fields))
+
+class TsigTests(unittest.TestCase):
+    """
+    Tests for the TSIG RR
+    """
+
+    def _tsig(self, mac='mac', algorithm='gss-tsig', signed=0, fudge=300, original_id=0, error=0, other=''):
+        d = ''
+        for p in algorithm.split('.'):
+            d += chr(len(p))
+            d += p
+        d += '\x00'
+
+        d += struct.pack('!HIHH', 0, signed, fudge, len(mac))
+        d += mac
+        d += struct.pack('!HHH', original_id, error, len(other))
+        d += other
+
+        return d
+
+    def test_tsig_decode(self):
+        fields = {
+                'mac': 'SOMEMAC',
+                'algorithm': 'foo.bar',
+                'signed': 1000000,
+                'fudge': 20000,
+                'original_id': 0xdead,
+                'other': 'otherdata',
+                'error': 99,
+                }
+        strio = StringIO(
+                self._tsig(**fields)
+                )
+        r = dns.Record_TSIG()
+        r.decode(strio)
+
+        self.assertEquals(r, dns.Record_TSIG(**fields))
+
+    def test_tsig_encode(self):
+        fields = {
+                'mac': 'SOMEMAC',
+                'algorithm': 'foo.bar',
+                'signed': 1000000,
+                'fudge': 20000,
+                'original_id': 0xdead,
+                'other': 'otherdata',
+                'error': 99,
+                }
+        strio = StringIO()
+        r = dns.Record_TSIG(**fields)
+        r.encode(strio)
+        v = strio.getvalue()
+
+        self.assertEquals(v, self._tsig(**fields))
+
+    def _msg(self, id, b3=0, b4=0, nq=0, nans=0, nauth=0, nadd=0):
+        return struct.pack('!HBBHHHH', id, b3, b4, nq, nans, nauth, nadd)
+
+    def test_tsig_message(self):
+        """
+        TSIG records should be the last in the packet; save the payload
+        up to that point, so we can feed it into the hash verify function
+        """
+
+        fields = {
+                'mac': 'SOMEMAC',
+                'algorithm': 'foo.bar',
+                'signed': 1000000,
+                'fudge': 20000,
+                'original_id': 0xdead,
+                'other': 'otherdata',
+                'error': 99,
+                }
+
+        qry = str(
+            # 1st query
+            '\x04some\x04name\x00'  # some.name
+            '\x00\x06'              # SOA
+            '\x00\x01'              # IN
+            )
+
+        # data we "received" on the wire
+        wire = self._msg(id=1, nq=1, nadd=1)
+        wire += qry
+
+        tsg = self._tsig(**fields)
+        wire += '\x04some\x04name\x00'  # some.name
+        wire += '\x00\xfa'              # TSIG
+        wire += '\x00\xff'              # ANY
+        wire += '\x00\x00\x00\x00'      # ttl=0
+        wire += struct.pack('!H', len(tsg))
+        wire += tsg
+
+        # data that should be in the hash
+        expect = self._msg(id=fields['original_id'], nq=1, nadd=0)
+        expect += qry
+
+        msg = dns.Message()
+        msg.fromStr(wire)
+
+        self.assertEqual(msg.additional, [
+            dns.RRHeader('some.name', type=dns.TSIG, cls=dns.ANY, ttl=0, payload=dns.Record_TSIG(**fields)),
+            ])
+
+        self.assertEqual(msg.additional[0].payload.hashInput, expect)
+
+    def test_makeTsig(self):
+
+        themac = 'themac'
+        macdata = struct.pack('!H', len(themac)) + themac
+
+        # make a request packet with a TSIG & mac
+        request = dns.Message()
+        request.additional.append(
+                dns.RRHeader('foo.bar', type=dns.TSIG, cls=dns.ANY, payload=dns.Record_TSIG(mac=themac))
+                )
+
+
+        # make a response packet
+        response = dns.Message(id=0xbeef, opCode=4)
+        response.queries.append(
+                dns.Query('www.google.com')
+                )
+
+        # save the wire encoding pre-TSIG
+        wire = response.toStr()
+
+        # add the TSIG
+        tsig = response.makeTsig('foo.bar', request=request)
+
+        # mutuate the message ID; TSIG should handle this
+        response.id = 0xdead
+
+        self.assertEqual(
+                tsig.type,
+                dns.TSIG,
+                )
+        self.assertIsInstance(
+                tsig.payload,
+                dns.Record_TSIG,
+                )
+
+        # check that the TSIG hashInput is the request mac & pre-TSIG wire encoding
+        self.assertEqual(
+                tsig.payload.hashInput,
+                macdata + wire,
+                )
+
+        # ok, check that the signdata method returns the right info
+        signdata = macdata + wire
+        signdata += '\x03foo\x03bar\x00'
+        signdata += struct.pack('!HI', tsig.cls, tsig.ttl)
+        signdata += '\x08gss-tsig\x00'
+        signdata += struct.pack('!HIHHH', 0, tsig.payload.signed, tsig.payload.fudge, tsig.payload.error, len(tsig.payload.other))
+        signdata += tsig.payload.other
+
+        self.assertEqual(
+                tsig.payload.signdata(tsig),
+                signdata,
+                )
+
+    def test_hmac_md5(self):
+        # this data generated by external tools e.g.
+        # dig -y testkey:<base64 of 'value'> www.google.com
+        # don't build it manually, whole point is interop!
+        pkt = str(
+                '\xff\xfe'                                      # manually change this!
+                '\x01\x00'
+                '\x00\x01'
+                '\x00\x00'
+                '\x00\x00'
+                '\x00\x01'
+                '\x03www\x06google\x03com\x00\x00\x01\x00\x01'  # www.google.com IN A
+                '\x07testkey\x00\x00\xfa\x00\xff'               # testkey TSIG ANY
+                '\x00\x00\x00\x00'                              # ttl=0
+                '\x00:'                                         # datalen
+                '\x08hmac-md5\x07sig-alg\x03reg\x03int\x00'     # hmac-md5.sig-alg.reg.int
+                '\x00\x00LE\xaa\xd6'                            # signed=Jul 20, 2010 14:55:34.000000000
+                '\x01,'                                         # fudge=300
+                '\x00\x10'                                      # maclen=16
+                '\x87X]Kn\xa5\xb5\xd8;\x08\xcaA\xfc(\xd8\x0b'   # mac
+                '\x87\xea'                                      # origid=34794
+                '\x00\x00'                                      # error
+                '\x00\x00'                                      # otherlen
+                )
+
+        msg = dns.Message()
+        msg.fromStr(pkt)
+
+        tsig = msg.additional[-1]
+        sign = tsig.payload.signdata(tsig)
+
+        h = hmac.HMAC('value')
+        h.update(sign)
+
+        self.assertEqual(
+                h.digest(),
+                '\x87X]Kn\xa5\xb5\xd8;\x08\xcaA\xfc(\xd8\x0b'   # mac
+                )
+        self.assertEqual(tsig.payload.fudge, 300)
+        self.assertEqual(tsig.payload.signed, 1279634134)
