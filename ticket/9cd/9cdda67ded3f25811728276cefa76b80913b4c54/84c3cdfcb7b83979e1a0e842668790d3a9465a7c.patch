diff -r 8b2a31d7b349 twisted/cred/digest.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/twisted/cred/digest.py	Wed Mar 14 16:12:20 2007 +0100
@@ -0,0 +1,892 @@
+# -*- test-case-name: twisted.test.test_digest -*-
+
+"""
+Implementation of RFC 2617: HTTP Digest Authentication
+and RFC 2831: Digest Authentication as a SASL Mechanism,
+with support for RFC 2069 (obsoleted by RFC 2617).
+
+http://tools.ietf.org/html/rfc2617
+http://tools.ietf.org/html/rfc2831
+http://tools.ietf.org/html/rfc2069
+"""
+
+from twisted.cred import credentials, error, sasl
+from twisted.internet import reactor
+
+from zope.interface import implements, Interface, Attribute
+
+import time
+import os
+import md5
+import sha
+import random
+import math
+import weakref
+try:
+    set
+except NameError:
+    from sets import Set as set
+
+
+DEFAULT_METHOD = "AUTHENTICATE"
+DEFAULT_BODY_HASH = "0" * 32
+
+
+def secureRandom(nbytes):
+    """
+    Return a number of (hopefully) secure random bytes.
+
+    @param nbytes: number of bytes to generate.
+    @type nbytes: C{int}.
+    @return: a string of random bytes.
+    @rtype: C{str}.
+    """
+    try:
+        # NOTE: os.urandom is slow on some platforms (10x slower than getrandbits here)
+        bytes = os.urandom(nbytes)
+    except (AttributeError, NotImplementedError):
+        # Why getrandbits() doesn't simply return bytes is beyond me...
+        try:
+            n = random.getrandbits(nbytes * 8)
+            hexBytes = ("%%0%dx" % (nbytes * 2)) % n
+        except AttributeError:
+            # getrandbits() is 2.4+ only
+            lim = 2**32
+            hexBytes = ""
+            for i in range((nbytes + 3) // 4):
+                hexBytes += "%08x" % random.randrange(lim)
+            hexBytes = hexBytes[:nbytes * 2]
+        bytes = hexBytes.decode('hex')
+    return bytes
+
+
+# Fields which shouldn't be quoted
+_unquotedFields = set(["algorithm", "nc", "stale", "response", "rspauth"])
+
+
+def _parseDigest(digestString):
+    """
+    Parses a digest challenge or response.
+    """
+    s = digestString
+    paramDict = {}
+    cur = 0
+    remainingParams = True
+    while remainingParams:
+        # Parse a param. We can't just split on commas, before there can be
+        # some commas inside (quoted) param values, e.g.: qop="auth,auth-int"
+        middle = s.index("=", cur)
+        name = s[cur:middle].lstrip()
+        middle += 1
+        if s[middle] == '"':
+            middle += 1
+            end = s.index('"', middle)
+            value = s[middle:end]
+            cur = s.find(',', end) + 1
+            if cur == 0:
+                remainingParams = False
+        else:
+            end = s.find(',', middle)
+            if end == -1:
+                value = s[middle:].rstrip()
+                remainingParams = False
+            else:
+                value = s[middle:end].rstrip()
+            cur = end + 1
+        paramDict[name] = value
+    return paramDict
+
+def parseChallenge(challenge):
+    """
+    Parses a digest challenge.
+
+    @param challenge: the string representation of the digest challenge or response.
+    @type challenge: C{str}.
+    @return: dictionary of parsed fields.
+    @rtype: C{dict}.
+    """
+    fields = _parseDigest(challenge)
+    if 'qop' in fields:
+        fields['qop'] = fields['qop'].split(',')
+    else:
+        fields['qop'] = []
+    fields['stale'] = (fields.get('stale') == "true")
+    return fields
+
+def parseResponse(response):
+    """
+    Parses a digest response.
+
+    @param response: the string representation of the digest challenge or response.
+    @type response: C{str}.
+    @return: dictionary of parsed fields.
+    @rtype: C{dict}.
+    """
+    return _parseDigest(response)
+
+
+def _unparseDigest(**fields):
+    """
+    Generate the string representation of a digest challenge or response.
+    """
+    q = _unquotedFields
+    s = ", ".join([(k in q and '%s=%s' or '%s="%s"') % (k, v)
+                    for (k, v) in fields.iteritems() if v])
+    return s
+
+def unparseChallenge(**fields):
+    """
+    Generate the string representation of a digest challenge.
+
+    @param fields: dictionary of fields.
+    @type fields: C{dict}.
+    @return: string representation of the challenge.
+    @rtype: C{str}.
+    """
+    qop = fields.pop('qop', None)
+    if qop:
+        fields['qop'] = ','.join(qop)
+    if fields.pop('stale', False):
+        fields['stale'] = 'true'
+    return _unparseDigest(**fields)
+
+def unparseResponse(**fields):
+    """
+    Generate the string representation of a digest response.
+
+    @param fields: dictionary of fields.
+    @type fields: C{dict}.
+    @return: string representation of the response.
+    @rtype: C{str}.
+    """
+    return _unparseDigest(**fields)
+
+
+# The digest math
+
+algorithms = {
+    'md5': md5.new,
+    'md5-sess': md5.new,
+    'sha': sha.new,
+}
+
+# DigestCalcHA1
+def calcHA1(
+    pszAlg,
+    pszUserName,
+    pszRealm,
+    pszPassword,
+    pszNonce,
+    pszCNonce,
+    pszAuthzID=None,
+    preHA1=None
+):
+    """
+    @param pszAlg: The name of the algorithm to use to calculate the digest.
+        Currently supported are md5 md5-sess and sha.
+
+    @param pszUserName: The username
+    @param pszRealm: The realm
+    @param pszPassword: The password
+    @param pszNonce: The nonce
+    @param pszCNonce: The cnonce
+    @param pszAuthzID: The optional authzid (or None)
+
+    @param preHA1: If available this is a str containing a previously
+       calculated HA1 as a hex string. If this is given then the values for
+       pszUserName, pszRealm, and pszPassword are ignored.
+    """
+
+    if (preHA1 and (pszUserName or pszRealm or pszPassword)):
+        raise TypeError(("preHA1 is incompatible with the pszUserName, "
+                         "pszRealm, and pszPassword arguments"))
+
+    if preHA1 is None:
+        # We need to calculate the HA1 from the username:realm:password
+        m = algorithms[pszAlg]()
+        m.update(pszUserName)
+        m.update(":")
+        m.update(pszRealm)
+        m.update(":")
+        m.update(pszPassword)
+        HA1 = m.digest()
+    else:
+        # We were given a username:realm:password
+        HA1 = preHA1.decode('hex')
+
+    if pszAlg == "md5-sess":
+        m = algorithms[pszAlg]()
+        m.update(HA1)
+        m.update(":")
+        m.update(pszNonce)
+        m.update(":")
+        m.update(pszCNonce)
+        if pszAuthzID:
+            m.update(":")
+            m.update(pszAuthzID)
+        HA1 = m.digest()
+
+    return HA1.encode('hex')
+
+def calcDigestHash(
+    pszAlg,
+    pszUserName,
+    pszRealm,
+    pszPassword
+):
+    m = algorithms[pszAlg]()
+    m.update(pszUserName)
+    m.update(":")
+    m.update(pszRealm)
+    m.update(":")
+    m.update(pszPassword)
+    return m.hexdigest()
+
+# DigestCalcResponse
+def calcResponse(
+    HA1,
+    algo,
+    pszNonce,
+    pszNonceCount,
+    pszCNonce,
+    pszQop,
+    pszMethod,
+    pszDigestUri,
+    pszHEntity,
+):
+    m = algorithms[algo]()
+    m.update(pszMethod)
+    m.update(":")
+    m.update(pszDigestUri)
+    if pszQop == "auth-int" or pszQop == "auth-conf":
+        m.update(":")
+        m.update(pszHEntity)
+    HA2 = m.digest().encode('hex')
+
+    m = algorithms[algo]()
+    m.update(HA1)
+    m.update(":")
+    m.update(pszNonce)
+    m.update(":")
+    if pszNonceCount and pszCNonce: # pszQop:
+        m.update(pszNonceCount)
+        m.update(":")
+        m.update(pszCNonce)
+        m.update(":")
+        m.update(pszQop)
+        m.update(":")
+    m.update(HA2)
+    respHash = m.digest().encode('hex')
+    return respHash
+
+
+
+class IDigestMechanism(Interface):
+    """
+    A Digest mechanism.
+    """
+
+    digestURIFieldName = Attribute("""name of the digest URI field""")
+    algorithm = Attribute("""name of digest algorithm""")
+
+    def setClientParams(cnonce, nc, qop, realm=None):
+        """
+        Set the client-supplied digest parameters.
+
+        @param cnonce: the cnonce parameter.
+        @type cnonce: C{str}.
+        @param nc: the nonce-count parameter.
+        @type nc: C{str}.
+        @param qop: the qop parameter (can be None for old-school Digest auth).
+        @type qop: C{str}.
+        @param realm: the realm parameter (can be None if the server supplies one).
+        @type realm: C{str}.
+        """
+
+    def getDigestHash(password):
+        """
+        Get the digest hash from a clear-text password.
+
+        @param password: the clear-text password.
+        @type password: C{str}.
+        @return: the digest hash, in hexadecimal form.
+        @rtype: C{str}.
+        """
+
+    def getResponseFromPassword(password, method=None, bodyHash=None):
+        """
+        Get the digest response from a clear-text password.
+
+        @param password: the clear-text password.
+        @type password: C{str}.
+        @param method: optional method name for integrity checking.
+        @type method: C{str}.
+        @param bodyHash: optional hash of the message body for integrity checking.
+        @type bodyHash: C{str}.
+        @return: digest response in hexadecimal form.
+        @rtype: C{str}.
+        """
+
+    def getResponseFromDigestHash(digestHash, method=None, bodyHash=None):
+        """
+        Get the digest response from a pre-computed digest hash
+        (a hash of "username:realm:password").
+
+        @param digestHash: the pre-computed digest hash in hexadecimal form.
+        @type digestHash: C{str}.
+        @param method: optional method name for integrity checking.
+        @type method: C{str}.
+        @param bodyHash: optional hash of the message body for integrity checking.
+        @type bodyHash: C{str}.
+        @return: digest response in hexadecimal form.
+        @rtype: C{str}.
+        """
+
+
+
+class BaseDigestMechanism(object):
+    def __init__(self, username, uri, fields, authzid=None, algorithm=None):
+        self.charset = 'charset' in fields and 'utf-8' or 'iso-8859-1'
+        self.username = username
+        self.uri = uri
+        self.authzid = authzid
+
+        self.nonce = fields.get('nonce')
+        self.realm = fields.get('realm')
+        self.algorithm = algorithm or self._guessAlgorithm(fields)
+
+        self.lastDigestHash = None
+
+    def setClientParams(self, cnonce, nc, qop, realm=None):
+        self.cnonce = cnonce
+        self.nc = nc
+        self.qop = qop
+        if realm:
+            self.realm = realm
+
+    def getBodyHash(self, body=None):
+        if self.qop == "auth-int" and body is not None:
+            hashAlg = algorithms[self.algorithm]
+            bodyHash = hashAlg(body).hexdigest()
+        else:
+            bodyHash = None
+        return bodyHash
+
+    def getDigestHash(self, password):
+        username, password = self.specialEncode(self.username, password)
+        return calcDigestHash(self.algorithm, username, self.realm, password)
+
+    def getResponseFromPassword(self, password, method=None, bodyHash=None):
+        digestHash = self.getDigestHash(password)
+        return self.getResponseFromDigestHash(digestHash, method, bodyHash)
+
+    def getResponseFromDigestHash(self, digestHash, method=None, bodyHash=None):
+        if method is None:
+            method = DEFAULT_METHOD
+        bodyHash = bodyHash or DEFAULT_BODY_HASH
+        self.lastDigestHash = digestHash
+        return calcResponse(
+            calcHA1(self.algorithm, None, None, None, self.nonce, self.cnonce,
+                pszAuthzID=self.authzid, preHA1=digestHash),
+            self.algorithm, self.nonce, self.nc, self.cnonce, self.qop, method, self.uri, bodyHash
+        )
+
+    def encode(self, s):
+        """
+        If the argument is an unicode string, encode it according to the stored
+        charset parameter.
+
+        @param s: string to be encoded.
+        @type s: C{str} or C{unicode}.
+        @return: encoded string.
+        @rtype: C{str}.
+        """
+        if isinstance(s, unicode):
+            return s.encode(self.charset)
+        return s
+
+    def specialEncode(self, *strings):
+        """
+        Apply the special encoding algorithm as defined in RFC 2831 to the
+        given strings: if the stored charset parameter is utf-8 and all the
+        strings can be encoded to iso-8859-1, then encode them into iso-8859-1.
+        Otherwise, encode them according to the stored charset parameter.
+
+        @param strings: strings to be encoded.
+        @type strings: sequence of C{unicode} or C{str}.
+        @return: list of encoded strings.
+        @rtype: sequence of C{str}.
+        """
+        def _encode(charset):
+            return [isinstance(s, unicode) and s.encode(charset) or s
+                for s in strings]
+        if self.charset == 'utf-8':
+            try:
+                return _encode('iso-8859-1')
+            except UnicodeEncodeError:
+                pass
+        return _encode(self.charset)
+
+
+class SASLDigestMechanism(BaseDigestMechanism):
+    """
+    The SASL Digest mechanism (as per RFC 2831).
+    """
+    implements(IDigestMechanism)
+    digestURIFieldName = "digest-uri"
+
+    def _guessAlgorithm(self, fields):
+        return "md5-sess"
+
+class HTTPDigestMechanism(BaseDigestMechanism):
+    """
+    The HTTP Digest mechanism (as per RFC 2617).
+    """
+    implements(IDigestMechanism)
+    digestURIFieldName = "uri"
+
+    def _guessAlgorithm(self, fields):
+        return fields.get('algorithm', 'MD5').lower()
+
+
+# TODO: add IIntegrityChecker for the "auth-int" case
+
+class IUsernameDigestHash(Interface):
+    """
+    This credential is used when a CredentialChecker has access to the hash
+    of the username:realm:password as in an Apache .htdigest file.
+    """
+    def checkHash(digestHash):
+        """
+        @param digestHash: The hashed username:realm:password to check against.
+
+        @return: a deferred which becomes, or a boolean indicating if the
+            hash matches.
+        """
+
+class DigestedCredentials(object):
+    """
+    Credentials from a SASL Digest response.
+    """
+
+    implements(credentials.IUsernameHashedPassword, sasl.IAuthzID,
+               IUsernameDigestHash)
+    # Needs fixing cred.portal bug with inherited interfaces first
+    #implements(sasl.ISASLCredentials, IUsernameDigestHash)
+
+    def __init__(self, mechanism, response, method=None, bodyHash=None):
+        self.mechanism = mechanism
+        self.username = self.mechanism.username
+        self.authzid = self.mechanism.authzid
+        self.response = response
+        self.method = method
+        self.bodyHash = bodyHash
+        self.rspauth = None
+
+    def checkPassword(self, password):
+        digestHash = self.mechanism.getDigestHash(password)
+        return self.checkHash(digestHash)
+
+    def checkHash(self, digestHash):
+        expected = self.mechanism.getResponseFromDigestHash(
+            digestHash, self.method, self.bodyHash)
+        if expected == self.response:
+            # rspauth is generated by using the same parameters, except method
+            # which is the empty string.
+            # XXX I'm not sure if the bodyHash is the current one or the one
+            # for the message containing the successful challenge.
+            # The distinction is irrelevant for SASL but not for HTTP.
+            self.rspauth = self.mechanism.getResponseFromDigestHash(
+                digestHash, "", self.bodyHash)
+            return True
+        return False
+
+
+class BaseDigestResponder(object):
+    def __init__(self, username, password, realm=None, authzid=None):
+        """
+        Construct a digest responder. You can pass an optional default realm
+        (e.g. a domain name for the username) which will be used if the server
+        doesn't specify one.
+
+        @param username: username to authenticate with.
+        @type username: C{str} or C{unicode}.
+        @param password: password to authenticate with.
+        @type password: C{str} or C{unicode}.
+        @param realm: optional realm.
+        @type realm: C{str}.
+        @param authzid: optional authorization ID.
+        @type authzid: C{str}.
+        """
+        self.username = username
+        self.password = password
+        self.realm = realm
+        self.authzid = authzid
+        self.cnonce = None
+        self.nonceCount = 1
+        self.prevNonce = None
+        self.lastMechanism = None
+
+    def getResponse(self, challenge, uri, method=None, body=None):
+        """
+        Process a server challenge.
+        Returns a tuple of the challenge type and the response to be sent (if any).
+        The challenge type gives the protocol a hint as to what policy to adopt:
+        - if instance of InitialChallenge, there was no previous successful
+          authentication. If it is the second InitialChallenge in a row, then
+          perhaps it is time to ask the user another password.
+        - if instance of ChallengeRenewal, the server refused the previous
+          response because the challenge we responded to was too old. Sending a
+          new response without re-asking for a password is recommended.
+        - if instance of FinalChallenge, authentication was successful on both
+          sides.
+
+        @param challenge: server challenge.
+        @type challenge: C{str}.
+        @param uri: the URI to authenticate against.
+        @type uri: C{str}.
+        @param method: optional method for message integrity.
+        @type method: C{str}.
+        @param body: optional body for message integrity.
+        @type body: C{str}.
+        @return: tuple of L{ChallengeType}, (C{str} or None).
+        """
+        f = parseChallenge(challenge)
+        rspauth = f.get('rspauth')
+        if rspauth:
+            # Final challenge: rspauth will be checked with the same parameters
+            # as the previous response
+            chalType = sasl.FinalChallenge()
+            method = ""
+            mechanism = self.lastMechanism
+            if not mechanism:
+                raise sasl.UnexpectedFinalChallenge("Unexpected final challenge.")
+        else:
+            # Non-final challenge: extract parameters and build mechanism
+            realm = f.get('realm') or self.realm
+            if not realm:
+                raise sasl.InvalidChallenge("Missing realm value.")
+            if f['stale']:
+                chalType = sasl.ChallengeRenewal()
+            else:
+                chalType = sasl.InitialChallenge()
+
+            mechanism = self.mechanismClass(username=self.username,
+                uri=uri, fields=f, authzid=self.authzid)
+
+            qop = self._chooseQop(f['qop'], method, body)
+            nonce = f['nonce']
+            if qop:
+                cnonce = self.cnonce
+                if cnonce is None:
+                    cnonce = sha.new(secureRandom(20)).hexdigest()
+                    self.cnonce = cnonce
+                # XXX is this robust enough?
+                if nonce == self.prevNonce:
+                    self.nonceCount += 1
+                else:
+                    self.nonceCount = 1
+                    self.prevNonce = nonce
+                nc = "%08X" % self.nonceCount
+            else:
+                # Fallback on old-school Digest mechanism
+                cnonce = None
+                nc = None
+            mechanism.setClientParams(cnonce, nc, qop, realm)
+            self.lastMechanism = mechanism
+
+        bodyHash = mechanism.getBodyHash(body)
+        digestResponse = mechanism.getResponseFromPassword(self.password, method, bodyHash)
+
+        if rspauth:
+            if rspauth != digestResponse:
+                raise sasl.FailedChallenge("Invalid final challenge: wrong rspauth value.")
+            return chalType, None
+
+        respFields = {
+            'username': mechanism.encode(self.username),
+            'realm' : mechanism.realm,
+            'nonce' : nonce,
+            'cnonce' : cnonce,
+            'nc' : nc,
+            'qop' : qop,
+            mechanism.digestURIFieldName: uri,
+            'response': digestResponse,
+        }
+        for s in 'charset', 'opaque':
+            if s in f:
+                respFields[s] = f[s]
+        if self.authzid:
+            respFields['authzid'] = self.authzid
+        return chalType, unparseResponse(**respFields)
+
+    def _chooseQop(self, chalQops, method=None, body=None):
+        # XXX factor out choice of qop in concrete mechanism?
+        if "auth-int" in chalQops and (body is not None or "auth" not in chalQops):
+            return "auth-int"
+        elif "auth" in chalQops:
+            return "auth"
+        else:
+            return None
+
+
+class SASLDigestResponder(BaseDigestResponder):
+    """
+    An SASL Digest authentication responder.
+    """
+    implements(sasl.ISASLResponder)
+    mechanismClass = SASLDigestMechanism
+
+    def getInitialResponse(self, uri):
+        return None
+
+    # Override method to have the correct signature (without optional arguments)
+    def getResponse(self, challenge, uri):
+        return BaseDigestResponder.getResponse(self, challenge, uri)
+
+class HTTPDigestResponder(BaseDigestResponder):
+    """
+    An HTTP Digest authentication responder.
+    """
+    mechanismClass = HTTPDigestMechanism
+
+
+class NonceSlot(object):
+    """
+    Contains a nonce-count, an IDelayedCall and a weakref to its creator.
+    """
+    def __init__(self, dc, container):
+        self.nc = 0
+        def _destroyed(_, dc=dc):
+            if dc.active():
+                dc.cancel()
+        self._ref = weakref.ref(container, _destroyed)
+
+
+class BaseDigestChallenger(object):
+    CHALLENGE_LIFETIME_SECS = 15 * 60    # 15 minutes
+
+    _callLater = reactor.callLater
+
+    def __init__(self, realm=None):
+        """
+        @param realm: case sensitive string that specifies the realm portion
+            of the challenge. If None, any realm will be accepted.
+        @type realm: C{str}
+        """
+        self.realm = realm
+        self.nonces = {}
+
+    def processResponse(self, response, method=None, body=None):
+        """
+        Process the response from the client and return credentials for checking
+        the password. It can also return None if the challenge responded to is
+        too old, in which case you'll have to generate a new one with
+        getRenewedChallenge().
+
+        @param challenge: server challenge.
+        @type challenge: C{str}.
+        @param method: optional method for message integrity.
+        @type method: C{str}.
+        @param body: optional body for message integrity.
+        @type body: C{str}.
+        @return: credentials.
+        @rtype: L{twisted.cred.credentials.IUsernameHashedPassword}.
+        """
+        f = parseResponse(response)
+        nonce = f.get('nonce')
+        if not nonce:
+            raise sasl.InvalidResponse('Missing once.')
+        realm = f.get('realm')
+        if self.realm and realm != self.realm:
+            raise sasl.InvalidResponse("Invalid realm '%s'" % realm)
+        username = f.get('username')
+        if not username:
+            raise sasl.InvalidResponse("Missing username.")
+        digestResponse = f.get('response')
+        if not digestResponse:
+            raise sasl.InvalidResponse("Missing digest response.")
+        digestURI = f.get('digest-uri') or f.get('uri')
+        if not digestURI:
+            raise sasl.InvalidResponse("Missing digest URI.")
+        cnonce = f.get('cnonce')
+        nc = f.get('nc')
+        qop = f.get('qop')
+        if not qop and not self.acceptWeakDigest:
+            raise sasl.InvalidResponse("Missing qop value")
+        if qop and qop != "auth" and qop != "auth-int":
+            raise sasl.InvalidResponse("Invalid qop value '%s'" % qop)
+        if qop and (not nc or not cnonce):
+            raise sasl.InvalidResponse("Missing nc and/or cnonce value.")
+        algo = f.get('algorithm')
+        if algo and algo != self.algorithm:
+            raise sasl.InvalidResponse("Invalid algorithm '%s'" % algo)
+        authzid = f.get('authzid')
+
+        if not self.acceptNonce(nonce, nc or None):
+            return None
+
+        mechanism = self.mechanismClass(username=username, authzid=authzid,
+            uri=digestURI, fields=f, algorithm=self.algorithm)
+        mechanism.setClientParams(cnonce, nc, qop)
+
+        bodyHash = mechanism.getBodyHash(body)
+        return DigestedCredentials(mechanism, digestResponse, method, bodyHash)
+
+    def getChallenge(self):
+        """
+        Get a challenge to send the client.
+
+        @return: server challenge.
+        @rtype: C{str}.
+        """
+        f = self._getAuthChallenge()
+        return unparseChallenge(**f)
+
+    def getSuccessfulChallenge(self, response, cred):
+        """
+        Get the final challenge, i.e. when auth when successful.
+        Returns None if the particular SASL mechanism doesn't define a final challenge.
+
+        @param response: latest successful response.
+        @type response: C{str}.
+        @param response: credentials of the successful response (as returned by
+            processResponse()).
+        @type response: L{twisted.cred.credentials.IUsernameHashedPassword}.
+        @return: server challenge.
+        @rtype: C{str}.
+        """
+        # XXX we assume that cred is an instance of DigestedCredentials,
+        # and that cred.rspauth is not None.
+        if not cred.mechanism.qop:
+            # No rspauth for RFC 2069, don't bother with nextnonce et al.
+            return None
+        f = { 'rspauth': cred.rspauth }
+        return unparseChallenge(**f)
+
+    def getRenewedChallenge(self, response):
+        """
+        Get a renewed challenge to send the client (i.e. when received a response
+        to an expired challenge).
+
+        @param response: response received to the previous challenge.
+        @type response: C{str}.
+        @return: server challenge.
+        @rtype: C{str}.
+        """
+        f = self._getAuthChallenge()
+        f['stale'] = True
+        return unparseChallenge(**f)
+
+    def generateNonce(self):
+        """
+        Generate a nonce to be sent as part of the challenge.
+        This is an unique string that can be returned to us and verified,
+        but unpredictable by an attacker.
+
+        @return: nonce.
+        @rtype: C{str}.
+        """
+        while True:
+            nonce = "%d.%s" % (self._getTime(), sha.new(secureRandom(20)).hexdigest())
+            if nonce not in self.nonces:
+                break
+        # The following function object must not contain any reference to self
+        def _nonceExpired(nonces, nonce):
+            del nonces[nonce]
+        dc = self._callLater(self.CHALLENGE_LIFETIME_SECS, _nonceExpired,
+            self.nonces, nonce)
+        self.nonces[nonce] = NonceSlot(dc, self)
+        return nonce
+
+    def acceptNonce(self, nonce, nc=None):
+        """
+        Given the nonce from the client response, verify that the nonce is
+        fresh enough and that the nonce-count is appropriate.
+        Returns True if the nonce is accepted, False if the challenge is not fresh enough,
+        raises an error if the nonce or nonce-count is invalid (e.g. faked).
+        If True is returned, the nc value is eaten and trying to reuse it will
+        raise an error (protection against replays).
+
+        This method is implicitly called by processResponse().
+
+        @param nonce: nonce value from the Digest response
+        @type nonce: C{str}.
+        @param nc: nonce-count value from the Digest response
+        @type nc: C{str}.
+        @return: True if the nonce is fresh enough.
+        @rtype: C{bool}.
+        @raise L{twisted.cred.error.LoginFailed}
+        """
+        try:
+            timestamp, seed = nonce.split(".")
+            timestamp = int(timestamp)
+        except ValueError:
+            raise sasl.InvalidResponse("Invalid nonce value")
+
+        age = self._getTime() - timestamp
+        if age > self.CHALLENGE_LIFETIME_SECS - 1:
+            return False
+        if age < 0:
+            raise sasl.InvalidResponse("Invalid nonce value")
+
+        # We check the nc only if the nonce is fresh, because otherwise the
+        # entry in self.nonces will have been deleted.
+        nonceSlot = self.nonces.get(nonce)
+        if nonceSlot is None:
+            raise sasl.InvalidResponse("Invalid nonce value.")
+        if nc is not None:
+            if int(nc, 16) != nonceSlot.nc + 1:
+                raise sasl.InvalidResponse("Invalid nc value.")
+            nonceSlot.nc += 1
+
+        return True
+
+    def _getAuthChallenge(self):
+        nonce = self.generateNonce()
+        f = {
+            'nonce': nonce,
+            'qop': ['auth', 'auth-int'],
+            'algorithm': self.algorithm,
+        }
+        if self.realm:
+            f['realm'] = self.realm
+        self._populateChallenge(f)
+        return f
+
+    def _getTime(self):
+        """
+        Parameterize the time based seed used in _generateNonce()
+        so we can deterministically unittest it's behavior.
+        """
+        return time.time()
+
+
+class SASLDigestChallenger(BaseDigestChallenger):
+    """
+    An SASL Digest challenger generates challenges and processes responses from a client.
+    """
+    implements(sasl.ISASLChallenger)
+    mechanismClass = SASLDigestMechanism
+    acceptWeakDigest = False
+    algorithm = "md5-sess"
+
+    # Override method to have the correct signature (without optional arguments)
+    def processResponse(self, response):
+        return BaseDigestChallenger.processResponse(self, response)
+
+    def _populateChallenge(self, fields):
+        fields['charset'] = 'utf-8'
+
+
+class HTTPDigestChallenger(BaseDigestChallenger):
+    """
+    An HTTP Digest challenger generates challenges and processes responses from a client.
+    """
+    mechanismClass = HTTPDigestMechanism
+    # Required to support RFC 2069-only clients
+    acceptWeakDigest = True
+    algorithm = "md5"
+
+    def _populateChallenge(self, fields):
+        fields['opaque'] = '0'
diff -r 8b2a31d7b349 twisted/cred/plain.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/twisted/cred/plain.py	Wed Mar 14 15:50:49 2007 +0100
@@ -0,0 +1,123 @@
+# -*- test-case-name: twisted.test.test_plain -*-
+
+"""
+Implementation of RFC 4616: PLAIN SASL Mechanism.
+
+http://tools.ietf.org/html/rfc4616
+"""
+
+from twisted.cred import credentials, error, sasl
+
+from zope.interface import implements
+
+
+def _encode(s, charset):
+    if isinstance(s, unicode):
+        return s.encode(charset)
+    return s
+
+
+class PlainCredentials(object):
+    """
+    Credentials from a SASL PLAIN response.
+    """
+
+    implements(credentials.IUsernamePassword, sasl.IAuthzID)
+    # Needs fixing cred.portal bug with inherited interfaces first
+    #implements(credentials.IUsernamePassword, sasl.ISASLCredentials)
+
+    def __init__(self, username, password, authzid=None):
+        self.username = username
+        self.password = password
+        # Convert empty string to None
+        self.authzid = authzid or None
+
+    def checkPassword(self, password):
+        return password == self.password
+
+
+class SASLPlainResponder(object):
+    """
+    An SASL PLAIN authentication responder.
+    """
+    implements(sasl.ISASLResponder)
+
+    charset = 'utf-8'
+
+    def __init__(self, username, password, authzid=None):
+        """
+        Construct a digest responder. You can pass an optional default realm
+        (e.g. a domain name for the username) which will be used if the server
+        doesn't specify one.
+
+        @param username: username to authenticate with.
+        @type username: C{str} or C{unicode}.
+        @param password: password to authenticate with.
+        @type password: C{str} or C{unicode}.
+        @param authzid: optional authorization ID.
+        @type authzid: C{str}.
+        """
+        self.username = username
+        self.password = password
+        self.authzid = authzid
+
+    def getInitialResponse(self, uri):
+        return self._getResponse()
+
+    def getResponse(self, challenge, uri):
+        resp = self._getResponse()
+        return sasl.InitialChallenge(), resp
+
+    def _getResponse(self):
+        """
+        Compute the actual PLAIN authentication string.
+
+        @return: authentication string.
+        @rtype: C{str}.
+        """
+        # XXX add support for authentication without authzid?
+        # (seen in twisted.mail.smtp)
+        resp = "\0".join(map(lambda s: _encode(s, self.charset),
+            [self.authzid or "", self.username, self.password]))
+        return resp
+
+
+
+class SASLPlainChallenger(object):
+    """
+    An SASL PLAIN authentication challenger.
+    """
+    implements(sasl.ISASLChallenger)
+
+    charset = 'utf-8'
+
+    def __init__(self):
+        pass
+
+    def processResponse(self, response):
+        try:
+            authzid, username, password = response.split('\0')
+        except ValueError:
+            raise sasl.InvalidResponse("Invalid SASL PLAIN response.")
+        if not username:
+            raise sasl.InvalidResponse("Missing username.")
+        # XXX should we allow an empty password?
+        if not password:
+            raise sasl.InvalidResponse("Missing password.")
+        try:
+            authzid, username, password = map(lambda s: s.decode(self.charset),
+                [authzid, username, password])
+        except UnicodeDecodeError:
+            raise sasl.InvalidResponse("Cannot decode SASL PLAIN response to %s." % self.charset)
+        return PlainCredentials(username, password, authzid)
+
+    def getChallenge(self):
+        return None
+
+    def getSuccessfulChallenge(self, response, cred):
+        return None
+
+    def getRenewedChallenge(self, response):
+        return None
+
+
diff -r 8b2a31d7b349 twisted/cred/sasl.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/twisted/cred/sasl.py	Wed Mar 14 14:45:11 2007 +0100
@@ -0,0 +1,171 @@
+"""
+Interfaces for SASL mechanisms.
+"""
+
+from twisted.cred import credentials, error
+
+from zope.interface import Interface, Attribute
+
+
+class SASLError(error.LoginFailed):
+    """
+    A generic SASL error.
+    """
+
+class InvalidResponse(SASLError):
+    """
+    A response contains invalid (e.g. missing or mismatching) values.
+    """
+
+class InvalidChallenge(SASLError):
+    """
+    A challenge contains invalid (e.g. missing or mismatching) values.
+    """
+
+class FailedChallenge(SASLError):
+    """
+    Verification of an SASL challenge failed.
+    (e.g. for a final Digest challenge with a wrong rspauth value).
+    """
+
+class UnexpectedFinalChallenge(InvalidChallenge):
+    """
+    A final challenge has been received but no response was previously sent.
+    """
+
+
+class IAuthzID(Interface):
+    """
+    I encapsulate an authorization ID.
+
+    This credential is used when an authentication mechanism optionally provides
+    an authorization ID as part as the authentication process. This authorization
+    ID can be checked and used so as to decide which identity is requested.
+
+    @type authzid: C{str} or None
+    @ivar authzid: optional authorization ID.
+    """
+
+class ISASLCredentials(credentials.IUsernameHashedPassword, IAuthzID):
+    """
+    An SASL credential.
+    """
+
+
+
+# Design note: we could use singleton instances for ChallengeTypes returned
+# by ISASLResponder.getResponse(), but we may want to add information to the
+# returned instances in the future. For example, about the level of integrity
+# provided, etc.
+
+class ChallengeType(object):
+    """
+    An SASL challenge type.
+    """
+
+class InitialChallenge(ChallengeType):
+    """
+    An SASL initial challenge.
+    """
+
+class ChallengeRenewal(ChallengeType):
+    """
+    An SASL challenge renewal.
+    """
+
+class FinalChallenge(ChallengeType):
+    """
+    An SASL final challenge.
+    """
+
+
+
+class ISASLResponder(Interface):
+    """
+    An SASL responder responds to challenges sent by an auth server.
+
+    Note: the "method" and "body" parameters for response-getting methods
+    are optional, they are only useful for certain pre-SASL authentication
+    mechanisms (e.g. HTTP Digest).
+    """
+
+    def getInitialResponse(uri):
+        """
+        Get the initial client response, if defined for this mechanism.
+
+        @return: initial client response string, or None.
+        @rtype: C{str}.
+        """
+
+    def getResponse(challenge, uri):
+        """
+        Process a server challenge.
+        Returns a tuple of the challenge type and the response to be sent (if any).
+        The challenge type gives the protocol a hint as to what policy to adopt:
+        - if instance of InitialChallenge, there was no previous successful
+          authentication. If it is the second InitialChallenge in a row, then
+          perhaps it is time to ask the user another password.
+        - if instance of ChallengeRenewal, the server refused the previous
+          response because the challenge we responded to was too old. Sending a
+          new response without re-asking for a password is recommended.
+        - if instance of FinalChallenge, authentication was successful on both
+          sides.
+
+        @param challenge: server challenge.
+        @type challenge: C{str}.
+        @param uri: the URI to authenticate against.
+        @type uri: C{str}.
+        @return: tuple of L{ChallengeType}, (C{str} or None).
+        """
+
+
+class ISASLChallenger(Interface):
+    """
+    An SASL challenger generates challenges and processes responses from a client.
+    """
+
+    def processResponse(response):
+        """
+        Process the response from the client and return credentials for checking
+        the password. It can also return None if the challenge responded to is
+        too old, in which case you'll have to generate a new one with
+        getRenewedChallenge().
+
+        @param challenge: server challenge.
+        @type challenge: C{str}.
+        @return: credentials.
+        @rtype: L{ISASLCredentials}.
+        """
+
+    def getChallenge():
+        """
+        Get a challenge to send the client.
+
+        @return: server challenge.
+        @rtype: C{str}.
+        """
+
+    def getRenewedChallenge(response):
+        """
+        Get a renewed challenge to send the client (i.e. when received a response
+        to an expired challenge).
+
+        @param response: response received to the previous challenge.
+        @type response: C{str}.
+        @return: server challenge.
+        @rtype: C{str}.
+        """
+
+    def getSuccessfulChallenge(self, response, credentials):
+        """
+        Get the final challenge, i.e. when auth when successful.
+        Returns None if the particular SASL mechanism doesn't define a final challenge.
+
+        @param response: latest successful response.
+        @type response: C{str}.
+        @param credentials: credentials of the successful response (as returned by
+            processResponse()).
+        @type credentials: L{ISASLCredentials}.
+        @return: server challenge.
+        @rtype: C{str}.
+        """
diff -r 8b2a31d7b349 twisted/test/test_digest.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/twisted/test/test_digest.py	Wed Mar 14 16:17:00 2007 +0100
@@ -0,0 +1,801 @@
+
+from twisted.internet import task
+from twisted.trial import unittest
+from twisted.cred import error, sasl, digest
+
+import os
+import random
+import time
+
+# XXX see http://jakarta.apache.org/commons/httpclient/xref-test/org/apache/commons/httpclient/auth/TestDigestAuth.html
+# for inspiration?
+
+
+# From http://rfc.net/rfc2617.html#p6
+quotedWWWChallenge = """realm="testrealm@host.com", \
+qop="auth,auth-int", \
+nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", \
+opaque="5ccc069c403ebaf9f0171e9517f40e41" """
+
+mixquotedWWWChallenge = """realm="testrealm@host.com",\
+nonce="00e2855b3f047bfd3297e720498e4571",opaque="00e04875776e15b",\
+stale=true , algorithm=MD5 """
+
+# an SASL challenge with qop=auth
+chal1 = """realm="elwood.innosoft.com",nonce="OA6MG9tEQGm2hh",qop="auth",\
+algorithm=md5-sess,charset=utf-8"""
+
+resp1 = """charset=utf-8,username="chris",realm="elwood.innosoft.com",\
+nonce="OA6MG9tEQGm2hh",nc=00000001,cnonce="OA6MHXh6VqTrRk",\
+digest-uri="imap/elwood.innosoft.com",\
+response=d388dad90d4bbd760a152321f2143af7,qop=auth"""
+
+final1 = """rspauth=ea40f60335c427b5527b84dbabcdfffd"""
+
+# an HTTP challenge with qop=auth
+chal2 = """realm="testrealm@host.com",\
+qop="auth,auth-int",
+nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
+opaque="5ccc069c403ebaf9f0171e9517f40e41"\
+"""
+
+resp2 = """username="Mufasa", \
+realm="testrealm@host.com", \
+nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",\
+uri="/dir/index.html", \
+qop=auth,\
+nc=00000001, \
+cnonce="0a4f113b", \
+response="6629fae49393a05397450978507c4ef1", \
+opaque="5ccc069c403ebaf9f0171e9517f40e41"\
+"""
+
+# a SIP challenge without qop
+chal3 = """realm="voip.wengo.fr",nonce="0115a73e3d7bbad83eb238c35e2756fa",\
+opaque="00e04875776e15b" """
+
+# an SASL challenge with qop=auth-int
+# inspired from http://www.sendmail.org/~ca/email/authrealms.html
+# XXX there was no realm in the original example challenge...
+chal4 = """nonce="AJRUc5Jx0UQbv5SJ9FoyUnaZpqZIHDhLTU+Awn/K0Uw=",\
+qop="auth-int,auth-conf",charset=utf-8,algorithm=md5-sess"""
+
+resp4 = """username="test",realm="wiz.example.com",\
+nonce="AJRUc5Jx0UQbv5SJ9FoyUnaZpqZIHDhLTU+Awn/K0Uw=",\
+cnonce="AJRUc5Jx0UQbv5SJ9FoyUnaZpqZIHDhLTU+Awn/K0Uw=",\
+nc=00000001,qop=auth-int,charset=utf-8,digest-uri="smtp/localhost.sendmail.com.",
+response=0e7cfcae717eeac972fc9d5606a1083d"""
+
+
+
+class SecureRandomTestCase(unittest.TestCase):
+    def _check(self):
+        for nbytes in range(17, 25):
+            s = digest.secureRandom(nbytes)
+            self.assertEquals(len(s), nbytes)
+            s2 = digest.secureRandom(nbytes)
+            self.assertEquals(len(s2), nbytes)
+            # This is crude but hey
+            self.assertNotEquals(s2, s)
+
+    def test_normal(self):
+        """
+        Test secureRandom() in normal conditions (os.urandom).
+        """
+        self._check()
+
+    def test_withoutUrandom(self):
+        """
+        Test secureRandom() without os.urandom.
+        """
+        old_urandom = getattr(os, "urandom", None)
+        try:
+            if old_urandom:
+                del os.urandom
+            self._check()
+        finally:
+            if old_urandom:
+                os.urandom = old_urandom
+
+    def test_withoutUrandomAndGetrandbits(self):
+        """
+        Test secureRandom() with neither os.urandom nor random.getrandbits.
+        """
+        old_urandom = getattr(os, "urandom", None)
+        old_getrandbits = getattr(random, "getrandbits", None)
+        try:
+            if old_urandom:
+                del os.urandom
+            if old_getrandbits:
+                del random.getrandbits
+            self._check()
+        finally:
+            if old_urandom:
+                os.urandom = old_urandom
+            if old_getrandbits:
+                random.getrandbits = old_getrandbits
+
+    def test_unimplemented(self):
+        """
+        Test secureRandom() with unimplemented os.urandom.
+        """
+        old_urandom = getattr(os, "urandom", None)
+        try:
+            def my_urandom(_):
+                raise NotImplementedError
+            os.urandom = my_urandom
+            self._check()
+        finally:
+            if old_urandom:
+                os.urandom = old_urandom
+            else:
+                del os.urandom
+
+
+class ChallengeParseTestCase(unittest.TestCase):
+    def _roundTrip(self, fields):
+        chal = digest.unparseChallenge(**fields)
+        f = digest.parseChallenge(chal)
+        self.assertEquals(f, fields)
+
+    def test_parseWWWQuoted(self):
+        """
+        Various levels of quoting.
+        """
+        f = digest.parseChallenge(quotedWWWChallenge)
+        self.assertEquals(f, {
+            'realm': "testrealm@host.com",
+            'qop': ["auth","auth-int"],
+            'nonce': "dcd98b7102dd2f0e8b11d0f600bfb0c093",
+            'opaque': "5ccc069c403ebaf9f0171e9517f40e41",
+            'stale': False,
+        })
+        self._roundTrip(f)
+
+    def test_parseWWWMixquoted(self):
+        """
+        Various levels of quoting (2).
+        """
+        f = digest.parseChallenge(mixquotedWWWChallenge)
+        self.assertEquals(f, {
+            'realm': "testrealm@host.com",
+            'nonce': "00e2855b3f047bfd3297e720498e4571",
+            'opaque': "00e04875776e15b",
+            'algorithm': "MD5",
+            'qop': [],
+            'stale': True,
+        })
+        self._roundTrip(f)
+
+    def test_parseStaleTrue(self):
+        """
+        Explicit stale=true.
+        """
+        f = digest.parseChallenge('realm="testrealm@host.com",stale=true')
+        self.assertEquals(f['stale'], True)
+        self._roundTrip(f)
+
+    def test_parseStaleFalse(self):
+        """
+        Explicit stale=false.
+        """
+        f = digest.parseChallenge('realm="testrealm@host.com",stale=false')
+        self.assertEquals(f['stale'], False)
+        self._roundTrip(f)
+
+    def test_parseStaleAbsent(self):
+        """
+        Implicit stale=false.
+        """
+        f = digest.parseChallenge('realm="testrealm@host.com"')
+        self.assertEquals(f['stale'], False)
+        self._roundTrip(f)
+
+    def test_parseSASLChal(self):
+        """
+        A real SASL challenge.
+        """
+        f = digest.parseChallenge(chal1)
+        self.assertEquals(f, {
+            'realm': "elwood.innosoft.com",
+            'nonce': "OA6MG9tEQGm2hh",
+            'qop': ["auth"],
+            'algorithm': "md5-sess",
+            'charset': "utf-8",
+            'stale': False,
+        })
+        self._roundTrip(f)
+
+    def test_parseHTTPChal(self):
+        """
+        A real HTTP challenge.
+        """
+        f = digest.parseChallenge(chal2)
+        self.assertEquals(f, {
+            'realm': "testrealm@host.com",
+            'qop': ["auth", "auth-int"],
+            'nonce': "dcd98b7102dd2f0e8b11d0f600bfb0c093",
+            'opaque': "5ccc069c403ebaf9f0171e9517f40e41",
+            'stale': False,
+        })
+        self._roundTrip(f)
+
+    def test_parseFinalChal(self):
+        """
+        A real final (rspauth) challenge.
+        """
+        f = digest.parseChallenge(final1)
+        self.assertEquals(f, {
+            'rspauth': "ea40f60335c427b5527b84dbabcdfffd",
+            'qop': [],
+            'stale': False,
+        })
+
+class ResponseParseTestCase(unittest.TestCase):
+    def _roundTrip(self, fields):
+        resp = digest.unparseResponse(**fields)
+        f = digest.parseResponse(resp)
+        self.assertEquals(f, fields)
+
+    def test_parseSASLResp(self):
+        """
+        A real SASL response.
+        """
+        f = digest.parseResponse(resp1)
+        self.assertEquals(f, {
+            'charset': 'utf-8',
+            'username': "chris",
+            'realm': "elwood.innosoft.com",
+            'nonce': "OA6MG9tEQGm2hh",
+            'nc': '00000001',
+            'cnonce': "OA6MHXh6VqTrRk",
+            'digest-uri': "imap/elwood.innosoft.com",
+            'response': "d388dad90d4bbd760a152321f2143af7",
+            'qop': 'auth',
+        })
+        self._roundTrip(f)
+
+    def test_parseWWWResp(self):
+        """
+        A real HTTP response.
+        """
+        f = digest.parseResponse(resp2)
+        self.assertEquals(f, {
+            'username': "Mufasa",
+            'realm': "testrealm@host.com",
+            'nonce': "dcd98b7102dd2f0e8b11d0f600bfb0c093",
+            'uri': "/dir/index.html",
+            'qop': "auth",
+            'nc': "00000001",
+            'cnonce': "0a4f113b",
+            'response': "6629fae49393a05397450978507c4ef1",
+            'opaque': "5ccc069c403ebaf9f0171e9517f40e41",
+        })
+        self._roundTrip(f)
+
+
+class HTTPMechanismTestCase(unittest.TestCase):
+    def test_responseFromPassword(self):
+        """
+        Generate digest response from password.
+        """
+        fields = digest.parseChallenge(chal2)
+        mech = digest.HTTPDigestMechanism("Mufasa", "/dir/index.html", fields)
+        mech.setClientParams("0a4f113b", "00000001", "auth")
+        r = mech.getResponseFromPassword("Circle Of Life", "GET")
+        self.assertEquals(r, "6629fae49393a05397450978507c4ef1")
+
+class SASLMechanismTestCase(unittest.TestCase):
+    def test_responseFromPassword(self):
+        """
+        Generate digest response from password.
+        """
+        fields = digest.parseChallenge(chal1)
+        mech = digest.SASLDigestMechanism("chris", "imap/elwood.innosoft.com", fields)
+        mech.setClientParams("OA6MHXh6VqTrRk", "00000001", "auth")
+        r = mech.getResponseFromPassword("secret")
+        self.assertEquals(r, "d388dad90d4bbd760a152321f2143af7")
+        # rspauth
+        r = mech.getResponseFromPassword("secret", method="")
+        self.assertEquals(r, "ea40f60335c427b5527b84dbabcdfffd")
+
+
+#
+# Test responders
+#
+
+class _BaseResponderTestCase(object):
+    def _checkResponseToChallenge(self, resp, chal, checkDict):
+        f2 = digest.parseResponse(resp)
+        f = digest.parseChallenge(chal)
+        for s in 'nonce', 'realm', 'opaque':
+            if s in f:
+                self.assertEquals(f2[s], f[s])
+        for k, v in checkDict.items():
+            if v is not None:
+                self.assertEquals(f2[k], v)
+            else:
+                self.assertTrue(k not in f2)
+        return f2
+
+
+class HTTPResponderTestCase(_BaseResponderTestCase, unittest.TestCase):
+    def test_latinUsername(self):
+        """
+        Username with non-ASCII characters and no charset parameter.
+        """
+        checkDict = {
+            'charset': None,
+            'username': "andr\xe9",
+        }
+        # Unicode username
+        responder = digest.HTTPDigestResponder(
+            username=u"andr\u00e9", password="Circle Of Life")
+        responder.cnonce = "1234"
+        chalType, unparsed = responder.getResponse(chal2, uri="/dir/index.html", method="GET")
+        f = self._checkResponseToChallenge(unparsed, chal2, checkDict)
+        # Already encoded username
+        responder = digest.HTTPDigestResponder(
+            username="andr\xe9", password="Circle Of Life")
+        responder.cnonce = "1234"
+        chalType, unparsed = responder.getResponse(chal2, uri="/dir/index.html", method="GET")
+        f2 = self._checkResponseToChallenge(unparsed, chal2, checkDict)
+        self.assertEquals(f['response'], f2['response'])
+
+    def test_respondMD5Auth(self):
+        """
+        Generate response for algorithm=MD5 and qop=auth.
+        """
+        checkDict = {
+            'charset': None,
+            'uri': "/dir/index.html",
+            'nonce': "dcd98b7102dd2f0e8b11d0f600bfb0c093",
+            'cnonce': "0a4f113b",
+            'nc': "00000001",
+            'qop': "auth",
+            'username': "Mufasa",
+            'response': "6629fae49393a05397450978507c4ef1",
+        }
+        responder = digest.HTTPDigestResponder(
+            username="Mufasa", password="Circle Of Life")
+        responder.cnonce = "0a4f113b"
+        chalType, unparsed = responder.getResponse(chal2, uri="/dir/index.html", method="GET")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        self._checkResponseToChallenge(unparsed, chal2, checkDict)
+        # Subsequent auth increments nc
+        chalType, unparsed = responder.getResponse(chal2, uri="/dir/index.html", method="GET")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        checkDict['nc'] = "00000002"
+        del checkDict['response']
+        f = self._checkResponseToChallenge(unparsed, chal2, checkDict)
+        self.assertNotEquals(f['response'], "6629fae49393a05397450978507c4ef1")
+
+    def test_respondMD5WithoutQop(self):
+        """
+        Support for RFC 2069 servers (no qop).
+        """
+        checkDict = {
+            'charset': None,
+            'uri': "sip:voip.wengo.fr",
+            'nonce': "0115a73e3d7bbad83eb238c35e2756fa",
+            'cnonce': None,
+            'nc': None,
+            'qop': None,
+            'username': "robobob5003",
+            'response': "3727aec655653050494b164f1a483769",
+        }
+        responder = digest.HTTPDigestResponder(
+            username="robobob5003", password="spameggs")
+        chalType, unparsed = responder.getResponse(chal3, uri="sip:voip.wengo.fr", method="REGISTER")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        self._checkResponseToChallenge(unparsed, chal3, checkDict)
+        # Subsequent auth returns same response
+        chalType, unparsed = responder.getResponse(chal3, uri="sip:voip.wengo.fr", method="REGISTER")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        self._checkResponseToChallenge(unparsed, chal3, checkDict)
+
+class SASLResponderTestCase(_BaseResponderTestCase, unittest.TestCase):
+    def test_noAuthzid(self):
+        """
+        No authzid in response by default.
+        """
+        responder = digest.SASLDigestResponder(username="chris", password="secret")
+        chalType, unparsed = responder.getResponse(chal1, uri="/")
+        f = digest.parseResponse(unparsed)
+        self.assertEquals(f.get('authzid'), None)
+
+    def test_authzid(self):
+        """
+        Authzid in response if specified.
+        """
+        responder = digest.SASLDigestResponder(username="chris", password="secret",
+            authzid="paul")
+        chalType, unparsed = responder.getResponse(chal1, uri="/")
+        f = digest.parseResponse(unparsed)
+        self.assertEquals(f.get('authzid'), "paul")
+
+    def test_latinUsernameAndPassword(self):
+        """
+        Username/password with iso-8859-1 characters and charset=utf-8 parameter.
+        The username will be encoded in utf-8 in the response, but its hash will
+        be taken in iso-8859-1 form. Weird :-)
+        """
+        checkDict = {
+            'charset': 'utf-8',
+            'username': "andr\xc3\xa9",
+        }
+        # Unicode username and password
+        responder = digest.SASLDigestResponder(
+            username=u"andr\u00e9", password=u"h\u00e9")
+        responder.cnonce = "1234"
+        chalType, unparsed = responder.getResponse(chal1, uri="/dir/index.html")
+        f = self._checkResponseToChallenge(unparsed, chal1, checkDict)
+        # ISO-8859-1 encoded username and password
+        responder = digest.SASLDigestResponder(
+            username="andr\xe9", password="h\xe9")
+        responder.cnonce = "1234"
+        chalType, unparsed = responder.getResponse(chal1, uri="/dir/index.html")
+        f2 = digest.parseResponse(unparsed)
+        self.assertEquals(f['response'], f2['response'])
+
+    def test_unicodeUsernameAndPassword(self):
+        """
+        Username/password with non iso-8859-1 characters and charset=utf-8 parameter.
+        """
+        checkDict = {
+            'charset': 'utf-8',
+            'username': "andr\xc3\xa9",
+        }
+        # Unicode username and password
+        responder = digest.SASLDigestResponder(
+            username=u"andr\u00e9", password=u"\u0101")
+        responder.cnonce = "1234"
+        chalType, unparsed = responder.getResponse(chal1, uri="/dir/index.html")
+        f = self._checkResponseToChallenge(unparsed, chal1, checkDict)
+        # Already encoded username and password (UTF-8)
+        responder = digest.SASLDigestResponder(
+            username="andr\xc3\xa9", password="\xc4\x81")
+        responder.cnonce = "1234"
+        chalType, unparsed = responder.getResponse(chal1, uri="/dir/index.html")
+        f2 = self._checkResponseToChallenge(unparsed, chal1, checkDict)
+        self.assertEquals(f['response'], f2['response'])
+
+    def test_respondMD5SessAuth(self):
+        """
+        Generate response for algorithm=md5-sess and qop=auth.
+        """
+        checkDict = {
+            'charset': "utf-8",
+            'digest-uri': "imap/elwood.innosoft.com",
+            'nonce': "OA6MG9tEQGm2hh",
+            'cnonce': "OA6MHXh6VqTrRk",
+            'nc': "00000001",
+            'qop': "auth",
+            'username': "chris",
+            'response': "d388dad90d4bbd760a152321f2143af7",
+        }
+        responder = digest.SASLDigestResponder(username="chris", password="secret")
+        responder.cnonce = "OA6MHXh6VqTrRk"
+        chalType, unparsed = responder.getResponse(chal1, uri="imap/elwood.innosoft.com")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        self._checkResponseToChallenge(unparsed, chal1, checkDict)
+        # Subsequent auth increments nc
+        chalType, unparsed = responder.getResponse(chal1, uri="imap/elwood.innosoft.com")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        checkDict['nc'] = "00000002"
+        del checkDict['response']
+        f = self._checkResponseToChallenge(unparsed, chal1, checkDict)
+        self.assertNotEquals(f['response'], "d388dad90d4bbd760a152321f2143af7")
+
+    def test_respondMD5SessAuthFinal(self):
+        """
+        Generate rspauth for algorithm=md5-sess and qop=auth.
+        """
+        responder = digest.SASLDigestResponder(username="chris", password="secret")
+        responder.cnonce = "OA6MHXh6VqTrRk"
+        responder.getResponse(chal1, uri="imap/elwood.innosoft.com")
+        chalType, unparsed = responder.getResponse(final1, uri="imap/elwood.innosoft.com")
+        self.assertTrue(isinstance(chalType, sasl.FinalChallenge))
+        self.assertTrue(unparsed is None)
+        # Bad rspauth
+        self.assertRaises(error.LoginFailed, responder.getResponse,
+            "rspauth=0", uri="imap/elwood.innosoft.com")
+
+    def test_respondMD5SessAuthInt(self):
+        """
+        Generate response for algorithm=md5-sess, qop=auth-int, and without realm.
+        """
+        checkDict = {
+            'charset': "utf-8",
+            'digest-uri': "smtp/localhost.sendmail.com.",
+            'nonce': "AJRUc5Jx0UQbv5SJ9FoyUnaZpqZIHDhLTU+Awn/K0Uw=",
+            'cnonce': "AJRUc5Jx0UQbv5SJ9FoyUnaZpqZIHDhLTU+Awn/K0Uw=",
+            'nc': "00000001",
+            'qop': "auth-int",
+            'username': "test",
+            'response': "780c0451303666e1ea9a24de7b5eb08b",
+        }
+        responder = digest.SASLDigestResponder(username="test", password="tEst42",
+            realm="wiz.example.com")
+        responder.cnonce = "AJRUc5Jx0UQbv5SJ9FoyUnaZpqZIHDhLTU+Awn/K0Uw="
+        chalType, unparsed = responder.getResponse(chal4, uri="smtp/localhost.sendmail.com.")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        self._checkResponseToChallenge(unparsed, chal4, checkDict)
+        # Subsequent auth increments nc
+        chalType, unparsed = responder.getResponse(chal4, uri="smtp/localhost.sendmail.com.")
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        checkDict['nc'] = "00000002"
+        del checkDict['response']
+        f = self._checkResponseToChallenge(unparsed, chal4, checkDict)
+        self.assertNotEquals(f['response'], "780c0451303666e1ea9a24de7b5eb08b")
+
+    def test_overrideRealm(self):
+        """
+        Default responder realm overriden by realm in challenge.
+        """
+        responder = digest.SASLDigestResponder(username="chris", password="secret",
+            realm="example.org")
+        responder.cnonce = "OA6MHXh6VqTrRk"
+        chalType, unparsed = responder.getResponse(chal1, uri="imap/elwood.innosoft.com")
+        self._checkResponseToChallenge(unparsed, chal1, {})
+
+    def test_noRealm(self):
+        """
+        No realm in challenge and no default realm in responder either.
+        """
+        responder = digest.SASLDigestResponder(username="test", password="tEst42")
+        self.assertRaises(error.LoginFailed, responder.getResponse,
+            chal4, uri="smtp/localhost.sendmail.com.")
+
+
+
+#
+# Test challengers
+#
+
+class StaticTimeSASLChallenger(digest.SASLDigestChallenger):
+    def __init__(self, *args, **kargs):
+        digest.SASLDigestChallenger.__init__(self, *args, **kargs)
+        self._clock = task.Clock()
+        self._callLater = self._clock.callLater
+    def _getTime(self):
+        return self._clock.seconds()
+
+class StaticTimeHTTPChallenger(digest.HTTPDigestChallenger):
+    def __init__(self, *args, **kargs):
+        digest.HTTPDigestChallenger.__init__(self, *args, **kargs)
+        self._clock = task.Clock()
+        self._callLater = self._clock.callLater
+    def _getTime(self):
+        return self._clock.seconds()
+
+class _BaseChallengerTestCase(object):
+    def test_freshNonce(self):
+        """
+        Accept a fresh nonce.
+        """
+        c = self.challengerClass("example.com")
+        nonce = c.generateNonce()
+        nonce2 = c.generateNonce()
+        self.assertNotEquals(nonce, nonce2)
+        self.assertEquals(c.acceptNonce(nonce, "00000001"), True)
+        self.assertEquals(c.acceptNonce(nonce2, "00000001"), True)
+
+    def test_expiredNonce(self):
+        """
+        Don't accept an expired nonce.
+        """
+        c = self.staticTimeChallengerClass("example.com")
+        c._clock.advance(time.time())
+        nonce = c.generateNonce()
+        nonce2 = c.generateNonce()
+        self.assertNotEquals(nonce, nonce2)
+        c._clock.advance(c.CHALLENGE_LIFETIME_SECS * 0.5)
+        self.assertEquals(c.acceptNonce(nonce, "00000001"), True)
+        c._clock.advance(c.CHALLENGE_LIFETIME_SECS * 0.5 + 1)
+        self.assertEquals(c.acceptNonce(nonce2, "00000001"), False)
+
+    def test_nonceInFuture(self):
+        """
+        Don't accept a nonce generated in the future.
+        """
+        c = self.staticTimeChallengerClass("example.com")
+        c._clock.advance(time.time())
+        nonce = c.generateNonce()
+        c._clock.advance(- c.CHALLENGE_LIFETIME_SECS * 0.5)
+        self.assertRaises(error.LoginFailed, c.acceptNonce, nonce, "00000001")
+
+    def test_fakeNonce(self):
+        """
+        Don't accept a fake nonce (i.e. not generated by us).
+        """
+        c = self.challengerClass("example.com")
+        nonce = c.generateNonce()
+        self.assertRaises(error.LoginFailed, c.acceptNonce, nonce + "1", "00000001")
+        self.assertRaises(error.LoginFailed, c.acceptNonce, "1" + nonce, "00000001")
+
+    def test_nonceReplay(self):
+        """
+        Don't accept nonce replays.
+        """
+        c = self.challengerClass("example.com")
+        nonce = c.generateNonce()
+        nonce2 = c.generateNonce()
+        self.assertNotEquals(nonce, nonce2)
+        self.assertEquals(c.acceptNonce(nonce, "00000001"), True)
+        self.assertEquals(c.acceptNonce(nonce, "00000002"), True)
+        self.assertRaises(error.LoginFailed, c.acceptNonce, nonce, "00000001")
+        self.assertRaises(error.LoginFailed, c.acceptNonce, nonce, "00000002")
+        self.assertRaises(error.LoginFailed, c.acceptNonce, nonce, "00000004")
+        self.assertEquals(c.acceptNonce(nonce, "00000003"), True)
+
+    def test_getChallenge(self):
+        """
+        Generate a challenge.
+        """
+        realm = "example.com"
+        c = self.challengerClass(realm)
+        unparsed = c.getChallenge()
+        f = digest.parseChallenge(unparsed)
+        self.assertEquals(f['realm'], realm)
+        self.assertEquals(f['qop'], ["auth", "auth-int"])
+        self.assertEquals(c.acceptNonce(f['nonce'], "00000001"), True)
+        self.assertEquals(f['stale'], False)
+        self._check_getChallenge(f)
+
+    def test_getRenewedChallenge(self):
+        """
+        Generate a renewed challenge.
+        """
+        realm = "example.com"
+        c = self.challengerClass(realm)
+        # The response is currently ignored so give an empty one
+        unparsed = c.getRenewedChallenge("")
+        f = digest.parseChallenge(unparsed)
+        self.assertEquals(f['realm'], realm)
+        self.assertEquals(f['qop'], ["auth", "auth-int"])
+        self.assertEquals(c.acceptNonce(f['nonce'], "00000001"), True)
+        self.assertEquals(f['stale'], True)
+        self._check_getRenewedChallenge(f)
+
+    def _check_processResponseOk(self, realm, uri, username, password, method=None, body=None):
+        c = self.challengerClass(realm)
+        r = self.responderClass(username, password)
+        # Initial auth
+        chal = c.getChallenge()
+        if method is not None or body is not None:
+            chalType, resp = r.getResponse(chal, uri, method, body)
+        else:
+            chalType, resp = r.getResponse(chal, uri)
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        f = digest.parseResponse(resp)
+        if body is not None:
+            self.assertEquals(f['qop'], "auth-int")
+        if method is not None or body is not None:
+            credentials = c.processResponse(resp, method, body)
+        else:
+            credentials = c.processResponse(resp)
+        self.assertTrue(credentials.checkPassword(password))
+        self.assertFalse(credentials.checkPassword(password + "a"))
+
+    def _check_multipleRoundTrip(self, realm, uri, username, password, method=None, body=None):
+        c = self.challengerClass(realm)
+        r = self.responderClass(username, password)
+        # Roundtrips with new challenge each time
+        for i in range(3):
+            chal = c.getChallenge()
+            if method is not None or body is not None:
+                chalType, resp = r.getResponse(chal, uri, method, body)
+                credentials = c.processResponse(resp, method, body)
+            else:
+                chalType, resp = r.getResponse(chal, uri)
+                credentials = c.processResponse(resp)
+        self.assertTrue(credentials.checkPassword(password))
+        self.assertFalse(credentials.checkPassword(password + "a"))
+        # Roundtrips with the same original challenge
+        chal = c.getChallenge()
+        for i in range(3):
+            if method is not None or body is not None:
+                chalType, resp = r.getResponse(chal, uri, method, body)
+                credentials = c.processResponse(resp, method, body)
+            else:
+                chalType, resp = r.getResponse(chal, uri)
+                credentials = c.processResponse(resp)
+        self.assertTrue(credentials.checkPassword(password))
+        self.assertFalse(credentials.checkPassword(password + "a"))
+
+    def _check_getSuccessfulChallenge(self, response, uri, password, rspauth):
+        f = digest.parseResponse(response)
+        c = self.challengerClass(f['realm'])
+        mech = digest.SASLDigestMechanism(f['username'], uri, f)
+        mech.setClientParams(f['cnonce'], f['nc'], f['qop'])
+        cred = digest.DigestedCredentials(mech, f['response'])
+        # Generate rspauth
+        self.assertTrue(cred.checkPassword(password))
+        unparsed = c.getSuccessfulChallenge(resp1, cred)
+        f2 = digest.parseChallenge(unparsed)
+        self.assertEquals(f2['rspauth'], rspauth)
+
+
+class SASLChallengerTestCase(unittest.TestCase, _BaseChallengerTestCase):
+    challengerClass = digest.SASLDigestChallenger
+    responderClass = digest.SASLDigestResponder
+    staticTimeChallengerClass = StaticTimeSASLChallenger
+
+    def _check_getChallenge(self, f):
+        self.assertTrue('opaque' not in f)
+        self.assertEquals(f['charset'], "utf-8")
+        self.assertEquals(f['algorithm'], "md5-sess")
+
+    def _check_getRenewedChallenge(self, f):
+        self.assertTrue('opaque' not in f)
+        self.assertEquals(f['charset'], "utf-8")
+        self.assertEquals(f['algorithm'], "md5-sess")
+
+    def test_processResponseOk(self):
+        """
+        Full challenger -> responder -> challenger roundtrip, with credentials check.
+        """
+        self._check_processResponseOk("example.com", "/", "chris", "secret")
+
+    def test_multipleRoundTrip(self):
+        """
+        Multiple roundtrip with same challenger and responder.
+        """
+        self._check_multipleRoundTrip("example.com", "/", "chris", "secret")
+
+    def test_getSuccessfulChallenge(self):
+        """
+        Generate rspauth challenge.
+        """
+        self._check_getSuccessfulChallenge(resp1, "imap/elwood.innosoft.com",
+            password="secret", rspauth="ea40f60335c427b5527b84dbabcdfffd")
+
+
+class HTTPChallengerTestCase(unittest.TestCase, _BaseChallengerTestCase):
+    challengerClass = digest.HTTPDigestChallenger
+    responderClass = digest.HTTPDigestResponder
+    staticTimeChallengerClass = StaticTimeHTTPChallenger
+
+    def _check_getChallenge(self, f):
+        self.assertTrue('opaque' in f)
+        self.assertTrue('charset' not in f)
+        self.assertEquals(f['algorithm'], "md5")
+
+    def _check_getRenewedChallenge(self, f):
+        self.assertTrue('opaque' in f)
+        self.assertTrue('charset' not in f)
+        self.assertEquals(f['algorithm'], "md5")
+
+    def test_processResponseOk(self):
+        """
+        Full challenger -> responder -> challenger roundtrip, with credentials check.
+        """
+        self._check_processResponseOk("example.com", "/", "chris", "secret")
+        self._check_processResponseOk("example.com", "/", "chris", "secret", "GET")
+        self._check_processResponseOk("example.com", "/", "chris", "secret", "GET", "blah")
+
+    def test_multipleRoundTrip(self):
+        """
+        Multiple roundtrip with same challenger and responder.
+        """
+        self._check_multipleRoundTrip("example.com", "/", "chris", "secret")
+        self._check_multipleRoundTrip("example.com", "/", "chris", "secret", "GET")
+        self._check_multipleRoundTrip("example.com", "/", "chris", "secret", "GET", "blah")
+
+    def test_weakDigest(self):
+        """
+        Support for RFC 2069 clients.
+        """
+        method, body = "GET", "blah"
+        c = self.challengerClass("example.com")
+        r = self.responderClass("chris", "secret")
+        r._chooseQop = lambda *_: None
+        chal = c.getChallenge()
+        chalType, resp = r.getResponse(chal, "/", method, body)
+        f = digest.parseResponse(resp)
+        self.assertEquals(f.get('qop'), None)
+        credentials = c.processResponse(resp, method, body)
+        self.assertTrue(credentials.checkPassword("secret"))
+        self.assertFalse(credentials.checkPassword("secreta"))
+
diff -r 8b2a31d7b349 twisted/test/test_plain.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/twisted/test/test_plain.py	Wed Mar 14 15:54:49 2007 +0100
@@ -0,0 +1,130 @@
+
+from twisted.trial import unittest
+from twisted.cred import error, sasl, plain
+
+
+class CredentialsTestCase(unittest.TestCase):
+    def test_password(self):
+        """
+        Password checking.
+        """
+        c = plain.PlainCredentials("chris", "secret")
+        self.assertTrue(c.checkPassword("secret"))
+        self.assertFalse(c.checkPassword("secreta"))
+
+    def test_noAuthzid(self):
+        """
+        Credentials without authzid, or empty string.
+        """
+        c = plain.PlainCredentials("chris", "secret", "")
+        self.assertTrue(c.authzid is None)
+
+    def test_authzid(self):
+        """
+        Credentials with provided authzid.
+        """
+        c = plain.PlainCredentials("chris", "secret", "paul")
+        self.assertEquals(c.authzid, "paul")
+
+class ResponderTestCase(unittest.TestCase):
+    def _check_responses(self, responder, uri, expected):
+        resp = responder.getInitialResponse(uri)
+        self.assertEquals(resp, expected)
+        # Accept any challenge
+        chalType, resp = responder.getResponse("123", uri)
+        self.assertTrue(isinstance(chalType, sasl.InitialChallenge))
+        self.assertEquals(resp, expected)
+
+    def test_noAuthzid(self):
+        """
+        Generate responses with empty authzid.
+        """
+        r = plain.SASLPlainResponder(username="chris", password="secret")
+        self._check_responses(r, "imap/elwood.innosoft.com", "\0chris\0secret")
+
+    def test_authzid(self):
+        """
+        Generate responses with non-empty authzid.
+        """
+        r = plain.SASLPlainResponder(username="chris", password="secret",
+            authzid="paul")
+        self._check_responses(r, "imap/elwood.innosoft.com", "paul\0chris\0secret")
+
+    def test_nonASCII(self):
+        """
+        Non-ASCII username/password/authzid.
+        """
+        r = plain.SASLPlainResponder(username=u'andr\xe9', password=u'h\xe9h\xe9',
+            authzid=u"gis\xe8le")
+        self._check_responses(r, "imap/elwood.innosoft.com",
+            "gis\xc3\xa8le\0andr\xc3\xa9\0h\xc3\xa9h\xc3\xa9")
+
+class ChallengerTestCase(unittest.TestCase):
+    def test_getChallenge(self):
+        """
+        Empty (initial) challenge.
+        """
+        c = plain.SASLPlainChallenger()
+        self.assertTrue(c.getChallenge() is None)
+
+    def test_getRenewedChallenge(self):
+        """
+        Empty renewed challenge.
+        """
+        c = plain.SASLPlainChallenger()
+        self.assertTrue(c.getRenewedChallenge("\0chris\0secret") is None)
+
+    def test_getSuccessfulChallenge(self):
+        """
+        Empty successful challenge.
+        """
+        c = plain.SASLPlainChallenger()
+        self.assertTrue(c.getSuccessfulChallenge("\0chris\0secret",
+            plain.PlainCredentials("chris", "secret")) is None)
+
+    def test_InvalidResponse(self):
+        """
+        Response can't be parsed.
+        """
+        c = plain.SASLPlainChallenger()
+        # Not the right number of \0's
+        self.assertRaises(error.LoginFailed,
+            c.processResponse, "chris")
+        self.assertRaises(error.LoginFailed,
+            c.processResponse, "chris\0secret")
+        self.assertRaises(error.LoginFailed,
+            c.processResponse, "\0chris\0secret\0")
+        # No username
+        self.assertRaises(error.LoginFailed,
+            c.processResponse, "paul\0\0secret")
+        # No password
+        self.assertRaises(error.LoginFailed,
+            c.processResponse, "paul\0chris\0")
+
+    def test_nonUTF8Response(self):
+        """
+        Response can't be decoded with UTF-8.
+        """
+        c = plain.SASLPlainChallenger()
+        self.assertRaises(error.LoginFailed,
+            c.processResponse, "andr\xe9\0chris\0secret")
+
+    def test_UTF8Response(self):
+        """
+        UTF-8 response.
+        """
+        c = plain.SASLPlainChallenger()
+        cred = c.processResponse("gis\xc3\xa8le\0andr\xc3\xa9\0h\xc3\xa9h\xc3\xa9")
+        self.assertEquals(cred.username, u'andr\xe9')
+        self.assertTrue(cred.checkPassword(u'h\xe9h\xe9'))
+        self.assertEquals(cred.authzid, u"gis\xe8le")
+
+    def test_emptyAuthzid(self):
+        """
+        Empty authzid.
+        """
+        c = plain.SASLPlainChallenger()
+        cred = c.processResponse("\0chris\0secret")
+        self.assertEquals(cred.username, "chris")
+        self.assertTrue(cred.checkPassword("secret"))
+        self.assertTrue(cred.authzid is None)
