diff --git setup3.py setup3.py
index ca27cbe..789a724 100644
--- setup3.py
+++ setup3.py
@@ -78,7 +78,7 @@ modules = [
     "twisted.python.log",
     "twisted.python.monkey",
     "twisted.python.randbytes",
-    "twisted.python._reflectpy3",
+    "twisted.python.reflect",
     "twisted.python.runtime",
     "twisted.python.test",
     "twisted.python.test.deprecatedattributes",
@@ -150,7 +150,6 @@ testModules = [
     "twisted.protocols.test.test_tls",
     "twisted.python.test.test_components",
     "twisted.python.test.test_deprecate",
-    "twisted.python.test.test_reflectpy3",
     "twisted.python.test.test_runtime",
     "twisted.python.test.test_util",
     "twisted.python.test.test_versions",
@@ -173,6 +172,7 @@ testModules = [
     "twisted.test.test_paths",
     "twisted.test.test_policies",
     "twisted.test.test_randbytes",
+    "twisted.test.test_reflect",
     "twisted.test.test_setup",
     "twisted.test.test_ssl",
     "twisted.test.test_sslverify",
diff --git twisted/internet/_sslverify.py twisted/internet/_sslverify.py
index 3462f9a..5baa62f 100644
--- twisted/internet/_sslverify.py
+++ twisted/internet/_sslverify.py
@@ -11,7 +11,7 @@ from hashlib import md5
 from OpenSSL import SSL, crypto
 
 from twisted.python.compat import nativeString, networkString
-from twisted.python import _reflectpy3 as reflect, util
+from twisted.python import reflect, util
 from twisted.internet.defer import Deferred
 from twisted.internet.error import VerifyError, CertificateError
 
diff --git twisted/internet/abstract.py twisted/internet/abstract.py
index 6e69f4a..41df5f7 100644
--- twisted/internet/abstract.py
+++ twisted/internet/abstract.py
@@ -14,7 +14,7 @@ from zope.interface import implementer
 
 # Twisted Imports
 from twisted.python.compat import _PY3, unicode, lazyByteSlice
-from twisted.python import _reflectpy3 as reflect, failure
+from twisted.python import reflect, failure
 from twisted.internet import interfaces, main
 
 if _PY3:
diff --git twisted/internet/base.py twisted/internet/base.py
index ce63c37..cfcd9fc 100644
--- twisted/internet/base.py
+++ twisted/internet/base.py
@@ -21,7 +21,7 @@ from twisted.internet.interfaces import IReactorCore, IReactorTime, IReactorThre
 from twisted.internet.interfaces import IResolverSimple, IReactorPluggableResolver
 from twisted.internet.interfaces import IConnector, IDelayedCall
 from twisted.internet import fdesc, main, error, abstract, defer, threads
-from twisted.python import log, failure, _reflectpy3 as reflect
+from twisted.python import log, failure, reflect
 from twisted.python.runtime import seconds as runtimeSeconds, platform
 from twisted.internet.defer import Deferred, DeferredList
 
diff --git twisted/internet/task.py twisted/internet/task.py
index 5d8ff4b..56bbacb 100644
--- twisted/internet/task.py
+++ twisted/internet/task.py
@@ -16,7 +16,7 @@ import time
 from zope.interface import implementer
 
 from twisted.python import log
-from twisted.python import _reflectpy3 as reflect
+from twisted.python import reflect
 from twisted.python.failure import Failure
 
 from twisted.internet import base, defer
diff --git twisted/internet/tcp.py twisted/internet/tcp.py
index 24931d5..2c68929 100644
--- twisted/internet/tcp.py
+++ twisted/internet/tcp.py
@@ -96,7 +96,7 @@ from errno import errorcode
 # Twisted Imports
 from twisted.internet import base, address, fdesc
 from twisted.internet.task import deferLater
-from twisted.python import log, failure, _reflectpy3 as reflect
+from twisted.python import log, failure, reflect
 from twisted.python.util import untilConcludes
 from twisted.internet.error import CannotListenError
 from twisted.internet import abstract, main, interfaces, error
diff --git twisted/internet/test/reactormixins.py twisted/internet/test/reactormixins.py
index 3080ebe..b0618da 100644
--- twisted/internet/test/reactormixins.py
+++ twisted/internet/test/reactormixins.py
@@ -24,8 +24,7 @@ from twisted.python.compat import _PY3
 from twisted.trial.unittest import SynchronousTestCase, SkipTest
 from twisted.trial.util import DEFAULT_TIMEOUT_DURATION, acquireAttribute
 from twisted.python.runtime import platform
-from twisted.python._reflectpy3 import namedAny
-from twisted.python.deprecate import _fullyQualifiedName as fullyQualifiedName
+from twisted.python.reflect import namedAny, fullyQualifiedName
 
 from twisted.python import log
 from twisted.python.failure import Failure
diff --git twisted/protocols/tls.py twisted/protocols/tls.py
index f139c6a..cc7d235 100644
--- twisted/protocols/tls.py
+++ twisted/protocols/tls.py
@@ -52,7 +52,7 @@ from zope.interface import implementer, providedBy, directlyProvides
 from twisted.python.compat import unicode
 from twisted.python.failure import Failure
 from twisted.python import log
-from twisted.python._reflectpy3 import safe_str
+from twisted.python.reflect import safe_str
 from twisted.internet.interfaces import ISystemHandle, ISSLTransport
 from twisted.internet.interfaces import IPushProducer, ILoggingContext
 from twisted.internet.main import CONNECTION_LOST
diff --git twisted/python/_reflectpy3.py twisted/python/_reflectpy3.py
deleted file mode 100644
index f3e98d4..0000000
--- twisted/python/_reflectpy3.py
+++ /dev/null
@@ -1,387 +0,0 @@
-# -*- test-case-name: twisted.python.test.test_reflectpy3 -*-
-# Copyright (c) Twisted Matrix Laboratories.
-# See LICENSE for details.
-
-"""
-Reflection APIs which have been ported to Python 3.
-"""
-
-from __future__ import division, absolute_import
-
-import types, sys, os, traceback
-
-from twisted.python.compat import reraise, nativeString, NativeStringIO
-
-
-def prefixedMethodNames(classObj, prefix):
-    """
-    Given a class object C{classObj}, returns a list of method names that match
-    the string C{prefix}.
-
-    @param classObj: A class object from which to collect method names.
-
-    @param prefix: A native string giving a prefix.  Each method with a name
-        which begins with this prefix will be returned.
-    @type prefix: L{str}
-
-    @return: A list of the names of matching methods of C{classObj} (and base
-        classes of C{classObj}).
-    @rtype: L{list} of L{str}
-    """
-    dct = {}
-    addMethodNamesToDict(classObj, dct, prefix)
-    return list(dct.keys())
-
-
-
-def addMethodNamesToDict(classObj, dict, prefix, baseClass=None):
-    """
-    This goes through C{classObj} (and its bases) and puts method names
-    starting with 'prefix' in 'dict' with a value of 1. if baseClass isn't
-    None, methods will only be added if classObj is-a baseClass
-
-    If the class in question has the methods 'prefix_methodname' and
-    'prefix_methodname2', the resulting dict should look something like:
-    {"methodname": 1, "methodname2": 1}.
-
-    @param classObj: A class object from which to collect method names.
-
-    @param dict: A L{dict} which will be updated with the results of the
-        accumulation.  Items are added to this dictionary, with method names as
-        keys and C{1} as values.
-    @type dict: L{dict}
-
-    @param prefix: A native string giving a prefix.  Each method of C{classObj}
-        (and base classes of C{classObj}) with a name which begins with this
-        prefix will be returned.
-    @type prefix: L{str}
-
-    @param baseClass: A class object at which to stop searching upwards for new
-        methods.  To collect all method names, do not pass a value for this
-        parameter.
-
-    @return: C{None}
-    """
-    for base in classObj.__bases__:
-        addMethodNamesToDict(base, dict, prefix, baseClass)
-
-    if baseClass is None or baseClass in classObj.__bases__:
-        for name, method in classObj.__dict__.items():
-            optName = name[len(prefix):]
-            if ((type(method) is types.FunctionType)
-                and (name[:len(prefix)] == prefix)
-                and (len(optName))):
-                dict[optName] = 1
-
-
-
-def prefixedMethods(obj, prefix=''):
-    """
-    Given an object C{obj}, returns a list of method objects that match the
-    string C{prefix}.
-
-    @param obj: An arbitrary object from which to collect methods.
-
-    @param prefix: A native string giving a prefix.  Each method of C{obj} with
-        a name which begins with this prefix will be returned.
-    @type prefix: L{str}
-
-    @return: A list of the matching method objects.
-    @rtype: L{list}
-    """
-    dct = {}
-    accumulateMethods(obj, dct, prefix)
-    return list(dct.values())
-
-
-
-def accumulateMethods(obj, dict, prefix='', curClass=None):
-    """
-    Given an object C{obj}, add all methods that begin with C{prefix}.
-
-    @param obj: An arbitrary object to collect methods from.
-
-    @param dict: A L{dict} which will be updated with the results of the
-        accumulation.  Items are added to this dictionary, with method names as
-        keys and corresponding instance method objects as values.
-    @type dict: L{dict}
-
-    @param prefix: A native string giving a prefix.  Each method of C{obj} with
-        a name which begins with this prefix will be returned.
-    @type prefix: L{str}
-
-    @param curClass: The class in the inheritance hierarchy at which to start
-        collecting methods.  Collection proceeds up.  To collect all methods
-        from C{obj}, do not pass a value for this parameter.
-
-    @return: C{None}
-    """
-    if not curClass:
-        curClass = obj.__class__
-    for base in curClass.__bases__:
-        accumulateMethods(obj, dict, prefix, base)
-
-    for name, method in curClass.__dict__.items():
-        optName = name[len(prefix):]
-        if ((type(method) is types.FunctionType)
-            and (name[:len(prefix)] == prefix)
-            and (len(optName))):
-            dict[optName] = getattr(obj, name)
-
-
-
-def namedModule(name):
-    """
-    Return a module given its name.
-    """
-    topLevel = __import__(name)
-    packages = name.split(".")[1:]
-    m = topLevel
-    for p in packages:
-        m = getattr(m, p)
-    return m
-
-
-
-def namedObject(name):
-    """
-    Get a fully named module-global object.
-    """
-    classSplit = name.split('.')
-    module = namedModule('.'.join(classSplit[:-1]))
-    return getattr(module, classSplit[-1])
-
-namedClass = namedObject # backwards compat
-
-
-
-class _NoModuleFound(Exception):
-    """
-    No module was found because none exists.
-    """
-
-
-
-class InvalidName(ValueError):
-    """
-    The given name is not a dot-separated list of Python objects.
-    """
-
-
-
-class ModuleNotFound(InvalidName):
-    """
-    The module associated with the given name doesn't exist and it can't be
-    imported.
-    """
-
-
-
-class ObjectNotFound(InvalidName):
-    """
-    The object associated with the given name doesn't exist and it can't be
-    imported.
-    """
-
-
-
-def _importAndCheckStack(importName):
-    """
-    Import the given name as a module, then walk the stack to determine whether
-    the failure was the module not existing, or some code in the module (for
-    example a dependent import) failing.  This can be helpful to determine
-    whether any actual application code was run.  For example, to distiguish
-    administrative error (entering the wrong module name), from programmer
-    error (writing buggy code in a module that fails to import).
-
-    @param importName: The name of the module to import.
-    @type importName: C{str}
-    @raise Exception: if something bad happens.  This can be any type of
-        exception, since nobody knows what loading some arbitrary code might
-        do.
-    @raise _NoModuleFound: if no module was found.
-    """
-    try:
-        return __import__(importName)
-    except ImportError:
-        excType, excValue, excTraceback = sys.exc_info()
-        while excTraceback:
-            execName = excTraceback.tb_frame.f_globals["__name__"]
-            # in Python 2 execName is None when an ImportError is encountered,
-            # where in Python 3 execName is equal to the importName.
-            if execName is None or execName == importName:
-                reraise(excValue, excTraceback)
-            excTraceback = excTraceback.tb_next
-        raise _NoModuleFound()
-
-
-
-def namedAny(name):
-    """
-    Retrieve a Python object by its fully qualified name from the global Python
-    module namespace.  The first part of the name, that describes a module,
-    will be discovered and imported.  Each subsequent part of the name is
-    treated as the name of an attribute of the object specified by all of the
-    name which came before it.  For example, the fully-qualified name of this
-    object is 'twisted.python.reflect.namedAny'.
-
-    @type name: L{str}
-    @param name: The name of the object to return.
-
-    @raise InvalidName: If the name is an empty string, starts or ends with
-        a '.', or is otherwise syntactically incorrect.
-
-    @raise ModuleNotFound: If the name is syntactically correct but the
-        module it specifies cannot be imported because it does not appear to
-        exist.
-
-    @raise ObjectNotFound: If the name is syntactically correct, includes at
-        least one '.', but the module it specifies cannot be imported because
-        it does not appear to exist.
-
-    @raise AttributeError: If an attribute of an object along the way cannot be
-        accessed, or a module along the way is not found.
-
-    @return: the Python object identified by 'name'.
-    """
-    if not name:
-        raise InvalidName('Empty module name')
-
-    names = name.split('.')
-
-    # if the name starts or ends with a '.' or contains '..', the __import__
-    # will raise an 'Empty module name' error. This will provide a better error
-    # message.
-    if '' in names:
-        raise InvalidName(
-            "name must be a string giving a '.'-separated list of Python "
-            "identifiers, not %r" % (name,))
-
-    topLevelPackage = None
-    moduleNames = names[:]
-    while not topLevelPackage:
-        if moduleNames:
-            trialname = '.'.join(moduleNames)
-            try:
-                topLevelPackage = _importAndCheckStack(trialname)
-            except _NoModuleFound:
-                moduleNames.pop()
-        else:
-            if len(names) == 1:
-                raise ModuleNotFound("No module named %r" % (name,))
-            else:
-                raise ObjectNotFound('%r does not name an object' % (name,))
-
-    obj = topLevelPackage
-    for n in names[1:]:
-        obj = getattr(obj, n)
-
-    return obj
-
-
-
-def filenameToModuleName(fn):
-    """
-    Convert a name in the filesystem to the name of the Python module it is.
-
-    This is aggressive about getting a module name back from a file; it will
-    always return a string.  Aggressive means 'sometimes wrong'; it won't look
-    at the Python path or try to do any error checking: don't use this method
-    unless you already know that the filename you're talking about is a Python
-    module.
-
-    @param fn: A filesystem path to a module or package; C{bytes} on Python 2,
-        C{bytes} or C{unicode} on Python 3.
-
-    @return: A hopefully importable module name.
-    @rtype: C{str}
-    """
-    if isinstance(fn, bytes):
-        initPy = b"__init__.py"
-    else:
-        initPy = "__init__.py"
-    fullName = os.path.abspath(fn)
-    base = os.path.basename(fn)
-    if not base:
-        # this happens when fn ends with a path separator, just skit it
-        base = os.path.basename(fn[:-1])
-    modName = nativeString(os.path.splitext(base)[0])
-    while 1:
-        fullName = os.path.dirname(fullName)
-        if os.path.exists(os.path.join(fullName, initPy)):
-            modName = "%s.%s" % (
-                nativeString(os.path.basename(fullName)),
-                nativeString(modName))
-        else:
-            break
-    return modName
-
-
-
-def qual(clazz):
-    """
-    Return full import path of a class.
-    """
-    return clazz.__module__ + '.' + clazz.__name__
-
-
-
-def _determineClass(x):
-    try:
-        return x.__class__
-    except:
-        return type(x)
-
-
-
-def _determineClassName(x):
-    c = _determineClass(x)
-    try:
-        return c.__name__
-    except:
-        try:
-            return str(c)
-        except:
-            return '<BROKEN CLASS AT 0x%x>' % id(c)
-
-
-
-def _safeFormat(formatter, o):
-    """
-    Helper function for L{safe_repr} and L{safe_str}.
-    """
-    try:
-        return formatter(o)
-    except:
-        io = NativeStringIO()
-        traceback.print_exc(file=io)
-        className = _determineClassName(o)
-        tbValue = io.getvalue()
-        return "<%s instance at 0x%x with %s error:\n %s>" % (
-            className, id(o), formatter.__name__, tbValue)
-
-
-
-def safe_repr(o):
-    """
-    Returns a string representation of an object, or a string containing a
-    traceback, if that object's __repr__ raised an exception.
-
-    @param o: Any object.
-
-    @rtype: C{str}
-    """
-    return _safeFormat(repr, o)
-
-
-
-def safe_str(o):
-    """
-    Returns a string representation of an object, or a string containing a
-    traceback, if that object's __str__ raised an exception.
-
-    @param o: Any object.
-
-    @rtype: C{str}
-    """
-    return _safeFormat(str, o)
diff --git twisted/python/compat.py twisted/python/compat.py
index a8fc936..3c4102e 100644
--- twisted/python/compat.py
+++ twisted/python/compat.py
@@ -405,6 +405,26 @@ interpolation.  For example, this is safe on Python 2 and Python 3:
 """
 
 
+try:
+    StringType = basestring
+except NameError:
+    # Python 3+
+    StringType = str
+
+try:
+    from types import InstanceType
+except ImportError:
+    # Python 3+
+    InstanceType = object
+
+try:
+    from types import FileType
+except ImportError:
+    from io import IOBase
+    # Python 3+
+    FileType = IOBase
+
+
 __all__ = [
     "reraise",
     "execfile",
diff --git twisted/python/components.py twisted/python/components.py
index 53eb879..2e715ba 100644
--- twisted/python/components.py
+++ twisted/python/components.py
@@ -36,7 +36,7 @@ from zope.interface.adapter import AdapterRegistry
 
 # twisted imports
 from twisted.python.compat import NativeStringIO
-from twisted.python import _reflectpy3 as reflect
+from twisted.python import reflect
 
 
 
diff --git twisted/python/deprecate.py twisted/python/deprecate.py
index 7d71b2a..e3a74e7 100644
--- twisted/python/deprecate.py
+++ twisted/python/deprecate.py
@@ -61,43 +61,10 @@ from dis import findlinestarts
 from functools import wraps
 
 from twisted.python.versions import getVersionString
+from twisted.python.reflect import fullyQualifiedName
 
-DEPRECATION_WARNING_FORMAT = '%(fqpn)s was deprecated in %(version)s'
-
-# Notionally, part of twisted.python.reflect, but defining it there causes a
-# cyclic dependency between this module and that module.  Define it here,
-# instead, and let reflect import it to re-expose to the public.
-def _fullyQualifiedName(obj):
-    """
-    Return the fully qualified name of a module, class, method or function.
-    Classes and functions need to be module level ones to be correctly
-    qualified.
 
-    @rtype: C{str}.
-    """
-    try:
-        name = obj.__qualname__
-    except AttributeError:
-        name = obj.__name__
-
-    if inspect.isclass(obj) or inspect.isfunction(obj):
-        moduleName = obj.__module__
-        return "%s.%s" % (moduleName, name)
-    elif inspect.ismethod(obj):
-        try:
-            cls = obj.im_class
-        except AttributeError:
-            # Python 3 eliminates im_class, substitutes __module__ and
-            # __qualname__ to provide similar information.
-            return "%s.%s" % (obj.__module__, obj.__qualname__)
-        else:
-            className = _fullyQualifiedName(cls)
-            return "%s.%s" % (className, name)
-    return name
-# Try to keep it looking like something in twisted.python.reflect.
-_fullyQualifiedName.__module__ = 'twisted.python.reflect'
-_fullyQualifiedName.__name__ = 'fullyQualifiedName'
-_fullyQualifiedName.__qualname__ = 'fullyQualifiedName'
+DEPRECATION_WARNING_FORMAT = '%(fqpn)s was deprecated in %(version)s'
 
 
 def _getReplacementString(replacement):
@@ -111,7 +78,7 @@ def _getReplacementString(replacement):
         instead".
     """
     if callable(replacement):
-        replacement = _fullyQualifiedName(replacement)
+        replacement = fullyQualifiedName(replacement)
     return "please use %s instead" % (replacement,)
 
 
@@ -206,7 +173,7 @@ def getDeprecationWarningString(callableThing, version, format=None,
     @rtype: C{str}
     """
     return _getDeprecationWarningString(
-        _fullyQualifiedName(callableThing), version, format, replacement)
+        fullyQualifiedName(callableThing), version, format, replacement)
 
 
 
diff --git twisted/python/failure.py twisted/python/failure.py
index e79862d..aa68ac9 100644
--- twisted/python/failure.py
+++ twisted/python/failure.py
@@ -21,7 +21,7 @@ import opcode
 from inspect import getmro
 
 from twisted.python.compat import _PY3, NativeStringIO as StringIO
-from twisted.python import _reflectpy3 as reflect
+from twisted.python import reflect
 
 count = 0
 traceupLength = 4
diff --git twisted/python/log.py twisted/python/log.py
index 9299651..0a22d07 100644
--- twisted/python/log.py
+++ twisted/python/log.py
@@ -18,7 +18,7 @@ from zope.interface import Interface
 
 from twisted.python.compat import unicode, _PY3
 from twisted.python import context
-from twisted.python import _reflectpy3 as reflect
+from twisted.python import reflect
 from twisted.python import util
 from twisted.python import failure
 from twisted.python.threadable import synchronize
diff --git twisted/python/reflect.py twisted/python/reflect.py
index 4baf090..de9c2b0 100644
--- twisted/python/reflect.py
+++ twisted/python/reflect.py
@@ -7,274 +7,430 @@ Standardized versions of various cool and/or strange things that you can do
 with Python's reflection capabilities.
 """
 
+from __future__ import division, absolute_import
+
+import inspect
+import os
 import sys
 import types
 import pickle
 import weakref
 import re
+import traceback
 import warnings
 from collections import deque
 
 RegexType = type(re.compile(""))
 
+from twisted.python import compat
+from twisted.python.versions import Version
 
-try:
-    from cStringIO import StringIO
-except ImportError:
-    from StringIO import StringIO
+from twisted.python.compat import reraise, nativeString, NativeStringIO
 
-from twisted.python.deprecate import deprecated, deprecatedModuleAttribute
-from twisted.python.deprecate import _fullyQualifiedName as fullyQualifiedName
-from twisted.python.versions import Version
+# Notionally, part of twisted.python.reflect, but defining it there causes a
+# cyclic dependency between this module and that module.  Define it here,
+# instead, and let reflect import it to re-expose to the public.
+def fullyQualifiedName(obj):
+    """
+    Return the fully qualified name of a module, class, method or function.
+    Classes and functions need to be module level ones to be correctly
+    qualified.
 
-from twisted.python._reflectpy3 import (
-    prefixedMethods, accumulateMethods, prefixedMethodNames,
-    addMethodNamesToDict)
-from twisted.python._reflectpy3 import namedModule, namedObject, namedClass
-from twisted.python._reflectpy3 import InvalidName, ModuleNotFound
-from twisted.python._reflectpy3 import ObjectNotFound, namedAny
-from twisted.python._reflectpy3 import filenameToModuleName
-from twisted.python._reflectpy3 import qual, safe_str, safe_repr
-
-class Settable:
-    """
-    A mixin class for syntactic sugar.  Lets you assign attributes by
-    calling with keyword arguments; for example, C{x(a=b,c=d,y=z)} is the
-    same as C{x.a=b;x.c=d;x.y=z}.  The most useful place for this is
-    where you don't want to name a variable, but you do want to set
-    some attributes; for example, C{X()(y=z,a=b)}.
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "Settable is old and untested. Please write your own version of this "
-        "functionality if you need it.", "twisted.python.reflect", "Settable")
-
-    def __init__(self, **kw):
-        self(**kw)
-
-    def __call__(self,**kw):
-        for key,val in kw.items():
-            setattr(self,key,val)
-        return self
-
-
-class AccessorType(type):
-    """
-    Metaclass that generates properties automatically.
-
-    This is for Python 2.2 and up.
-
-    Using this metaclass for your class will give you explicit accessor
-    methods; a method called set_foo, will automatically create a property
-    'foo' that uses set_foo as a setter method. Same for get_foo and del_foo.
-
-    Note that this will only work on methods that are present on class
-    creation. If you add methods after the class is defined they will not
-    automatically become properties. Likewise, class attributes will only
-    be used if they are present upon class creation, and no getter function
-    was set - if a getter is present, the class attribute will be ignored.
-
-    This is a 2.2-only alternative to the Accessor mixin - just set in your
-    class definition::
-
-        __metaclass__ = AccessorType
-
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "AccessorType is old and untested. Please write your own version of "
-        "this functionality if you need it.", "twisted.python.reflect",
-        "AccessorType")
-
-    def __init__(self, name, bases, d):
-        type.__init__(self, name, bases, d)
-        accessors = {}
-        prefixs = ["get_", "set_", "del_"]
-        for k in d.keys():
-            v = getattr(self, k)
-            for i in range(3):
-                if k.startswith(prefixs[i]):
-                    accessors.setdefault(k[4:], [None, None, None])[i] = v
-        for name, (getter, setter, deler) in accessors.items():
-            # create default behaviours for the property - if we leave
-            # the getter as None we won't be able to getattr, etc..
-            if getter is None:
-                if hasattr(self, name):
-                    value = getattr(self, name)
-                    def getter(this, value=value, name=name):
-                        if name in this.__dict__:
-                            return this.__dict__[name]
-                        else:
-                            return value
-                else:
-                    def getter(this, name=name):
-                        if name in this.__dict__:
-                            return this.__dict__[name]
-                        else:
-                            raise AttributeError("no such attribute %r" % name)
-            if setter is None:
-                def setter(this, value, name=name):
-                    this.__dict__[name] = value
-            if deler is None:
-                def deler(this, name=name):
-                    del this.__dict__[name]
-            setattr(self, name, property(getter, setter, deler, ""))
-
-
-class PropertyAccessor(object):
-    """
-    A mixin class for Python 2.2 that uses AccessorType.
-
-    This provides compatability with the pre-2.2 Accessor mixin, up
-    to a point.
-
-    Extending this class will give you explicit accessor methods; a
-    method called set_foo, for example, is the same as an if statement
-    in __setattr__ looking for 'foo'.  Same for get_foo and del_foo.
-
-    There are also reallyDel and reallySet methods, so you can
-    override specifics in subclasses without clobbering __setattr__
-    and __getattr__, or using non-2.1 compatible code.
-
-    There is are incompatibilities with Accessor - accessor
-    methods added after class creation will *not* be detected. OTOH,
-    this method is probably way faster.
-
-    In addition, class attributes will only be used if no getter
-    was defined, and instance attributes will not override getter methods
-    whereas in original Accessor the class attribute or instance attribute
-    would override the getter method.
-    """
-    # addendum to above:
-    # The behaviour of Accessor is wrong IMHO, and I've found bugs
-    # caused by it.
-    #  -- itamar
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "PropertyAccessor is old and untested. Please write your own version "
-        "of this functionality if you need it.", "twisted.python.reflect",
-        "PropertyAccessor")
-    __metaclass__ = AccessorType
-
-    def reallySet(self, k, v):
-        self.__dict__[k] = v
-
-    def reallyDel(self, k):
-        del self.__dict__[k]
-
-
-class Accessor:
-    """
-    Extending this class will give you explicit accessor methods; a
-    method called C{set_foo}, for example, is the same as an if statement
-    in L{__setattr__} looking for C{'foo'}.  Same for C{get_foo} and
-    C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
-    so you can override specifics in subclasses without clobbering
-    L{__setattr__} and L{__getattr__}.
-
-    This implementation is for Python 2.1.
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "Accessor is an implementation for Python 2.1 which is no longer "
-        "supported by Twisted.", "twisted.python.reflect", "Accessor")
-
-    def __setattr__(self, k,v):
-        kstring='set_%s'%k
-        if hasattr(self.__class__,kstring):
-            return getattr(self,kstring)(v)
+    @rtype: C{str}.
+    """
+    try:
+        name = obj.__qualname__
+    except AttributeError:
+        name = obj.__name__
+
+    if inspect.isclass(obj) or inspect.isfunction(obj):
+        moduleName = obj.__module__
+        return "%s.%s" % (moduleName, name)
+    elif inspect.ismethod(obj):
+        try:
+            cls = obj.im_class
+        except AttributeError:
+            # Python 3 eliminates im_class, substitutes __module__ and
+            # __qualname__ to provide similar information.
+            return "%s.%s" % (obj.__module__, obj.__qualname__)
         else:
-            self.reallySet(k,v)
-
-    def __getattr__(self, k):
-        kstring='get_%s'%k
-        if hasattr(self.__class__,kstring):
-            return getattr(self,kstring)()
-        raise AttributeError("%s instance has no accessor for: %s" % (qual(self.__class__),k))
-
-    def __delattr__(self, k):
-        kstring='del_%s'%k
-        if hasattr(self.__class__,kstring):
-            getattr(self,kstring)()
-            return
-        self.reallyDel(k)
-
-    def reallySet(self, k,v):
-        """
-        *actually* set self.k to v without incurring side-effects.
-        This is a hook to be overridden by subclasses.
-        """
-        if k == "__dict__":
-            self.__dict__.clear()
-            self.__dict__.update(v)
+            className = fullyQualifiedName(cls)
+            return "%s.%s" % (className, name)
+    return name
+
+
+def prefixedMethodNames(classObj, prefix):
+    """
+    Given a class object C{classObj}, returns a list of method names that match
+    the string C{prefix}.
+
+    @param classObj: A class object from which to collect method names.
+
+    @param prefix: A native string giving a prefix.  Each method with a name
+        which begins with this prefix will be returned.
+    @type prefix: L{str}
+
+    @return: A list of the names of matching methods of C{classObj} (and base
+        classes of C{classObj}).
+    @rtype: L{list} of L{str}
+    """
+    dct = {}
+    addMethodNamesToDict(classObj, dct, prefix)
+    return list(dct.keys())
+
+
+
+def addMethodNamesToDict(classObj, dict, prefix, baseClass=None):
+    """
+    This goes through C{classObj} (and its bases) and puts method names
+    starting with 'prefix' in 'dict' with a value of 1. if baseClass isn't
+    None, methods will only be added if classObj is-a baseClass
+
+    If the class in question has the methods 'prefix_methodname' and
+    'prefix_methodname2', the resulting dict should look something like:
+    {"methodname": 1, "methodname2": 1}.
+
+    @param classObj: A class object from which to collect method names.
+
+    @param dict: A L{dict} which will be updated with the results of the
+        accumulation.  Items are added to this dictionary, with method names as
+        keys and C{1} as values.
+    @type dict: L{dict}
+
+    @param prefix: A native string giving a prefix.  Each method of C{classObj}
+        (and base classes of C{classObj}) with a name which begins with this
+        prefix will be returned.
+    @type prefix: L{str}
+
+    @param baseClass: A class object at which to stop searching upwards for new
+        methods.  To collect all method names, do not pass a value for this
+        parameter.
+
+    @return: C{None}
+    """
+    for base in classObj.__bases__:
+        addMethodNamesToDict(base, dict, prefix, baseClass)
+
+    if baseClass is None or baseClass in classObj.__bases__:
+        for name, method in classObj.__dict__.items():
+            optName = name[len(prefix):]
+            if ((type(method) is types.FunctionType)
+                and (name[:len(prefix)] == prefix)
+                and (len(optName))):
+                dict[optName] = 1
+
+
+
+def prefixedMethods(obj, prefix=''):
+    """
+    Given an object C{obj}, returns a list of method objects that match the
+    string C{prefix}.
+
+    @param obj: An arbitrary object from which to collect methods.
+
+    @param prefix: A native string giving a prefix.  Each method of C{obj} with
+        a name which begins with this prefix will be returned.
+    @type prefix: L{str}
+
+    @return: A list of the matching method objects.
+    @rtype: L{list}
+    """
+    dct = {}
+    accumulateMethods(obj, dct, prefix)
+    return list(dct.values())
+
+
+
+def accumulateMethods(obj, dict, prefix='', curClass=None):
+    """
+    Given an object C{obj}, add all methods that begin with C{prefix}.
+
+    @param obj: An arbitrary object to collect methods from.
+
+    @param dict: A L{dict} which will be updated with the results of the
+        accumulation.  Items are added to this dictionary, with method names as
+        keys and corresponding instance method objects as values.
+    @type dict: L{dict}
+
+    @param prefix: A native string giving a prefix.  Each method of C{obj} with
+        a name which begins with this prefix will be returned.
+    @type prefix: L{str}
+
+    @param curClass: The class in the inheritance hierarchy at which to start
+        collecting methods.  Collection proceeds up.  To collect all methods
+        from C{obj}, do not pass a value for this parameter.
+
+    @return: C{None}
+    """
+    if not curClass:
+        curClass = obj.__class__
+    for base in curClass.__bases__:
+        accumulateMethods(obj, dict, prefix, base)
+
+    for name, method in curClass.__dict__.items():
+        optName = name[len(prefix):]
+        if ((type(method) is types.FunctionType)
+            and (name[:len(prefix)] == prefix)
+            and (len(optName))):
+            dict[optName] = getattr(obj, name)
+
+
+
+def namedModule(name):
+    """
+    Return a module given its name.
+    """
+    topLevel = __import__(name)
+    packages = name.split(".")[1:]
+    m = topLevel
+    for p in packages:
+        m = getattr(m, p)
+    return m
+
+
+
+def namedObject(name):
+    """
+    Get a fully named module-global object.
+    """
+    classSplit = name.split('.')
+    module = namedModule('.'.join(classSplit[:-1]))
+    return getattr(module, classSplit[-1])
+
+namedClass = namedObject # backwards compat
+
+
+
+class _NoModuleFound(Exception):
+    """
+    No module was found because none exists.
+    """
+
+
+
+class InvalidName(ValueError):
+    """
+    The given name is not a dot-separated list of Python objects.
+    """
+
+
+
+class ModuleNotFound(InvalidName):
+    """
+    The module associated with the given name doesn't exist and it can't be
+    imported.
+    """
+
+
+
+class ObjectNotFound(InvalidName):
+    """
+    The object associated with the given name doesn't exist and it can't be
+    imported.
+    """
+
+
+
+def _importAndCheckStack(importName):
+    """
+    Import the given name as a module, then walk the stack to determine whether
+    the failure was the module not existing, or some code in the module (for
+    example a dependent import) failing.  This can be helpful to determine
+    whether any actual application code was run.  For example, to distiguish
+    administrative error (entering the wrong module name), from programmer
+    error (writing buggy code in a module that fails to import).
+
+    @param importName: The name of the module to import.
+    @type importName: C{str}
+    @raise Exception: if something bad happens.  This can be any type of
+        exception, since nobody knows what loading some arbitrary code might
+        do.
+    @raise _NoModuleFound: if no module was found.
+    """
+    try:
+        return __import__(importName)
+    except ImportError:
+        excType, excValue, excTraceback = sys.exc_info()
+        while excTraceback:
+            execName = excTraceback.tb_frame.f_globals["__name__"]
+            # in Python 2 execName is None when an ImportError is encountered,
+            # where in Python 3 execName is equal to the importName.
+            if execName is None or execName == importName:
+                reraise(excValue, excTraceback)
+            excTraceback = excTraceback.tb_next
+        raise _NoModuleFound()
+
+
+
+def namedAny(name):
+    """
+    Retrieve a Python object by its fully qualified name from the global Python
+    module namespace.  The first part of the name, that describes a module,
+    will be discovered and imported.  Each subsequent part of the name is
+    treated as the name of an attribute of the object specified by all of the
+    name which came before it.  For example, the fully-qualified name of this
+    object is 'twisted.python.reflect.namedAny'.
+
+    @type name: L{str}
+    @param name: The name of the object to return.
+
+    @raise InvalidName: If the name is an empty string, starts or ends with
+        a '.', or is otherwise syntactically incorrect.
+
+    @raise ModuleNotFound: If the name is syntactically correct but the
+        module it specifies cannot be imported because it does not appear to
+        exist.
+
+    @raise ObjectNotFound: If the name is syntactically correct, includes at
+        least one '.', but the module it specifies cannot be imported because
+        it does not appear to exist.
+
+    @raise AttributeError: If an attribute of an object along the way cannot be
+        accessed, or a module along the way is not found.
+
+    @return: the Python object identified by 'name'.
+    """
+    if not name:
+        raise InvalidName('Empty module name')
+
+    names = name.split('.')
+
+    # if the name starts or ends with a '.' or contains '..', the __import__
+    # will raise an 'Empty module name' error. This will provide a better error
+    # message.
+    if '' in names:
+        raise InvalidName(
+            "name must be a string giving a '.'-separated list of Python "
+            "identifiers, not %r" % (name,))
+
+    topLevelPackage = None
+    moduleNames = names[:]
+    while not topLevelPackage:
+        if moduleNames:
+            trialname = '.'.join(moduleNames)
+            try:
+                topLevelPackage = _importAndCheckStack(trialname)
+            except _NoModuleFound:
+                moduleNames.pop()
         else:
-            self.__dict__[k]=v
-
-    def reallyDel(self, k):
-        """
-        *actually* del self.k without incurring side-effects.  This is a
-        hook to be overridden by subclasses.
-        """
-        del self.__dict__[k]
-
-# just in case
-OriginalAccessor = Accessor
-deprecatedModuleAttribute(
-    Version("Twisted", 12, 1, 0),
-    "OriginalAccessor is a reference to class twisted.python.reflect.Accessor "
-    "which is deprecated.", "twisted.python.reflect", "OriginalAccessor")
-
-
-class Summer(Accessor):
-    """
-    Extend from this class to get the capability to maintain 'related
-    sums'.  Have a tuple in your class like the following::
-
-        sums=(('amount','credit','credit_total'),
-              ('amount','debit','debit_total'))
-
-    and the 'credit_total' member of the 'credit' member of self will
-    always be incremented when the 'amount' member of self is
-    incremented, similiarly for the debit versions.
-    """
-
-    deprecatedModuleAttribute(
-        Version("Twisted", 12, 1, 0),
-        "Summer is a child class of twisted.python.reflect.Accessor which is " 
-        "deprecated.", "twisted.python.reflect", "Summer")
-
-    def reallySet(self, k,v):
-        "This method does the work."
-        for sum in self.sums:
-            attr=sum[0]
-            obj=sum[1]
-            objattr=sum[2]
-            if k == attr:
-                try:
-                    oldval=getattr(self, attr)
-                except:
-                    oldval=0
-                diff=v-oldval
-                if hasattr(self, obj):
-                    ob=getattr(self,obj)
-                    if ob is not None:
-                        try:oldobjval=getattr(ob, objattr)
-                        except:oldobjval=0.0
-                        setattr(ob,objattr,oldobjval+diff)
-
-            elif k == obj:
-                if hasattr(self, attr):
-                    x=getattr(self,attr)
-                    setattr(self,attr,0)
-                    y=getattr(self,k)
-                    Accessor.reallySet(self,k,v)
-                    setattr(self,attr,x)
-                    Accessor.reallySet(self,y,v)
-        Accessor.reallySet(self,k,v)
+            if len(names) == 1:
+                raise ModuleNotFound("No module named %r" % (name,))
+            else:
+                raise ObjectNotFound('%r does not name an object' % (name,))
+
+    obj = topLevelPackage
+    for n in names[1:]:
+        obj = getattr(obj, n)
+
+    return obj
+
+
+
+def filenameToModuleName(fn):
+    """
+    Convert a name in the filesystem to the name of the Python module it is.
+
+    This is aggressive about getting a module name back from a file; it will
+    always return a string.  Aggressive means 'sometimes wrong'; it won't look
+    at the Python path or try to do any error checking: don't use this method
+    unless you already know that the filename you're talking about is a Python
+    module.
+
+    @param fn: A filesystem path to a module or package; C{bytes} on Python 2,
+        C{bytes} or C{unicode} on Python 3.
+
+    @return: A hopefully importable module name.
+    @rtype: C{str}
+    """
+    if isinstance(fn, bytes):
+        initPy = b"__init__.py"
+    else:
+        initPy = "__init__.py"
+    fullName = os.path.abspath(fn)
+    base = os.path.basename(fn)
+    if not base:
+        # this happens when fn ends with a path separator, just skit it
+        base = os.path.basename(fn[:-1])
+    modName = nativeString(os.path.splitext(base)[0])
+    while 1:
+        fullName = os.path.dirname(fullName)
+        if os.path.exists(os.path.join(fullName, initPy)):
+            modName = "%s.%s" % (
+                nativeString(os.path.basename(fullName)),
+                nativeString(modName))
+        else:
+            break
+    return modName
+
+
+
+def qual(clazz):
+    """
+    Return full import path of a class.
+    """
+    return clazz.__module__ + '.' + clazz.__name__
+
+
+
+def _determineClass(x):
+    try:
+        return x.__class__
+    except:
+        return type(x)
+
+
+
+def _determineClassName(x):
+    c = _determineClass(x)
+    try:
+        return c.__name__
+    except:
+        try:
+            return str(c)
+        except:
+            return '<BROKEN CLASS AT 0x%x>' % id(c)
+
+
+
+def _safeFormat(formatter, o):
+    """
+    Helper function for L{safe_repr} and L{safe_str}.
+    """
+    try:
+        return formatter(o)
+    except:
+        io = NativeStringIO()
+        traceback.print_exc(file=io)
+        className = _determineClassName(o)
+        tbValue = io.getvalue()
+        return "<%s instance at 0x%x with %s error:\n %s>" % (
+            className, id(o), formatter.__name__, tbValue)
+
+
+
+def safe_repr(o):
+    """
+    Returns a string representation of an object, or a string containing a
+    traceback, if that object's __repr__ raised an exception.
+
+    @param o: Any object.
+
+    @rtype: C{str}
+    """
+    return _safeFormat(repr, o)
+
+
+
+def safe_str(o):
+    """
+    Returns a string representation of an object, or a string containing a
+    traceback, if that object's __str__ raised an exception.
+
+    @param o: Any object.
+
+    @rtype: C{str}
+    """
+    return _safeFormat(str, o)
 
 
 class QueueMethod:
@@ -352,7 +508,7 @@ def getClass(obj):
 
 # I should really have a better name for this...
 def isinst(inst,clazz):
-    if type(inst) != types.InstanceType or type(clazz)!= types.ClassType:
+    if type(inst) != compat.InstanceType or type(clazz)!= types.ClassType:
         return isinstance(inst,clazz)
     cl = inst.__class__
     cl2 = getcurrent(cl)
@@ -370,30 +526,6 @@ def isinst(inst,clazz):
 
 ## the following were factored out of usage
 
-@deprecated(Version("Twisted", 11, 0, 0), "inspect.getmro")
-def allYourBase(classObj, baseClass=None):
-    """
-    allYourBase(classObj, baseClass=None) -> list of all base
-    classes that are subclasses of baseClass, unless it is None,
-    in which case all bases will be added.
-    """
-    l = []
-    _accumulateBases(classObj, l, baseClass)
-    return l
-
-
-@deprecated(Version("Twisted", 11, 0, 0), "inspect.getmro")
-def accumulateBases(classObj, l, baseClass=None):
-    _accumulateBases(classObj, l, baseClass)
-
-
-def _accumulateBases(classObj, l, baseClass=None):
-    for base in classObj.__bases__:
-        if baseClass is None or issubclass(base, baseClass):
-            l.append(base)
-        _accumulateBases(base, l, baseClass)
-
-
 def accumulateClassDict(classObj, attr, adict, baseClass=None):
     """
     Accumulate all attributes of a given name in a class hierarchy into a single dictionary.
@@ -457,7 +589,7 @@ def modgrep(goal):
 
 def isOfType(start, goal):
     return ((type(start) is goal) or
-            (isinstance(start, types.InstanceType) and
+            (isinstance(start, compat.InstanceType) and
              start.__class__ is goal))
 
 
@@ -483,33 +615,33 @@ def objgrep(start, goal, eq=isLike, path='', paths=None, seen=None, showUnknowns
             return
         maxDepth -= 1
     seen[id(start)] = start
-    if isinstance(start, types.DictionaryType):
+    if isinstance(start, dict):
         for k, v in start.items():
             objgrep(k, goal, eq, path+'{'+repr(v)+'}', paths, seen, showUnknowns, maxDepth)
             objgrep(v, goal, eq, path+'['+repr(k)+']', paths, seen, showUnknowns, maxDepth)
     elif isinstance(start, (list, tuple, deque)):
-        for idx in xrange(len(start)):
+        for idx, _elem in enumerate(start):
             objgrep(start[idx], goal, eq, path+'['+str(idx)+']', paths, seen, showUnknowns, maxDepth)
     elif isinstance(start, types.MethodType):
-        objgrep(start.im_self, goal, eq, path+'.im_self', paths, seen, showUnknowns, maxDepth)
-        objgrep(start.im_func, goal, eq, path+'.im_func', paths, seen, showUnknowns, maxDepth)
-        objgrep(start.im_class, goal, eq, path+'.im_class', paths, seen, showUnknowns, maxDepth)
+        objgrep(start.__self__, goal, eq, path+'.__self__', paths, seen, showUnknowns, maxDepth)
+        objgrep(start.__func__, goal, eq, path+'.__func__', paths, seen, showUnknowns, maxDepth)
+        objgrep(start.__self__.__class__, goal, eq, path+'.__self__.__class__', paths, seen, showUnknowns, maxDepth)
     elif hasattr(start, '__dict__'):
         for k, v in start.__dict__.items():
             objgrep(v, goal, eq, path+'.'+k, paths, seen, showUnknowns, maxDepth)
-        if isinstance(start, types.InstanceType):
+        if isinstance(start, compat.InstanceType):
             objgrep(start.__class__, goal, eq, path+'.__class__', paths, seen, showUnknowns, maxDepth)
     elif isinstance(start, weakref.ReferenceType):
         objgrep(start(), goal, eq, path+'()', paths, seen, showUnknowns, maxDepth)
-    elif (isinstance(start, types.StringTypes+
-                    (types.IntType, types.FunctionType,
-                     types.BuiltinMethodType, RegexType, types.FloatType,
-                     types.NoneType, types.FileType)) or
+    elif (isinstance(start, (compat.StringType,
+                    int, types.FunctionType,
+                     types.BuiltinMethodType, RegexType, float,
+                     type(None), compat.FileType)) or
           type(start).__name__ in ('wrapper_descriptor', 'method_descriptor',
                                    'member_descriptor', 'getset_descriptor')):
         pass
     elif showUnknowns:
-        print 'unknown type', type(start), start
+        print('unknown type', type(start), start)
     return paths
 
 
@@ -519,12 +651,11 @@ __all__ = [
 
     'ISNT', 'WAS', 'IS',
 
-    'Settable', 'AccessorType', 'PropertyAccessor', 'Accessor', 'Summer',
-    'QueueMethod', 'OriginalAccessor',
+    'QueueMethod',
 
     'funcinfo', 'fullFuncName', 'qual', 'getcurrent', 'getClass', 'isinst',
     'namedModule', 'namedObject', 'namedClass', 'namedAny',
-    'safe_repr', 'safe_str', 'allYourBase', 'accumulateBases',
+    'safe_repr', 'safe_str',
     'prefixedMethodNames', 'addMethodNamesToDict', 'prefixedMethods',
     'accumulateMethods',
     'accumulateClassDict', 'accumulateClassList', 'isSame', 'isLike',
diff --git twisted/python/test/test_deprecate.py twisted/python/test/test_deprecate.py
index 1b4ebd1..a8c09bd 100644
--- twisted/python/test/test_deprecate.py
+++ twisted/python/test/test_deprecate.py
@@ -20,9 +20,9 @@ from twisted.python.deprecate import _getDeprecationWarningString
 from twisted.python.deprecate import DEPRECATION_WARNING_FORMAT
 from twisted.python.deprecate import (
     getDeprecationWarningString,
-    deprecated, _appendToDocstring, _getDeprecationDocstring,
-    _fullyQualifiedName as fullyQualifiedName)
+    deprecated, _appendToDocstring, _getDeprecationDocstring)
 
+from twisted.python.reflect import fullyQualifiedName
 from twisted.python.versions import Version
 from twisted.python.filepath import FilePath
 
diff --git twisted/python/test/test_reflectpy3.py twisted/python/test/test_reflectpy3.py
deleted file mode 100644
index 03c1178..0000000
--- twisted/python/test/test_reflectpy3.py
+++ /dev/null
@@ -1,670 +0,0 @@
-# Copyright (c) Twisted Matrix Laboratories.
-# See LICENSE for details.
-
-"""
-Tests for the parts of L{twisted.python.reflect} which have been ported to
-Python 3.
-"""
-
-from __future__ import division, absolute_import
-
-import os
-
-from twisted.trial.unittest import SynchronousTestCase as TestCase
-
-from twisted.python._reflectpy3 import (
-    accumulateMethods, prefixedMethods, prefixedMethodNames,
-    addMethodNamesToDict)
-from twisted.python import _reflectpy3 as reflect
-# After twisted.python.reflect is fully ported to Python 3, import
-# fullyQualifiedName from there instead, to test the actual public interface
-# instead of this implementation detail.  See #5929.
-from twisted.python.deprecate import _fullyQualifiedName as fullyQualifiedName
-
-
-
-class Base(object):
-    """
-    A no-op class which can be used to verify the behavior of
-    method-discovering APIs.
-    """
-
-    def method(self):
-        """
-        A no-op method which can be discovered.
-        """
-
-
-
-class Sub(Base):
-    """
-    A subclass of a class with a method which can be discovered.
-    """
-
-
-
-class Separate(object):
-    """
-    A no-op class with methods with differing prefixes.
-    """
-
-    def good_method(self):
-        """
-        A no-op method which a matching prefix to be discovered.
-        """
-
-
-    def bad_method(self):
-        """
-        A no-op method with a mismatched prefix to not be discovered.
-        """
-
-
-
-class AccumulateMethodsTests(TestCase):
-    """
-    Tests for L{accumulateMethods} which finds methods on a class hierarchy and
-    adds them to a dictionary.
-    """
-
-    def test_ownClass(self):
-        """
-        If x is and instance of Base and Base defines a method named method,
-        L{accumulateMethods} adds an item to the given dictionary with
-        C{"method"} as the key and a bound method object for Base.method value.
-        """
-        x = Base()
-        output = {}
-        accumulateMethods(x, output)
-        self.assertEqual({"method": x.method}, output)
-
-
-    def test_baseClass(self):
-        """
-        If x is an instance of Sub and Sub is a subclass of Base and Base
-        defines a method named method, L{accumulateMethods} adds an item to the
-        given dictionary with C{"method"} as the key and a bound method object
-        for Base.method as the value.
-        """
-        x = Sub()
-        output = {}
-        accumulateMethods(x, output)
-        self.assertEqual({"method": x.method}, output)
-
-
-    def test_prefix(self):
-        """
-        If a prefix is given, L{accumulateMethods} limits its results to
-        methods beginning with that prefix.  Keys in the resulting dictionary
-        also have the prefix removed from them.
-        """
-        x = Separate()
-        output = {}
-        accumulateMethods(x, output, 'good_')
-        self.assertEqual({'method': x.good_method}, output)
-
-
-
-class PrefixedMethodsTests(TestCase):
-    """
-    Tests for L{prefixedMethods} which finds methods on a class hierarchy and
-    adds them to a dictionary.
-    """
-
-    def test_onlyObject(self):
-        """
-        L{prefixedMethods} returns a list of the methods discovered on an
-        object.
-        """
-        x = Base()
-        output = prefixedMethods(x)
-        self.assertEqual([x.method], output)
-
-
-    def test_prefix(self):
-        """
-        If a prefix is given, L{prefixedMethods} returns only methods named
-        with that prefix.
-        """
-        x = Separate()
-        output = prefixedMethods(x, 'good_')
-        self.assertEqual([x.good_method], output)
-
-
-
-class PrefixedMethodNamesTests(TestCase):
-    """
-    Tests for L{prefixedMethodNames}.
-    """
-    def test_method(self):
-        """
-        L{prefixedMethodNames} returns a list including methods with the given
-        prefix defined on the class passed to it.
-        """
-        self.assertEqual(["method"], prefixedMethodNames(Separate, "good_"))
-
-
-    def test_inheritedMethod(self):
-        """
-        L{prefixedMethodNames} returns a list included methods with the given
-        prefix defined on base classes of the class passed to it.
-        """
-        class Child(Separate):
-            pass
-        self.assertEqual(["method"], prefixedMethodNames(Child, "good_"))
-
-
-
-class AddMethodNamesToDictTests(TestCase):
-    """
-    Tests for L{addMethodNamesToDict}.
-    """
-    def test_baseClass(self):
-        """
-        If C{baseClass} is passed to L{addMethodNamesToDict}, only methods which
-        are a subclass of C{baseClass} are added to the result dictionary.
-        """
-        class Alternate(object):
-            pass
-
-        class Child(Separate, Alternate):
-            def good_alternate(self):
-                pass
-
-        result = {}
-        addMethodNamesToDict(Child, result, 'good_', Alternate)
-        self.assertEqual({'alternate': 1}, result)
-
-
-
-class Summer(object):
-    """
-    A class we look up as part of the LookupsTestCase.
-    """
-
-    def reallySet(self):
-        """
-        Do something.
-        """
-
-
-
-class LookupsTestCase(TestCase):
-    """
-    Tests for L{namedClass}, L{namedModule}, and L{namedAny}.
-    """
-
-    def test_namedClassLookup(self):
-        """
-        L{namedClass} should return the class object for the name it is passed.
-        """
-        self.assertIdentical(
-            reflect.namedClass("twisted.python.test.test_reflectpy3.Summer"),
-            Summer)
-
-
-    def test_namedModuleLookup(self):
-        """
-        L{namedModule} should return the module object for the name it is
-        passed.
-        """
-        from twisted.python import monkey
-        self.assertIdentical(
-            reflect.namedModule("twisted.python.monkey"), monkey)
-
-
-    def test_namedAnyPackageLookup(self):
-        """
-        L{namedAny} should return the package object for the name it is passed.
-        """
-        import twisted.python
-        self.assertIdentical(
-            reflect.namedAny("twisted.python"), twisted.python)
-
-
-    def test_namedAnyModuleLookup(self):
-        """
-        L{namedAny} should return the module object for the name it is passed.
-        """
-        from twisted.python import monkey
-        self.assertIdentical(
-            reflect.namedAny("twisted.python.monkey"), monkey)
-
-
-    def test_namedAnyClassLookup(self):
-        """
-        L{namedAny} should return the class object for the name it is passed.
-        """
-        self.assertIdentical(
-            reflect.namedAny("twisted.python.test.test_reflectpy3.Summer"),
-            Summer)
-
-
-    def test_namedAnyAttributeLookup(self):
-        """
-        L{namedAny} should return the object an attribute of a non-module,
-        non-package object is bound to for the name it is passed.
-        """
-        # Note - not assertEqual because unbound method lookup creates a new
-        # object every time.  This is a foolishness of Python's object
-        # implementation, not a bug in Twisted.
-        self.assertEqual(
-            reflect.namedAny(
-                "twisted.python.test.test_reflectpy3.Summer.reallySet"),
-            Summer.reallySet)
-
-
-    def test_namedAnySecondAttributeLookup(self):
-        """
-        L{namedAny} should return the object an attribute of an object which
-        itself was an attribute of a non-module, non-package object is bound to
-        for the name it is passed.
-        """
-        self.assertIdentical(
-            reflect.namedAny(
-                "twisted.python.test.test_reflectpy3."
-                "Summer.reallySet.__doc__"),
-            Summer.reallySet.__doc__)
-
-
-    def test_importExceptions(self):
-        """
-        Exceptions raised by modules which L{namedAny} causes to be imported
-        should pass through L{namedAny} to the caller.
-        """
-        self.assertRaises(
-            ZeroDivisionError,
-            reflect.namedAny, "twisted.test.reflect_helper_ZDE")
-        # Make sure that there is post-failed-import cleanup
-        self.assertRaises(
-            ZeroDivisionError,
-            reflect.namedAny, "twisted.test.reflect_helper_ZDE")
-        self.assertRaises(
-            ValueError,
-            reflect.namedAny, "twisted.test.reflect_helper_VE")
-        # Modules which themselves raise ImportError when imported should
-        # result in an ImportError
-        self.assertRaises(
-            ImportError,
-            reflect.namedAny, "twisted.test.reflect_helper_IE")
-
-
-    def test_attributeExceptions(self):
-        """
-        If segments on the end of a fully-qualified Python name represents
-        attributes which aren't actually present on the object represented by
-        the earlier segments, L{namedAny} should raise an L{AttributeError}.
-        """
-        self.assertRaises(
-            AttributeError,
-            reflect.namedAny, "twisted.nosuchmoduleintheworld")
-        # ImportError behaves somewhat differently between "import
-        # extant.nonextant" and "import extant.nonextant.nonextant", so test
-        # the latter as well.
-        self.assertRaises(
-            AttributeError,
-            reflect.namedAny, "twisted.nosuch.modulein.theworld")
-        self.assertRaises(
-            AttributeError,
-            reflect.namedAny,
-            "twisted.python.test.test_reflectpy3.Summer.nosuchattribute")
-
-
-    def test_invalidNames(self):
-        """
-        Passing a name which isn't a fully-qualified Python name to L{namedAny}
-        should result in one of the following exceptions:
-         - L{InvalidName}: the name is not a dot-separated list of Python
-           objects
-         - L{ObjectNotFound}: the object doesn't exist
-         - L{ModuleNotFound}: the object doesn't exist and there is only one
-           component in the name
-        """
-        err = self.assertRaises(reflect.ModuleNotFound, reflect.namedAny,
-                                'nosuchmoduleintheworld')
-        self.assertEqual(str(err), "No module named 'nosuchmoduleintheworld'")
-
-        # This is a dot-separated list, but it isn't valid!
-        err = self.assertRaises(reflect.ObjectNotFound, reflect.namedAny,
-                                "@#$@(#.!@(#!@#")
-        self.assertEqual(str(err), "'@#$@(#.!@(#!@#' does not name an object")
-
-        err = self.assertRaises(reflect.ObjectNotFound, reflect.namedAny,
-                                "tcelfer.nohtyp.detsiwt")
-        self.assertEqual(
-            str(err),
-            "'tcelfer.nohtyp.detsiwt' does not name an object")
-
-        err = self.assertRaises(reflect.InvalidName, reflect.namedAny, '')
-        self.assertEqual(str(err), 'Empty module name')
-
-        for invalidName in ['.twisted', 'twisted.', 'twisted..python']:
-            err = self.assertRaises(
-                reflect.InvalidName, reflect.namedAny, invalidName)
-            self.assertEqual(
-                str(err),
-                "name must be a string giving a '.'-separated list of Python "
-                "identifiers, not %r" % (invalidName,))
-
-
-
-class Breakable(object):
-
-    breakRepr = False
-    breakStr = False
-
-    def __str__(self):
-        if self.breakStr:
-            raise RuntimeError("str!")
-        else:
-            return '<Breakable>'
-
-
-    def __repr__(self):
-        if self.breakRepr:
-            raise RuntimeError("repr!")
-        else:
-            return 'Breakable()'
-
-
-
-class BrokenType(Breakable, type):
-    breakName = False
-
-    def get___name__(self):
-        if self.breakName:
-            raise RuntimeError("no name")
-        return 'BrokenType'
-    __name__ = property(get___name__)
-
-
-
-BTBase = BrokenType('BTBase', (Breakable,),
-                    {"breakRepr": True,
-                     "breakStr": True})
-
-
-
-class NoClassAttr(Breakable):
-    __class__ = property(lambda x: x.not_class)
-
-
-
-class SafeRepr(TestCase):
-    """
-    Tests for L{reflect.safe_repr} function.
-    """
-
-    def test_workingRepr(self):
-        """
-        L{reflect.safe_repr} produces the same output as C{repr} on a working
-        object.
-        """
-        x = [1, 2, 3]
-        self.assertEqual(reflect.safe_repr(x), repr(x))
-
-
-    def test_brokenRepr(self):
-        """
-        L{reflect.safe_repr} returns a string with class name, address, and
-        traceback when the repr call failed.
-        """
-        b = Breakable()
-        b.breakRepr = True
-        bRepr = reflect.safe_repr(b)
-        self.assertIn("Breakable instance at 0x", bRepr)
-        # Check that the file is in the repr, but without the extension as it
-        # can be .py/.pyc
-        self.assertIn(os.path.splitext(__file__)[0], bRepr)
-        self.assertIn("RuntimeError: repr!", bRepr)
-
-
-    def test_brokenStr(self):
-        """
-        L{reflect.safe_repr} isn't affected by a broken C{__str__} method.
-        """
-        b = Breakable()
-        b.breakStr = True
-        self.assertEqual(reflect.safe_repr(b), repr(b))
-
-
-    def test_brokenClassRepr(self):
-        class X(BTBase):
-            breakRepr = True
-        reflect.safe_repr(X)
-        reflect.safe_repr(X())
-
-
-    def test_brokenReprIncludesID(self):
-        """
-        C{id} is used to print the ID of the object in case of an error.
-
-        L{safe_repr} includes a traceback after a newline, so we only check
-        against the first line of the repr.
-        """
-        class X(BTBase):
-            breakRepr = True
-
-        xRepr = reflect.safe_repr(X)
-        xReprExpected = ('<BrokenType instance at 0x%x with repr error:'
-                         % (id(X),))
-        self.assertEqual(xReprExpected, xRepr.split('\n')[0])
-
-
-    def test_brokenClassStr(self):
-        class X(BTBase):
-            breakStr = True
-        reflect.safe_repr(X)
-        reflect.safe_repr(X())
-
-
-    def test_brokenClassAttribute(self):
-        """
-        If an object raises an exception when accessing its C{__class__}
-        attribute, L{reflect.safe_repr} uses C{type} to retrieve the class
-        object.
-        """
-        b = NoClassAttr()
-        b.breakRepr = True
-        bRepr = reflect.safe_repr(b)
-        self.assertIn("NoClassAttr instance at 0x", bRepr)
-        self.assertIn(os.path.splitext(__file__)[0], bRepr)
-        self.assertIn("RuntimeError: repr!", bRepr)
-
-
-    def test_brokenClassNameAttribute(self):
-        """
-        If a class raises an exception when accessing its C{__name__} attribute
-        B{and} when calling its C{__str__} implementation, L{reflect.safe_repr}
-        returns 'BROKEN CLASS' instead of the class name.
-        """
-        class X(BTBase):
-            breakName = True
-        xRepr = reflect.safe_repr(X())
-        self.assertIn("<BROKEN CLASS AT 0x", xRepr)
-        self.assertIn(os.path.splitext(__file__)[0], xRepr)
-        self.assertIn("RuntimeError: repr!", xRepr)
-
-
-
-class SafeStr(TestCase):
-    """
-    Tests for L{reflect.safe_str} function.
-    """
-
-    def test_workingStr(self):
-        x = [1, 2, 3]
-        self.assertEqual(reflect.safe_str(x), str(x))
-
-
-    def test_brokenStr(self):
-        b = Breakable()
-        b.breakStr = True
-        reflect.safe_str(b)
-
-
-    def test_brokenRepr(self):
-        b = Breakable()
-        b.breakRepr = True
-        reflect.safe_str(b)
-
-
-    def test_brokenClassStr(self):
-        class X(BTBase):
-            breakStr = True
-        reflect.safe_str(X)
-        reflect.safe_str(X())
-
-
-    def test_brokenClassRepr(self):
-        class X(BTBase):
-            breakRepr = True
-        reflect.safe_str(X)
-        reflect.safe_str(X())
-
-
-    def test_brokenClassAttribute(self):
-        """
-        If an object raises an exception when accessing its C{__class__}
-        attribute, L{reflect.safe_str} uses C{type} to retrieve the class
-        object.
-        """
-        b = NoClassAttr()
-        b.breakStr = True
-        bStr = reflect.safe_str(b)
-        self.assertIn("NoClassAttr instance at 0x", bStr)
-        self.assertIn(os.path.splitext(__file__)[0], bStr)
-        self.assertIn("RuntimeError: str!", bStr)
-
-
-    def test_brokenClassNameAttribute(self):
-        """
-        If a class raises an exception when accessing its C{__name__} attribute
-        B{and} when calling its C{__str__} implementation, L{reflect.safe_str}
-        returns 'BROKEN CLASS' instead of the class name.
-        """
-        class X(BTBase):
-            breakName = True
-        xStr = reflect.safe_str(X())
-        self.assertIn("<BROKEN CLASS AT 0x", xStr)
-        self.assertIn(os.path.splitext(__file__)[0], xStr)
-        self.assertIn("RuntimeError: str!", xStr)
-
-
-
-class FilenameToModule(TestCase):
-    """
-    Test L{filenameToModuleName} detection.
-    """
-
-    def setUp(self):
-        self.path = os.path.join(self.mktemp(), "fakepackage", "test")
-        os.makedirs(self.path)
-        with open(os.path.join(self.path, "__init__.py"), "w") as f:
-            f.write("")
-        with open(os.path.join(os.path.dirname(self.path), "__init__.py"),
-                  "w") as f:
-            f.write("")
-
-
-    def test_directory(self):
-        """
-        L{filenameToModuleName} returns the correct module (a package) given a
-        directory.
-        """
-        module = reflect.filenameToModuleName(self.path)
-        self.assertEqual(module, 'fakepackage.test')
-        module = reflect.filenameToModuleName(self.path + os.path.sep)
-        self.assertEqual(module, 'fakepackage.test')
-
-
-    def test_file(self):
-        """
-        L{filenameToModuleName} returns the correct module given the path to
-        its file.
-        """
-        module = reflect.filenameToModuleName(
-            os.path.join(self.path, 'test_reflect.py'))
-        self.assertEqual(module, 'fakepackage.test.test_reflect')
-
-
-    def test_bytes(self):
-        """
-        L{filenameToModuleName} returns the correct module given a C{bytes}
-        path to its file.
-        """
-        module = reflect.filenameToModuleName(
-            os.path.join(self.path.encode("utf-8"), b'test_reflect.py'))
-        # Module names are always native string:
-        self.assertEqual(module, 'fakepackage.test.test_reflect')
-
-
-
-class FullyQualifiedNameTests(TestCase):
-    """
-    Test for L{fullyQualifiedName}.
-    """
-
-    def _checkFullyQualifiedName(self, obj, expected):
-        """
-        Helper to check that fully qualified name of C{obj} results to
-        C{expected}.
-        """
-        self.assertEqual(fullyQualifiedName(obj), expected)
-
-
-    def test_package(self):
-        """
-        L{fullyQualifiedName} returns the full name of a package and a
-        subpackage.
-        """
-        import twisted
-        self._checkFullyQualifiedName(twisted, 'twisted')
-        import twisted.python
-        self._checkFullyQualifiedName(twisted.python, 'twisted.python')
-
-
-    def test_module(self):
-        """
-        L{fullyQualifiedName} returns the name of a module inside a a package.
-        """
-        import twisted.python.compat
-        self._checkFullyQualifiedName(
-            twisted.python.compat, 'twisted.python.compat')
-
-
-    def test_class(self):
-        """
-        L{fullyQualifiedName} returns the name of a class and its module.
-        """
-        self._checkFullyQualifiedName(
-            FullyQualifiedNameTests,
-            '%s.FullyQualifiedNameTests' % (__name__,))
-
-
-    def test_function(self):
-        """
-        L{fullyQualifiedName} returns the name of a function inside its module.
-        """
-        self._checkFullyQualifiedName(
-            fullyQualifiedName, "twisted.python.reflect.fullyQualifiedName")
-
-
-    def test_boundMethod(self):
-        """
-        L{fullyQualifiedName} returns the name of a bound method inside its
-        class and its module.
-        """
-        self._checkFullyQualifiedName(
-            self.test_boundMethod,
-            "%s.%s.test_boundMethod" % (__name__, self.__class__.__name__))
-
-
-    def test_unboundMethod(self):
-        """
-        L{fullyQualifiedName} returns the name of an unbound method inside its
-        class and its module.
-        """
-        self._checkFullyQualifiedName(
-            self.__class__.test_unboundMethod,
-            "%s.%s.test_unboundMethod" % (__name__, self.__class__.__name__))
diff --git twisted/python/test/test_util.py twisted/python/test/test_util.py
index 5d3547d..15030bc 100644
--- twisted/python/test/test_util.py
+++ twisted/python/test/test_util.py
@@ -20,6 +20,7 @@ from twisted.trial.util import suppress as SUPPRESS
 
 from twisted.python.compat import _PY3
 from twisted.python import util
+from twisted.python.reflect import fullyQualifiedName
 from twisted.python.versions import Version
 from twisted.internet import reactor
 from twisted.internet.interfaces import IReactorProcess
@@ -29,10 +30,8 @@ from twisted.internet.error import ProcessDone
 
 if _PY3:
     MockOS = None
-    from twisted.python.deprecate import _fullyQualifiedName as fullyQualifiedName
 else:
     from twisted.test.test_process import MockOS
-    from twisted.python.reflect import fullyQualifiedName
 
 
 
diff --git twisted/test/test_failure.py twisted/test/test_failure.py
index 435ba99..2debd9d 100644
--- twisted/test/test_failure.py
+++ twisted/test/test_failure.py
@@ -14,7 +14,7 @@ import pdb
 import linecache
 
 from twisted.python.compat import NativeStringIO, _PY3
-from twisted.python import _reflectpy3 as reflect
+from twisted.python import reflect
 from twisted.python import failure
 
 from twisted.trial.unittest import SynchronousTestCase
diff --git twisted/test/test_reflect.py twisted/test/test_reflect.py
index 4a66211..8e033ec 100644
--- twisted/test/test_reflect.py
+++ twisted/test/test_reflect.py
@@ -5,6 +5,9 @@
 Test cases for the L{twisted.python.reflect} module.
 """
 
+from __future__ import division, absolute_import
+
+import os
 import weakref
 import warnings
 from collections import deque
@@ -14,139 +17,661 @@ try:
 except ImportError:
     ModuleImporter = None
 
+from twisted.python.compat import _PY3
 from twisted.trial import unittest
 from twisted.python import reflect
 from twisted.python.versions import Version
-from twisted.python.test.test_reflectpy3 import LookupsTestCase
+from twisted.python.reflect import (
+    accumulateMethods, prefixedMethods, prefixedMethodNames,
+    addMethodNamesToDict, fullyQualifiedName)
+
 
-with warnings.catch_warnings():
-    warnings.filterwarnings(action="ignore", category=DeprecationWarning,
-            message="twisted.python.reflect.Accessor was deprecated")
-    warnings.filterwarnings(action="ignore", category=DeprecationWarning,
-            message="twisted.python.reflect.PropertyAccessor was deprecated")
-    warnings.filterwarnings(action="ignore", category=DeprecationWarning,
-            message="twisted.python.reflect.Settable was deprecated")
+class Base(object):
+    """
+    A no-op class which can be used to verify the behavior of
+    method-discovering APIs.
+    """
 
-    from twisted.python.reflect import Accessor, PropertyAccessor, Settable
+    def method(self):
+        """
+        A no-op method which can be discovered.
+        """
 
 
-class SettableTest(unittest.TestCase):
-    def setUp(self):
-        self.setter = Settable()
 
-    def tearDown(self):
-        del self.setter
+class Sub(Base):
+    """
+    A subclass of a class with a method which can be discovered.
+    """
+
+
+
+class Separate(object):
+    """
+    A no-op class with methods with differing prefixes.
+    """
 
-    def testSet(self):
-        self.setter(a=1, b=2)
-        self.assertEqual(self.setter.a, 1)
-        self.assertEqual(self.setter.b, 2)
+    def good_method(self):
+        """
+        A no-op method which a matching prefix to be discovered.
+        """
 
 
+    def bad_method(self):
+        """
+        A no-op method with a mismatched prefix to not be discovered.
+        """
 
-class AccessorTester(Accessor):
 
-    def set_x(self, x):
-        self.y = x
-        self.reallySet('x', x)
 
+class AccumulateMethodsTests(unittest.SynchronousTestCase):
+    """
+    Tests for L{accumulateMethods} which finds methods on a class hierarchy and
+    adds them to a dictionary.
+    """
 
-    def get_z(self):
-        self.q = 1
-        return 1
+    def test_ownClass(self):
+        """
+        If x is and instance of Base and Base defines a method named method,
+        L{accumulateMethods} adds an item to the given dictionary with
+        C{"method"} as the key and a bound method object for Base.method value.
+        """
+        x = Base()
+        output = {}
+        accumulateMethods(x, output)
+        self.assertEqual({"method": x.method}, output)
 
 
-    def del_z(self):
-        self.reallyDel("q")
+    def test_baseClass(self):
+        """
+        If x is an instance of Sub and Sub is a subclass of Base and Base
+        defines a method named method, L{accumulateMethods} adds an item to the
+        given dictionary with C{"method"} as the key and a bound method object
+        for Base.method as the value.
+        """
+        x = Sub()
+        output = {}
+        accumulateMethods(x, output)
+        self.assertEqual({"method": x.method}, output)
 
 
+    def test_prefix(self):
+        """
+        If a prefix is given, L{accumulateMethods} limits its results to
+        methods beginning with that prefix.  Keys in the resulting dictionary
+        also have the prefix removed from them.
+        """
+        x = Separate()
+        output = {}
+        accumulateMethods(x, output, 'good_')
+        self.assertEqual({'method': x.good_method}, output)
 
-class PropertyAccessorTester(PropertyAccessor):
+
+
+class PrefixedMethodsTests(unittest.SynchronousTestCase):
     """
-    Test class to check L{reflect.PropertyAccessor} functionalities.
+    Tests for L{prefixedMethods} which finds methods on a class hierarchy and
+    adds them to a dictionary.
     """
-    r = 0
 
-    def set_r(self, r):
-        self.s = r
+    def test_onlyObject(self):
+        """
+        L{prefixedMethods} returns a list of the methods discovered on an
+        object.
+        """
+        x = Base()
+        output = prefixedMethods(x)
+        self.assertEqual([x.method], output)
+
 
+    def test_prefix(self):
+        """
+        If a prefix is given, L{prefixedMethods} returns only methods named
+        with that prefix.
+        """
+        x = Separate()
+        output = prefixedMethods(x, 'good_')
+        self.assertEqual([x.good_method], output)
 
-    def set_x(self, x):
-        self.y = x
-        self.reallySet('x', x)
 
 
-    def get_z(self):
-        self.q = 1
-        return 1
+class PrefixedMethodNamesTests(unittest.SynchronousTestCase):
+    """
+    Tests for L{prefixedMethodNames}.
+    """
+    def test_method(self):
+        """
+        L{prefixedMethodNames} returns a list including methods with the given
+        prefix defined on the class passed to it.
+        """
+        self.assertEqual(["method"], prefixedMethodNames(Separate, "good_"))
 
 
-    def del_z(self):
-        self.reallyDel("q")
+    def test_inheritedMethod(self):
+        """
+        L{prefixedMethodNames} returns a list included methods with the given
+        prefix defined on base classes of the class passed to it.
+        """
+        class Child(Separate):
+            pass
+        self.assertEqual(["method"], prefixedMethodNames(Child, "good_"))
 
 
 
-class AccessorTest(unittest.TestCase):
-    def setUp(self):
-        self.tester = AccessorTester()
+class AddMethodNamesToDictTests(unittest.SynchronousTestCase):
+    """
+    Tests for L{addMethodNamesToDict}.
+    """
+    def test_baseClass(self):
+        """
+        If C{baseClass} is passed to L{addMethodNamesToDict}, only methods which
+        are a subclass of C{baseClass} are added to the result dictionary.
+        """
+        class Alternate(object):
+            pass
+
+        class Child(Separate, Alternate):
+            def good_alternate(self):
+                pass
 
-    def testSet(self):
-        self.tester.x = 1
-        self.assertEqual(self.tester.x, 1)
-        self.assertEqual(self.tester.y, 1)
+        result = {}
+        addMethodNamesToDict(Child, result, 'good_', Alternate)
+        self.assertEqual({'alternate': 1}, result)
 
-    def testGet(self):
-        self.assertEqual(self.tester.z, 1)
-        self.assertEqual(self.tester.q, 1)
 
-    def testDel(self):
-        self.tester.z
-        self.assertEqual(self.tester.q, 1)
-        del self.tester.z
-        self.assertEqual(hasattr(self.tester, "q"), 0)
-        self.tester.x = 1
-        del self.tester.x
-        self.assertEqual(hasattr(self.tester, "x"), 0)
 
+class Summer(object):
+    """
+    A class we look up as part of the LookupsTestCase.
+    """
 
+    def reallySet(self):
+        """
+        Do something.
+        """
 
-class PropertyAccessorTest(AccessorTest):
+
+
+class LookupsTestCase(unittest.SynchronousTestCase):
     """
-    Tests for L{reflect.PropertyAccessor}, using L{PropertyAccessorTester}.
+    Tests for L{namedClass}, L{namedModule}, and L{namedAny}.
+    """
+
+    def test_namedClassLookup(self):
+        """
+        L{namedClass} should return the class object for the name it is passed.
+        """
+        self.assertIdentical(
+            reflect.namedClass("twisted.python.test.test_reflectpy3.Summer"),
+            Summer)
+
+
+    def test_namedModuleLookup(self):
+        """
+        L{namedModule} should return the module object for the name it is
+        passed.
+        """
+        from twisted.python import monkey
+        self.assertIdentical(
+            reflect.namedModule("twisted.python.monkey"), monkey)
+
+
+    def test_namedAnyPackageLookup(self):
+        """
+        L{namedAny} should return the package object for the name it is passed.
+        """
+        import twisted.python
+        self.assertIdentical(
+            reflect.namedAny("twisted.python"), twisted.python)
+
+
+    def test_namedAnyModuleLookup(self):
+        """
+        L{namedAny} should return the module object for the name it is passed.
+        """
+        from twisted.python import monkey
+        self.assertIdentical(
+            reflect.namedAny("twisted.python.monkey"), monkey)
+
+
+    def test_namedAnyClassLookup(self):
+        """
+        L{namedAny} should return the class object for the name it is passed.
+        """
+        self.assertIdentical(
+            reflect.namedAny("twisted.python.test.test_reflectpy3.Summer"),
+            Summer)
+
+
+    def test_namedAnyAttributeLookup(self):
+        """
+        L{namedAny} should return the object an attribute of a non-module,
+        non-package object is bound to for the name it is passed.
+        """
+        # Note - not assertEqual because unbound method lookup creates a new
+        # object every time.  This is a foolishness of Python's object
+        # implementation, not a bug in Twisted.
+        self.assertEqual(
+            reflect.namedAny(
+                "twisted.python.test.test_reflectpy3.Summer.reallySet"),
+            Summer.reallySet)
+
+
+    def test_namedAnySecondAttributeLookup(self):
+        """
+        L{namedAny} should return the object an attribute of an object which
+        itself was an attribute of a non-module, non-package object is bound to
+        for the name it is passed.
+        """
+        self.assertIdentical(
+            reflect.namedAny(
+                "twisted.python.test.test_reflectpy3."
+                "Summer.reallySet.__doc__"),
+            Summer.reallySet.__doc__)
+
+
+    def test_importExceptions(self):
+        """
+        Exceptions raised by modules which L{namedAny} causes to be imported
+        should pass through L{namedAny} to the caller.
+        """
+        self.assertRaises(
+            ZeroDivisionError,
+            reflect.namedAny, "twisted.test.reflect_helper_ZDE")
+        # Make sure that there is post-failed-import cleanup
+        self.assertRaises(
+            ZeroDivisionError,
+            reflect.namedAny, "twisted.test.reflect_helper_ZDE")
+        self.assertRaises(
+            ValueError,
+            reflect.namedAny, "twisted.test.reflect_helper_VE")
+        # Modules which themselves raise ImportError when imported should
+        # result in an ImportError
+        self.assertRaises(
+            ImportError,
+            reflect.namedAny, "twisted.test.reflect_helper_IE")
+
+
+    def test_attributeExceptions(self):
+        """
+        If segments on the end of a fully-qualified Python name represents
+        attributes which aren't actually present on the object represented by
+        the earlier segments, L{namedAny} should raise an L{AttributeError}.
+        """
+        self.assertRaises(
+            AttributeError,
+            reflect.namedAny, "twisted.nosuchmoduleintheworld")
+        # ImportError behaves somewhat differently between "import
+        # extant.nonextant" and "import extant.nonextant.nonextant", so test
+        # the latter as well.
+        self.assertRaises(
+            AttributeError,
+            reflect.namedAny, "twisted.nosuch.modulein.theworld")
+        self.assertRaises(
+            AttributeError,
+            reflect.namedAny,
+            "twisted.python.test.test_reflectpy3.Summer.nosuchattribute")
+
+
+    def test_invalidNames(self):
+        """
+        Passing a name which isn't a fully-qualified Python name to L{namedAny}
+        should result in one of the following exceptions:
+         - L{InvalidName}: the name is not a dot-separated list of Python
+           objects
+         - L{ObjectNotFound}: the object doesn't exist
+         - L{ModuleNotFound}: the object doesn't exist and there is only one
+           component in the name
+        """
+        err = self.assertRaises(reflect.ModuleNotFound, reflect.namedAny,
+                                'nosuchmoduleintheworld')
+        self.assertEqual(str(err), "No module named 'nosuchmoduleintheworld'")
+
+        # This is a dot-separated list, but it isn't valid!
+        err = self.assertRaises(reflect.ObjectNotFound, reflect.namedAny,
+                                "@#$@(#.!@(#!@#")
+        self.assertEqual(str(err), "'@#$@(#.!@(#!@#' does not name an object")
+
+        err = self.assertRaises(reflect.ObjectNotFound, reflect.namedAny,
+                                "tcelfer.nohtyp.detsiwt")
+        self.assertEqual(
+            str(err),
+            "'tcelfer.nohtyp.detsiwt' does not name an object")
+
+        err = self.assertRaises(reflect.InvalidName, reflect.namedAny, '')
+        self.assertEqual(str(err), 'Empty module name')
+
+        for invalidName in ['.twisted', 'twisted.', 'twisted..python']:
+            err = self.assertRaises(
+                reflect.InvalidName, reflect.namedAny, invalidName)
+            self.assertEqual(
+                str(err),
+                "name must be a string giving a '.'-separated list of Python "
+                "identifiers, not %r" % (invalidName,))
+
+
+
+class Breakable(object):
+
+    breakRepr = False
+    breakStr = False
+
+    def __str__(self):
+        if self.breakStr:
+            raise RuntimeError("str!")
+        else:
+            return '<Breakable>'
+
+
+    def __repr__(self):
+        if self.breakRepr:
+            raise RuntimeError("repr!")
+        else:
+            return 'Breakable()'
+
+
+
+class BrokenType(Breakable, type):
+    breakName = False
+
+    def get___name__(self):
+        if self.breakName:
+            raise RuntimeError("no name")
+        return 'BrokenType'
+    __name__ = property(get___name__)
+
+
+
+BTBase = BrokenType('BTBase', (Breakable,),
+                    {"breakRepr": True,
+                     "breakStr": True})
+
+
+
+class NoClassAttr(Breakable):
+    __class__ = property(lambda x: x.not_class)
+
+
+
+class SafeRepr(unittest.SynchronousTestCase):
+    """
+    Tests for L{reflect.safe_repr} function.
+    """
+
+    def test_workingRepr(self):
+        """
+        L{reflect.safe_repr} produces the same output as C{repr} on a working
+        object.
+        """
+        x = [1, 2, 3]
+        self.assertEqual(reflect.safe_repr(x), repr(x))
+
+
+    def test_brokenRepr(self):
+        """
+        L{reflect.safe_repr} returns a string with class name, address, and
+        traceback when the repr call failed.
+        """
+        b = Breakable()
+        b.breakRepr = True
+        bRepr = reflect.safe_repr(b)
+        self.assertIn("Breakable instance at 0x", bRepr)
+        # Check that the file is in the repr, but without the extension as it
+        # can be .py/.pyc
+        self.assertIn(os.path.splitext(__file__)[0], bRepr)
+        self.assertIn("RuntimeError: repr!", bRepr)
+
+
+    def test_brokenStr(self):
+        """
+        L{reflect.safe_repr} isn't affected by a broken C{__str__} method.
+        """
+        b = Breakable()
+        b.breakStr = True
+        self.assertEqual(reflect.safe_repr(b), repr(b))
+
+
+    def test_brokenClassRepr(self):
+        class X(BTBase):
+            breakRepr = True
+        reflect.safe_repr(X)
+        reflect.safe_repr(X())
+
+
+    def test_brokenReprIncludesID(self):
+        """
+        C{id} is used to print the ID of the object in case of an error.
+
+        L{safe_repr} includes a traceback after a newline, so we only check
+        against the first line of the repr.
+        """
+        class X(BTBase):
+            breakRepr = True
+
+        xRepr = reflect.safe_repr(X)
+        xReprExpected = ('<BrokenType instance at 0x%x with repr error:'
+                         % (id(X),))
+        self.assertEqual(xReprExpected, xRepr.split('\n')[0])
+
+
+    def test_brokenClassStr(self):
+        class X(BTBase):
+            breakStr = True
+        reflect.safe_repr(X)
+        reflect.safe_repr(X())
+
+
+    def test_brokenClassAttribute(self):
+        """
+        If an object raises an exception when accessing its C{__class__}
+        attribute, L{reflect.safe_repr} uses C{type} to retrieve the class
+        object.
+        """
+        b = NoClassAttr()
+        b.breakRepr = True
+        bRepr = reflect.safe_repr(b)
+        self.assertIn("NoClassAttr instance at 0x", bRepr)
+        self.assertIn(os.path.splitext(__file__)[0], bRepr)
+        self.assertIn("RuntimeError: repr!", bRepr)
+
+
+    def test_brokenClassNameAttribute(self):
+        """
+        If a class raises an exception when accessing its C{__name__} attribute
+        B{and} when calling its C{__str__} implementation, L{reflect.safe_repr}
+        returns 'BROKEN CLASS' instead of the class name.
+        """
+        class X(BTBase):
+            breakName = True
+        xRepr = reflect.safe_repr(X())
+        self.assertIn("<BROKEN CLASS AT 0x", xRepr)
+        self.assertIn(os.path.splitext(__file__)[0], xRepr)
+        self.assertIn("RuntimeError: repr!", xRepr)
+
+
+
+class SafeStr(unittest.SynchronousTestCase):
+    """
+    Tests for L{reflect.safe_str} function.
+    """
+
+    def test_workingStr(self):
+        x = [1, 2, 3]
+        self.assertEqual(reflect.safe_str(x), str(x))
+
+
+    def test_brokenStr(self):
+        b = Breakable()
+        b.breakStr = True
+        reflect.safe_str(b)
+
+
+    def test_brokenRepr(self):
+        b = Breakable()
+        b.breakRepr = True
+        reflect.safe_str(b)
+
+
+    def test_brokenClassStr(self):
+        class X(BTBase):
+            breakStr = True
+        reflect.safe_str(X)
+        reflect.safe_str(X())
+
+
+    def test_brokenClassRepr(self):
+        class X(BTBase):
+            breakRepr = True
+        reflect.safe_str(X)
+        reflect.safe_str(X())
+
+
+    def test_brokenClassAttribute(self):
+        """
+        If an object raises an exception when accessing its C{__class__}
+        attribute, L{reflect.safe_str} uses C{type} to retrieve the class
+        object.
+        """
+        b = NoClassAttr()
+        b.breakStr = True
+        bStr = reflect.safe_str(b)
+        self.assertIn("NoClassAttr instance at 0x", bStr)
+        self.assertIn(os.path.splitext(__file__)[0], bStr)
+        self.assertIn("RuntimeError: str!", bStr)
+
+
+    def test_brokenClassNameAttribute(self):
+        """
+        If a class raises an exception when accessing its C{__name__} attribute
+        B{and} when calling its C{__str__} implementation, L{reflect.safe_str}
+        returns 'BROKEN CLASS' instead of the class name.
+        """
+        class X(BTBase):
+            breakName = True
+        xStr = reflect.safe_str(X())
+        self.assertIn("<BROKEN CLASS AT 0x", xStr)
+        self.assertIn(os.path.splitext(__file__)[0], xStr)
+        self.assertIn("RuntimeError: str!", xStr)
+
+
+
+class FilenameToModule(unittest.SynchronousTestCase):
+    """
+    Test L{filenameToModuleName} detection.
     """
 
     def setUp(self):
-        self.tester = PropertyAccessorTester()
+        self.path = os.path.join(self.mktemp(), "fakepackage", "test")
+        os.makedirs(self.path)
+        with open(os.path.join(self.path, "__init__.py"), "w") as f:
+            f.write("")
+        with open(os.path.join(os.path.dirname(self.path), "__init__.py"),
+                  "w") as f:
+            f.write("")
+
+
+    def test_directory(self):
+        """
+        L{filenameToModuleName} returns the correct module (a package) given a
+        directory.
+        """
+        module = reflect.filenameToModuleName(self.path)
+        self.assertEqual(module, 'fakepackage.test')
+        module = reflect.filenameToModuleName(self.path + os.path.sep)
+        self.assertEqual(module, 'fakepackage.test')
+
+
+    def test_file(self):
+        """
+        L{filenameToModuleName} returns the correct module given the path to
+        its file.
+        """
+        module = reflect.filenameToModuleName(
+            os.path.join(self.path, 'test_reflect.py'))
+        self.assertEqual(module, 'fakepackage.test.test_reflect')
+
+
+    def test_bytes(self):
+        """
+        L{filenameToModuleName} returns the correct module given a C{bytes}
+        path to its file.
+        """
+        module = reflect.filenameToModuleName(
+            os.path.join(self.path.encode("utf-8"), b'test_reflect.py'))
+        # Module names are always native string:
+        self.assertEqual(module, 'fakepackage.test.test_reflect')
+
+
+
+class FullyQualifiedNameTests(unittest.SynchronousTestCase):
+    """
+    Test for L{fullyQualifiedName}.
+    """
+
+    def _checkFullyQualifiedName(self, obj, expected):
+        """
+        Helper to check that fully qualified name of C{obj} results to
+        C{expected}.
+        """
+        self.assertEqual(fullyQualifiedName(obj), expected)
 
 
-    def test_setWithDefaultValue(self):
+    def test_package(self):
         """
-        If an attribute is present in the class, it can be retrieved by
-        default.
+        L{fullyQualifiedName} returns the full name of a package and a
+        subpackage.
         """
-        self.assertEqual(self.tester.r, 0)
-        self.tester.r = 1
-        self.assertEqual(self.tester.r, 0)
-        self.assertEqual(self.tester.s, 1)
+        import twisted
+        self._checkFullyQualifiedName(twisted, 'twisted')
+        import twisted.python
+        self._checkFullyQualifiedName(twisted.python, 'twisted.python')
 
 
-    def test_getValueInDict(self):
+    def test_module(self):
         """
-        The attribute value can be overriden by directly modifying the value in
-        C{__dict__}.
+        L{fullyQualifiedName} returns the name of a module inside a a package.
         """
-        self.tester.__dict__["r"] = 10
-        self.assertEqual(self.tester.r, 10)
+        import twisted.python.compat
+        self._checkFullyQualifiedName(
+            twisted.python.compat, 'twisted.python.compat')
 
 
-    def test_notYetInDict(self):
+    def test_class(self):
         """
-        If a getter is defined on an attribute but without any default value,
-        it raises C{AttributeError} when trying to access it.
+        L{fullyQualifiedName} returns the name of a class and its module.
         """
-        self.assertRaises(AttributeError, getattr, self.tester, "x")
+        self._checkFullyQualifiedName(
+            FullyQualifiedNameTests,
+            '%s.FullyQualifiedNameTests' % (__name__,))
 
 
+    def test_function(self):
+        """
+        L{fullyQualifiedName} returns the name of a function inside its module.
+        """
+        self._checkFullyQualifiedName(
+            fullyQualifiedName, "twisted.python.reflect.fullyQualifiedName")
+
+
+    def test_boundMethod(self):
+        """
+        L{fullyQualifiedName} returns the name of a bound method inside its
+        class and its module.
+        """
+        self._checkFullyQualifiedName(
+            self.test_boundMethod,
+            "%s.%s.test_boundMethod" % (__name__, self.__class__.__name__))
+
+
+    def test_unboundMethod(self):
+        """
+        L{fullyQualifiedName} returns the name of an unbound method inside its
+        class and its module.
+        """
+        self._checkFullyQualifiedName(
+            self.__class__.test_unboundMethod,
+            "%s.%s.test_unboundMethod" % (__name__, self.__class__.__name__))
+
 
 class ImportHooksLookupTests(unittest.TestCase, LookupsTestCase):
     """
@@ -243,9 +768,9 @@ class ObjectGrep(unittest.TestCase):
         o = Dummy()
         m = o.dummy
 
-        self.assertIn(".im_self", reflect.objgrep(m, m.im_self, reflect.isSame))
-        self.assertIn(".im_class", reflect.objgrep(m, m.im_class, reflect.isSame))
-        self.assertIn(".im_func", reflect.objgrep(m, m.im_func, reflect.isSame))
+        self.assertIn(".__self__", reflect.objgrep(m, m.__self__, reflect.isSame))
+        self.assertIn(".__self__.__class__", reflect.objgrep(m, m.__self__.__class__, reflect.isSame))
+        self.assertIn(".__func__", reflect.objgrep(m, m.__func__, reflect.isSame))
 
     def test_everything(self):
         """
@@ -265,7 +790,7 @@ class ObjectGrep(unittest.TestCase):
         m = i.method
         w = weakref.ref(m)
 
-        self.assertIn("().im_self.attr[2][0][2]{'Foosh'}", reflect.objgrep(w, o, reflect.isSame))
+        self.assertIn("().__self__.attr[2][0][2]{'Foosh'}", reflect.objgrep(w, o, reflect.isSame))
 
     def test_depthLimit(self):
         """
@@ -294,11 +819,16 @@ class ObjectGrep(unittest.TestCase):
 
 
 class GetClass(unittest.TestCase):
+    if _PY3:
+        oldClassNames = ['type']
+    else:
+        oldClassNames = ['class', 'classobj']
+
     def testOld(self):
         class OldClass:
             pass
         old = OldClass()
-        self.assertIn(reflect.getClass(OldClass).__name__, ('class', 'classobj'))
+        self.assertIn(reflect.getClass(OldClass).__name__, self.oldClassNames)
         self.assertEqual(reflect.getClass(old).__name__, 'OldClass')
 
     def testNew(self):
@@ -307,119 +837,3 @@ class GetClass(unittest.TestCase):
         new = NewClass()
         self.assertEqual(reflect.getClass(NewClass).__name__, 'type')
         self.assertEqual(reflect.getClass(new).__name__, 'NewClass')
-
-
-
-class DeprecationTestCase(unittest.TestCase):
-    """
-    Test deprecations in twisted.python.reflect
-    """
-
-    def test_allYourBase(self):
-        """
-        Test deprecation of L{reflect.allYourBase}. See #5481 for removal.
-        """
-        self.callDeprecated(
-            (Version("Twisted", 11, 0, 0), "inspect.getmro"),
-            reflect.allYourBase, DeprecationTestCase)
-
-
-    def test_accumulateBases(self):
-        """
-        Test deprecation of L{reflect.accumulateBases}. See #5481 for removal.
-        """
-        l = []
-        self.callDeprecated(
-            (Version("Twisted", 11, 0, 0), "inspect.getmro"),
-            reflect.accumulateBases, DeprecationTestCase, l, None)
-
-
-    def lookForDeprecationWarning(self, testMethod, attributeName, warningMsg):
-        """
-        Test deprecation of attribute 'reflect.attributeName' by calling
-        'reflect.testMethod' and verifying the warning message
-        'reflect.warningMsg'
-
-        @param testMethod: Name of the offending function to be used with
-            flushWarnings
-        @type testmethod: C{str}
-
-        @param attributeName: Name of attribute to be checked for deprecation
-        @type attributeName: C{str}
-
-        @param warningMsg: Deprecation warning message
-        @type warningMsg: C{str}
-        """
-        warningsShown = self.flushWarnings([testMethod])
-        self.assertEqual(len(warningsShown), 1)
-        self.assertIdentical(warningsShown[0]['category'], DeprecationWarning)
-        self.assertEqual(
-            warningsShown[0]['message'],
-            "twisted.python.reflect." + attributeName + " "
-            "was deprecated in Twisted 12.1.0: " + warningMsg + ".")
-
-
-    def test_settable(self):
-        """
-        Test deprecation of L{reflect.Settable}.
-        """
-        reflect.Settable()
-        self.lookForDeprecationWarning(
-            self.test_settable, "Settable",
-            "Settable is old and untested. Please write your own version of this "
-            "functionality if you need it")
-
-
-    def test_accessorType(self):
-        """
-        Test deprecation of L{reflect.AccessorType}.
-        """
-        reflect.AccessorType(' ', ( ), { })
-        self.lookForDeprecationWarning(
-            self.test_accessorType, "AccessorType",
-            "AccessorType is old and untested. Please write your own version of "
-            "this functionality if you need it")
-
-
-    def test_propertyAccessor(self):
-        """
-        Test deprecation of L{reflect.PropertyAccessor}.
-        """
-        reflect.PropertyAccessor()
-        self.lookForDeprecationWarning(
-            self.test_propertyAccessor, "PropertyAccessor",
-            "PropertyAccessor is old and untested. Please write your own "
-            "version of this functionality if you need it")
-
-
-    def test_accessor(self):
-        """
-        Test deprecation of L{reflect.Accessor}.
-        """
-        reflect.Accessor()
-        self.lookForDeprecationWarning(
-            self.test_accessor, "Accessor",
-            "Accessor is an implementation for Python 2.1 which is no longer "
-            "supported by Twisted")
-
-
-    def test_originalAccessor(self):
-        """
-        Test deprecation of L{reflect.OriginalAccessor}.
-        """
-        reflect.OriginalAccessor()
-        self.lookForDeprecationWarning(
-            self.test_originalAccessor, "OriginalAccessor",
-            "OriginalAccessor is a reference to class "
-            "twisted.python.reflect.Accessor which is deprecated")
-
-
-    def test_summer(self):
-        """
-        Test deprecation of L{reflect.Summer}.
-        """
-        reflect.Summer()
-        self.lookForDeprecationWarning(
-            self.test_summer, "Summer",
-            "Summer is a child class of twisted.python.reflect.Accessor which "
-            "is deprecated")
diff --git twisted/trial/reporter.py twisted/trial/reporter.py
index e6d8365..f6aa22b 100644
--- twisted/trial/reporter.py
+++ twisted/trial/reporter.py
@@ -18,7 +18,7 @@ import unittest as pyunit
 
 from zope.interface import implementer
 
-from twisted.python import _reflectpy3 as reflect, log
+from twisted.python import reflect, log
 from twisted.python.components import proxyForInterface
 from twisted.python.failure import Failure
 from twisted.python.util import untilConcludes
diff --git twisted/trial/test/test_assertions.py twisted/trial/test/test_assertions.py
index 5243afc..356e89a 100644
--- twisted/trial/test/test_assertions.py
+++ twisted/trial/test/test_assertions.py
@@ -19,7 +19,7 @@ from pprint import pformat
 import unittest as pyunit
 
 from twisted.python.util import FancyEqMixin
-from twisted.python._reflectpy3 import prefixedMethods, accumulateMethods
+from twisted.python.reflect import prefixedMethods, accumulateMethods
 from twisted.python.deprecate import deprecated
 from twisted.python.versions import Version, getVersionString
 from twisted.python.failure import Failure
diff --git twisted/web/resource.py twisted/web/resource.py
index 4242305..7553e7a 100644
--- twisted/web/resource.py
+++ twisted/web/resource.py
@@ -18,7 +18,7 @@ import warnings
 from zope.interface import Attribute, Interface, implementer
 
 from twisted.python.compat import nativeString, unicode
-from twisted.python._reflectpy3 import prefixedMethodNames
+from twisted.python.reflect import prefixedMethodNames
 from twisted.python.components import proxyForInterface
 
 from twisted.web._responses import FORBIDDEN, NOT_FOUND
diff --git twisted/web/server.py twisted/web/server.py
index a48f2ea..ed42cdc 100644
--- twisted/web/server.py
+++ twisted/web/server.py
@@ -34,7 +34,7 @@ else:
 from twisted.internet import address
 from twisted.web import iweb, http, html
 from twisted.web.http import unquote
-from twisted.python import log, _reflectpy3 as reflect, failure, components
+from twisted.python import log, reflect, failure, components
 from twisted import copyright
 # Re-enable as part of #6178 when twisted.web.util is ported to Python 3:
 if not _PY3:
