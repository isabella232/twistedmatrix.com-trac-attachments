diff -urN python-gnutls-1.2.4/examples/certs/valid-pgp.key python-gnutls-1.2.4-gpg/examples/certs/valid-pgp.key
--- python-gnutls-1.2.4/examples/certs/valid-pgp.key	1970-01-01 01:00:00.000000000 +0100
+++ python-gnutls-1.2.4-gpg/examples/certs/valid-pgp.key	2013-04-18 16:11:30.667954650 +0200
@@ -0,0 +1,41 @@
+-----BEGIN PGP PRIVATE KEY BLOCK-----
+Version: GnuPG v1.4.12 (GNU/Linux)
+
+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
+ij1Ajzr7fMULTjncA0avv0MEYWIYwH9S6w==
+=3TPT
+-----END PGP PRIVATE KEY BLOCK-----
diff -urN python-gnutls-1.2.4/examples/certs/valid-pgp.pub python-gnutls-1.2.4-gpg/examples/certs/valid-pgp.pub
--- python-gnutls-1.2.4/examples/certs/valid-pgp.pub	1970-01-01 01:00:00.000000000 +0100
+++ python-gnutls-1.2.4-gpg/examples/certs/valid-pgp.pub	2013-04-18 16:11:30.667954650 +0200
@@ -0,0 +1,39 @@
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+Version: GnuPG v1.4.12 (GNU/Linux)
+
+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
+=Jbqz
+-----END PGP PUBLIC KEY BLOCK-----
diff -urN python-gnutls-1.2.4/examples/client-pgp.py python-gnutls-1.2.4-gpg/examples/client-pgp.py
--- python-gnutls-1.2.4/examples/client-pgp.py	1970-01-01 01:00:00.000000000 +0100
+++ python-gnutls-1.2.4-gpg/examples/client-pgp.py	2013-04-18 16:11:30.667954650 +0200
@@ -0,0 +1,29 @@
+#!/usr/bin/env python
+
+"""Synchronous client using python-gnutls"""
+
+import sys
+import os
+import socket
+
+from gnutls.crypto import *
+from gnutls.connection import *
+
+script_path = os.path.realpath(os.path.dirname(sys.argv[0]))
+certs_path = os.path.join(script_path, 'certs')
+
+cert = OpenPGPCertificate(open(certs_path + '/valid-pgp.pub').read())
+key = OpenPGPPrivateKey(open(certs_path + '/valid-pgp.key').read())
+cred = OpenPGPCredentials(cert, key)
+
+sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+session = ClientSession(sock, cred)
+
+session.connect(('localhost', 10000))
+session.handshake()
+session.send("test\r\n")
+buf = session.recv(1024)
+print 'Received: ', buf.rstrip()
+session.bye()
+session.close()
+
diff -urN python-gnutls-1.2.4/examples/crypto-pgp.py python-gnutls-1.2.4-gpg/examples/crypto-pgp.py
--- python-gnutls-1.2.4/examples/crypto-pgp.py	1970-01-01 01:00:00.000000000 +0100
+++ python-gnutls-1.2.4-gpg/examples/crypto-pgp.py	2013-04-18 16:11:30.667954650 +0200
@@ -0,0 +1,19 @@
+#!/usr/bin/env python
+
+"""Cryptographic examples using python-gnutls"""
+
+import sys, os
+
+from gnutls.crypto import *
+from gnutls.constants import OPENPGP_FMT_RAW, OPENPGP_FMT_BASE64
+
+script_path = os.path.realpath(os.path.dirname(sys.argv[0]))
+certs_path = os.path.join(script_path, 'certs')
+
+pkey = OpenPGPPrivateKey(open(certs_path + '/valid-pgp.key').read(), OPENPGP_FMT_BASE64)
+print pkey
+
+crt = OpenPGPCertificate(open(certs_path + '/valid-pgp.pub').read(), OPENPGP_FMT_BASE64)
+print crt
+uid = crt.uid()
+print '\nU:'.join((uid, uid.name, uid.comment, uid.email))
diff -urN python-gnutls-1.2.4/gnutls/connection.py python-gnutls-1.2.4-gpg/gnutls/connection.py
--- python-gnutls-1.2.4/gnutls/connection.py	2008-04-10 21:42:46.000000000 +0200
+++ python-gnutls-1.2.4-gpg/gnutls/connection.py	2013-04-18 16:11:30.663954651 +0200
@@ -3,7 +3,7 @@
 
 """GNUTLS connection support"""
 
-__all__ = ['X509Credentials', 'ClientSession', 'ServerSession', 'ServerSessionFactory']
+__all__ = ['X509Credentials', 'OpenPGPCredentials', 'ClientSession', 'ServerSession', 'ServerSessionFactory']
 
 from time import time
 from socket import SHUT_RDWR as SOCKET_SHUT_RDWR
@@ -16,7 +16,7 @@
 from gnutls.crypto import *
 from gnutls.errors import *
 
-from gnutls.library.constants import GNUTLS_SERVER, GNUTLS_CLIENT, GNUTLS_CRT_X509
+from gnutls.library.constants import GNUTLS_SERVER, GNUTLS_CLIENT, GNUTLS_CRT_X509, GNUTLS_CRT_OPENPGP
 from gnutls.library.constants import GNUTLS_CERT_INVALID, GNUTLS_CERT_REVOKED, GNUTLS_CERT_INSECURE_ALGORITHM
 from gnutls.library.constants import GNUTLS_CERT_SIGNER_NOT_FOUND, GNUTLS_CERT_SIGNER_NOT_CA
 from gnutls.library.constants import GNUTLS_AL_FATAL, GNUTLS_A_BAD_CERTIFICATE
@@ -29,7 +29,7 @@
 
 
 @gnutls_certificate_server_retrieve_function
-def _retrieve_server_certificate(c_session, retr_st):
+def _retrieve_x509_server_certificate(c_session, retr_st):
     session = PyObj_FromPtr(gnutls_session_get_ptr(c_session))
     identity = session.credentials.select_server_identity(session)
     retr_st.contents.type = GNUTLS_CRT_X509
@@ -42,8 +42,22 @@
         retr_st.contents.key.x509 = identity.key._c_object
     return 0
 
+@gnutls_certificate_server_retrieve_function
+def _retrieve_openpgp_server_certificate(c_session, retr_st):
+    session = PyObj_FromPtr(gnutls_session_get_ptr(c_session))
+    identity = session.credentials.select_server_identity(session)
+    retr_st.contents.type = GNUTLS_CRT_OPENPGP
+    retr_st.contents.deinit_all = 0
+    if identity is None:
+        retr_st.contents.ncerts = 0
+    else:
+        retr_st.contents.ncerts = 1
+        retr_st.contents.cert.openpgp.contents = identity.cert._c_object
+        retr_st.contents.key.openpgp = identity.key._c_object
+    return 0
 
-class _ServerNameIdentities(dict):
+
+class _ServerNameX509Identities(dict):
     """Used internally by X509Credentials to map server names to X509 identities for the server name extension"""
     def __init__(self, identities):
         dict.__init__(self)
@@ -67,8 +81,32 @@
                 return self[name]
         return default
 
+class _ServerNameOpenPGPIdentities(dict):
+    """Used internally by OpenPGPCredentials to map server names to OpenPGP identities for the server name extension"""
+    def __init__(self, identities):
+        dict.__init__(self)
+        for identity in identities:
+            self.add(identity)
+    def add(self, identity):
+        for name in identity.cert.uid().name:
+            self[name.lower()] = identity
+    def get(self, server_name, default=None):
+        server_name = server_name.lower()
+        if server_name in self:
+            return self[server_name]
+        for name in (n for n in self if n.startswith('*.')):
+            suffix = name[1:]
+            if server_name.endswith(suffix) and '.' not in server_name[:-len(suffix)]:
+                return self[name]
+        return default
+
+
+class TLSCredentials(object):
+    """Implement this to be a credential class."""
+    pass
 
-class X509Credentials(object):
+
+class X509Credentials(TLSCredentials):
     DH_BITS  = 1024
     RSA_BITS = 1024
 
@@ -91,7 +129,7 @@
             gnutls_certificate_set_x509_key(self._c_object, byref(cert._c_object), 1, key._c_object)
         elif (cert, key) != (None, None):
             raise ValueError("Specify neither or both the certificate and private key")
-        gnutls_certificate_server_set_retrieve_function(self._c_object, _retrieve_server_certificate)
+        gnutls_certificate_server_set_retrieve_function(self._c_object, _retrieve_x509_server_certificate)
         self._max_depth = 5
         self._max_bits  = 8200
         self._type = CRED_CERTIFICATE
@@ -101,10 +139,10 @@
         self._trusted = ()
         self.add_trusted(trusted)
         self.crl_list = crl_list
-        self.server_name_identities = _ServerNameIdentities(identities)
+        self.server_name_identities = _ServerNameX509Identities(identities)
         if cert and key:
             self.server_name_identities.add(X509Identity(cert, key))
-        self.session_params = SessionParams(self._type)
+        self.session_params = SessionParams(self._type, 'NORMAL:+CTYPE-X.509')
 
     def __del__(self):
         self.__deinit(self._c_object)
@@ -149,7 +187,7 @@
 
     def _get_crl_list(self):
         return self._crl_list
-    @method_args(list_of(X509CRL)) 
+    @method_args(list_of(X509CRL))
     def _set_crl_list(self, crl_list):
         self._crl_list = tuple(crl_list)
     crl_list = property(_get_crl_list, _set_crl_list)
@@ -157,7 +195,7 @@
 
     def _get_max_verify_length(self):
         return self._max_depth
-    @method_args(int) 
+    @method_args(int)
     def _set_max_verify_length(self, max_depth):
         gnutls_certificate_set_verify_limits(self._c_object, self._max_bits, max_depth)
         self._max_depth = max_depth
@@ -166,7 +204,7 @@
 
     def _get_max_verify_bits(self):
         return self._max_bits
-    @method_args(int) 
+    @method_args(int)
     def _set_max_verify_bits(self, max_bits):
         gnutls_certificate_set_verify_limits(self._c_object, max_bits, self._max_depth)
         self._max_bits = max_bits
@@ -197,6 +235,96 @@
             return None
 
 
+class OpenPGPCredentials(TLSCredentials):
+    DH_BITS  = 1024
+    RSA_BITS = 1024
+
+    dh_params  = None
+    rsa_params = None
+
+    def __new__(cls, *args, **kwargs):
+        c_object = gnutls_certificate_credentials_t()
+        gnutls_certificate_allocate_credentials(byref(c_object))
+        instance = object.__new__(cls)
+        instance.__deinit = gnutls_certificate_free_credentials
+        instance._c_object = c_object
+        return instance
+
+    @method_args((OpenPGPCertificate, none), (OpenPGPPrivateKey, none), list_of(OpenPGPIdentity))
+    def __init__(self, cert=None, key=None, identities=[]):
+        """Credentials contain an OpenPGP certificate and a private key (all optional).
+        An optional list of additional OpenPGP identities can be specified for applications that need more that one identity"""
+        if cert and key:
+            gnutls_certificate_set_openpgp_key(self._c_object, cert._c_object, key._c_object)
+        elif (cert, key) != (None, None):
+            raise ValueError("Specify neither or both the certificate and private key")
+        gnutls_certificate_server_set_retrieve_function(self._c_object, _retrieve_openpgp_server_certificate)
+        self._max_depth = 5
+        self._max_bits  = 8200
+        self._type = CRED_CERTIFICATE
+        self._cert = cert
+        self._key = key
+        self._identities = tuple(identities)
+        self.server_name_identities = _ServerNameOpenPGPIdentities(identities)
+        if cert and key:
+            self.server_name_identities.add(OpenPGPIdentity(cert, key))
+        self.session_params = SessionParams(self._type, 'NORMAL:+CTYPE-OPENPGP')
+
+    def __del__(self):
+        self.__deinit(self._c_object)
+
+    def generate_dh_params(self, bits=DH_BITS):
+        reference = self.dh_params ## keep a reference to preserve it until replaced
+        OpenPGPCredentials.dh_params  = DHParams(bits)
+        del reference
+
+    def generate_rsa_params(self, bits=RSA_BITS):
+        reference = self.rsa_params ## keep a reference to preserve it until replaced
+        OpenPGPCredentials.rsa_params = RSAParams(bits)
+        del reference
+
+    # Properties
+
+    @property
+    def cert(self):
+        return self._cert
+
+    @property
+    def key(self):
+        return self._key
+
+    @property
+    def identities(self):
+        return self._identities
+
+    @property
+    def trusted(self):
+        return self._trusted
+
+    # Methods to select and validate certificates
+
+    def check_certificate(self, cert, cert_name='certificate'):
+        """Verify activation, expiration and revocation for the given certificate"""
+        now = time()
+        if cert.activation_time > now:
+            raise CertificateExpiredError("%s is not yet activated" % cert_name)
+        if cert.expiration_time < now:
+            raise CertificateExpiredError("%s has expired" % cert_name)
+        for crl in self.crl_list:
+            crl.check_revocation(cert, cert_name=cert_name)
+
+    def select_server_identity(self, session):
+        """Select which identity the server will use for a given session. The default selection algorithm uses
+        the server name extension. A subclass can overwrite it if a different selection algorithm is desired."""
+        server_name = session.server_name
+        if server_name is not None:
+            return self.server_name_identities.get(server_name)
+        elif self.cert and self.key:
+            return self ## since we have the cert and key attributes we can behave like a X509Identity
+        else:
+            return None
+
+
 class SessionParams(object):
     _default_kx_algorithms = {
         CRED_CERTIFICATE: (KX_RSA, KX_DHE_DSS, KX_DHE_RSA),
@@ -205,18 +333,22 @@
         CRED_CERTIFICATE: set((KX_RSA, KX_DHE_DSS, KX_DHE_RSA, KX_RSA_EXPORT)),
         CRED_ANON: set((KX_ANON_DH,))}
 
-    def __new__(cls, credentials_type):
+    def __new__(cls, credentials_type, priority=None):
         if credentials_type not in cls._default_kx_algorithms:
             raise TypeError("Unknown credentials type: %r" % credentials_type)
         return object.__new__(cls)
 
-    def __init__(self, credentials_type):
+    def __init__(self, credentials_type, priority=None):
         self._credentials_type = credentials_type
-        self._protocols = (PROTO_TLS1_1, PROTO_TLS1_0, PROTO_SSL3)
-        self._kx_algorithms = self._default_kx_algorithms[credentials_type]
-        self._ciphers = (CIPHER_AES_128_CBC, CIPHER_3DES_CBC, CIPHER_ARCFOUR_128)
-        self._mac_algorithms = (MAC_SHA1, MAC_MD5, MAC_RMD160)
-        self._compressions = (COMP_NULL,)
+        self._direct = priority
+        # manual parameters
+        if not priority:
+            self._protocols = (PROTO_TLS1_2, PROTO_TLS1_1, PROTO_TLS1_0, PROTO_SSL3)
+            self._kx_algorithms = self._default_kx_algorithms[credentials_type]
+            self._ciphers = (CIPHER_AES_128_CBC, CIPHER_3DES_CBC, CIPHER_ARCFOUR_128)
+            self._mac_algorithms = (MAC_SHA1, MAC_MD5, MAC_RMD160)
+            self._compressions = (COMP_NULL,)
+            self._certificate_types = (GNUTLS_CRT_X509, GNUTLS_CRT_OPENPGP)
 
     def _get_protocols(self):
         return self._protocols
@@ -258,6 +390,13 @@
     compressions = property(_get_compressions, _set_compressions)
     del _get_compressions, _set_compressions
 
+    def _get_certificate_types(self):
+        return self._certificate_types
+    def _set_certificate_types(self, certificate_types):
+        self._certificate_types = OneOfValidator([GNUTLS_CRT_X509, GNUTLS_CRT_OPENPGP])
+    certificate_types = property(_get_certificate_types, _set_certificate_types)
+    del _get_certificate_types, _set_certificate_types
+
 
 class Session(object):
     """Abstract class representing a TLS session created from a TCP socket
@@ -295,7 +434,7 @@
 
     def _get_credentials(self):
         return self._credentials
-    @method_args(X509Credentials)
+    @method_args(TLSCredentials)
     def _set_credentials(self, credentials):
         ## Release all credentials, otherwise gnutls will only release an existing credential of
         ## the same type as the one being set and we can end up with multiple credentials in C.
@@ -327,14 +466,17 @@
 
     @property
     def peer_certificate(self):
-        if gnutls_certificate_type_get(self._c_object) != GNUTLS_CRT_X509:
+        if not gnutls_certificate_type_get(self._c_object) in (GNUTLS_CRT_X509, GNUTLS_CRT_OPENPGP):
             return None
         list_size = c_uint()
         cert_list = gnutls_certificate_get_peers(self._c_object, byref(list_size))
         if list_size.value == 0:
             return None
         cert = cert_list[0]
-        return X509Certificate(string_at(cert.data, cert.size), X509_FMT_DER)
+        if isinstance(self.credentials, X509Credentials):
+            return X509Certificate(string_at(cert.data, cert.size), X509_FMT_DER)
+        elif isinstance(self.credentials, OpenPGPCredentials):
+            return OpenPGPCertificate(string_at(cert.data, cert.size), OPENPGP_FMT_RAW)
 
     # Status checking after an operation was interrupted (these properties are
     # only useful to check after an operation was interrupted, otherwise their
@@ -358,13 +500,17 @@
             size = len(priorities) + 1
             return (c_int * size)(*priorities)
         session_params = self.credentials.session_params
-        # protocol order in the priority list is irrelevant (it always uses newer protocols first)
-        # the protocol list only specifies what protocols are to be enabled.
-        gnutls_protocol_set_priority(self._c_object, c_priority_list(session_params.protocols))
-        gnutls_kx_set_priority(self._c_object, c_priority_list(session_params.kx_algorithms))
-        gnutls_cipher_set_priority(self._c_object, c_priority_list(session_params.ciphers))
-        gnutls_mac_set_priority(self._c_object, c_priority_list(session_params.mac_algorithms))
-        gnutls_compression_set_priority(self._c_object, c_priority_list(session_params.compressions))
+        if session_params._direct:
+            gnutls_priority_set_direct(self._c_object, session_params._direct, None)
+        else:
+            # protocol order in the priority list is irrelevant (it always uses newer protocols first)
+            # the protocol list only specifies what protocols are to be enabled.
+            gnutls_protocol_set_priority(self._c_object, c_priority_list(session_params.protocols))
+            gnutls_kx_set_priority(self._c_object, c_priority_list(session_params.kx_algorithms))
+            gnutls_cipher_set_priority(self._c_object, c_priority_list(session_params.ciphers))
+            gnutls_mac_set_priority(self._c_object, c_priority_list(session_params.mac_algorithms))
+            gnutls_compression_set_priority(self._c_object, c_priority_list(session_params.compressions))
+            gnutls_certificate_type_set_priority(self._c_object, c_priority_list(session_params.certificate_types))
 
     def handshake(self):
         gnutls_handshake(self._c_object)
diff -urN python-gnutls-1.2.4/gnutls/constants.py python-gnutls-1.2.4-gpg/gnutls/constants.py
--- python-gnutls-1.2.4/gnutls/constants.py	2011-05-20 14:45:09.000000000 +0200
+++ python-gnutls-1.2.4-gpg/gnutls/constants.py	2013-04-18 16:11:30.663954651 +0200
@@ -6,16 +6,16 @@
 __all__ = [
     ## GNUTLS session protocols
     'PROTO_TLS1_2', 'PROTO_TLS1_1', 'PROTO_TLS1_0', 'PROTO_SSL3',
-    
+
     ## Key exchange algorithms
     'KX_RSA', 'KX_DHE_DSS', 'KX_DHE_RSA', 'KX_RSA_EXPORT', 'KX_ANON_DH',
-    
+
     ## Ciphers
     'CIPHER_AES_128_CBC', 'CIPHER_3DES_CBC', 'CIPHER_ARCFOUR_128', 'CIPHER_AES_256_CBC', 'CIPHER_DES_CBC', 'CIPHER_CAMELLIA_256_CBC', 'CIPHER_CAMELLIA_128_CBC',
-    
+
     ## MAC algorithms
     'MAC_SHA512', 'MAC_SHA384', 'MAC_SHA256', 'MAC_SHA1', 'MAC_MD5', 'MAC_RMD160',
-    
+
     ## Compressions
     'COMP_DEFLATE', 'COMP_LZO', 'COMP_NULL',
 
@@ -25,6 +25,9 @@
     ## X509 certificate/private key formats
     'X509_FMT_DER', 'X509_FMT_PEM',
 
+    ## OpenPGP certificate/private key formats
+    'OPENPGP_FMT_RAW', 'OPENPGP_FMT_BASE64',
+
     ## Miscellaneous
     'CERT_REQUEST', 'CERT_REQUIRE', 'SHUT_RDWR', 'SHUT_WR'
 ]
diff -urN python-gnutls-1.2.4/gnutls/crypto.py python-gnutls-1.2.4-gpg/gnutls/crypto.py
--- python-gnutls-1.2.4/gnutls/crypto.py	2011-05-20 15:13:12.000000000 +0200
+++ python-gnutls-1.2.4-gpg/gnutls/crypto.py	2013-04-18 16:11:30.663954651 +0200
@@ -3,13 +3,15 @@
 
 """GNUTLS crypto support"""
 
-__all__ = ['X509Name', 'X509Certificate', 'X509PrivateKey', 'X509Identity', 'X509CRL', 'DHParams', 'RSAParams']
+__all__ = ['X509Name', 'X509Certificate', 'X509PrivateKey', 'X509Identity', 'X509CRL',
+           'OpenPGPUid', 'OpenPGPCertificate', 'OpenPGPPrivateKey', 'OpenPGPIdentity',
+           'DHParams', 'RSAParams']
 
 import re
 from ctypes import *
 
 from gnutls.validators import method_args, one_of
-from gnutls.constants import X509_FMT_DER, X509_FMT_PEM
+from gnutls.constants import X509_FMT_DER, X509_FMT_PEM, OPENPGP_FMT_RAW, OPENPGP_FMT_BASE64
 from gnutls.errors import *
 
 from gnutls.library.constants import GNUTLS_SAN_DNSNAME, GNUTLS_SAN_RFC822NAME, GNUTLS_SAN_URI
@@ -230,14 +232,14 @@
 
 class X509Identity(object):
     """A X509 identity represents a X509 certificate and private key pair"""
-    
+
     __slots__ = ('cert', 'key')
-    
+
     @method_args(X509Certificate, X509PrivateKey)
     def __init__(self, cert, key):
         self.cert = cert
         self.key = key
-    
+
     def __setattr__(self, name, value):
         if name in self.__slots__ and hasattr(self, name):
             raise AttributeError("can't set attribute")
@@ -306,6 +308,145 @@
         return pemdata.value
 
 
+class OpenPGPUidMeta(type):
+    _names = ['name', 'email', 'comment']
+    def __new__(cls, name, bases, dic):
+        instance = type.__new__(cls, name, bases, dic)
+        instance.ids = OpenPGPUidMeta._names
+        return instance
+
+
+class OpenPGPUid(str):
+    __metaclass__ = OpenPGPUidMeta
+
+    def __init__(self, dname):
+        str.__init__(self)
+        m = re.split(r'^(.*) \((.*)\) <(.*)>$', dname)
+        try:
+            unused1, name, comment, email, unused2 = m
+            str.__setattr__(self, 'name', name)
+            str.__setattr__(self, 'comment', comment)
+            str.__setattr__(self, 'email', email)
+        except:
+            import traceback
+            traceback.print_exc()
+            raise ValueError("Invalid OpenPGP uid: %s" % dname)
+
+        for name in OpenPGPUid.ids:
+            if not hasattr(self, name):
+                str.__setattr__(self, name, None)
+
+    def __setattr__(self, name, value):
+        if name in OpenPGPUid.ids:
+            raise AttributeError("can't set attribute")
+        str.__setattr__(self, name, value)
+
+
+class OpenPGPCertificate(object):
+
+    def __new__(cls, *args, **kwargs):
+        instance = object.__new__(cls)
+        instance.__deinit = gnutls_openpgp_crt_deinit
+        instance._c_object = gnutls_openpgp_crt_t()
+        instance._alternative_names = None
+        return instance
+
+    @method_args(str, one_of(OPENPGP_FMT_RAW, OPENPGP_FMT_BASE64))
+    def __init__(self, buf, format=OPENPGP_FMT_BASE64):
+        gnutls_openpgp_crt_init(byref(self._c_object))
+        data = gnutls_datum_t(cast(c_char_p(buf), POINTER(c_ubyte)), c_uint(len(buf)))
+        gnutls_openpgp_crt_import(self._c_object, byref(data), format)
+
+    def __del__(self):
+        self.__deinit(self._c_object)
+
+    @method_args(int)
+    def uid(self, idx=0):
+        size = c_size_t(256)
+        dname = create_string_buffer(size.value)
+        try:
+            gnutls_openpgp_crt_get_name(self._c_object, idx, dname, byref(size))
+        except MemoryError:
+            dname = create_string_buffer(size.value)
+            gnutls_openpgp_crt_get_name(self._c_object, idx, dname, byref(size))
+        return OpenPGPUid(dname.value)
+
+    @property
+    def creation_time(self):
+        return gnutls_openpgp_crt_get_creation_time(self._c_object)
+
+    @property
+    def expiration_time(self):
+        return gnutls_openpgp_crt_get_expiration_time(self._c_object)
+
+    @property
+    def fingerprint(self):
+        # TODO gnutls_openpgp_crt_get_fingerprint(self._c_object)
+        return None
+
+    @property
+    def version(self):
+        return gnutls_openpgp_crt_get_version(self._c_object)
+
+    @method_args(one_of(OPENPGP_FMT_RAW, OPENPGP_FMT_BASE64))
+    def export(self, format=OPENPGP_FMT_BASE64):
+        size = c_size_t(4096)
+        pemdata = create_string_buffer(size.value)
+        try:
+            gnutls_openpgp_crt_export(self._c_object, format, cast(pemdata, c_void_p), byref(size))
+        except MemoryError:
+            pemdata = create_string_buffer(size.value)
+            gnutls_openpgp_crt_export(self._c_object, format, cast(pemdata, c_void_p), byref(size))
+        return pemdata.value
+
+
+class OpenPGPPrivateKey(object):
+    def __new__(cls, *args, **kwargs):
+        instance = object.__new__(cls)
+        instance.__deinit = gnutls_openpgp_privkey_deinit
+        instance._c_object = gnutls_openpgp_privkey_t()
+        return instance
+
+    @method_args(str, one_of(OPENPGP_FMT_RAW, OPENPGP_FMT_BASE64))
+    def __init__(self, buf, format=OPENPGP_FMT_BASE64):
+        gnutls_openpgp_privkey_init(byref(self._c_object))
+        data = gnutls_datum_t(cast(c_char_p(buf), POINTER(c_ubyte)), c_uint(len(buf)))
+        gnutls_openpgp_privkey_import(self._c_object, byref(data), format, None, c_uint(0))
+
+    def __del__(self):
+        self.__deinit(self._c_object)
+
+    @method_args(one_of(OPENPGP_FMT_RAW, OPENPGP_FMT_BASE64))
+    def export(self, format=OPENPGP_FMT_BASE64):
+        size = c_size_t(4096)
+        pemdata = create_string_buffer(size.value)
+        try:
+            gnutls_openpgp_privkey_export(self._c_object, format, None, 0, cast(pemdata, c_void_p), byref(size))
+        except MemoryError:
+            pemdata = create_string_buffer(size.value)
+            gnutls_openpgp_privkey_export(self._c_object, format, None, 0, cast(pemdata, c_void_p), byref(size))
+        return pemdata.value
+
+class OpenPGPIdentity(object):
+    """An OpenPGP identity represents a OpenPGP certificate and private key pair"""
+
+    __slots__ = ('cert', 'key')
+
+    @method_args(OpenPGPCertificate, OpenPGPPrivateKey)
+    def __init__(self, cert, key):
+        self.cert = cert
+        self.key = key
+
+    def __setattr__(self, name, value):
+        if name in self.__slots__ and hasattr(self, name):
+            raise AttributeError("can't set attribute")
+        object.__setattr__(self, name, value)
+
+    def __delattr__(self, name):
+        if name in self.__slots__:
+            raise AttributeError("can't delete attribute")
+        object.__delattr__(self, name)
+
 
 class DHParams(object):
     def __new__(cls, *args, **kwargs):
diff -urN python-gnutls-1.2.4/gnutls/interfaces/twisted/__init__.py python-gnutls-1.2.4-gpg/gnutls/interfaces/twisted/__init__.py
--- python-gnutls-1.2.4/gnutls/interfaces/twisted/__init__.py	2012-01-30 16:37:31.000000000 +0100
+++ python-gnutls-1.2.4-gpg/gnutls/interfaces/twisted/__init__.py	2013-04-18 16:11:30.663954651 +0200
@@ -14,6 +14,7 @@
 
 from gnutls.connection import ClientSession, ServerSession, ServerSessionFactory
 from gnutls.connection import X509Credentials as _X509Credentials
+from gnutls.connection import OpenPGPCredentials as _OpenPGPCredentials
 from gnutls.constants import SHUT_RDWR, SHUT_WR
 from gnutls.errors import *
 
@@ -67,6 +68,17 @@
             raise preverify_status
         self.check_certificate(peer_cert, cert_name='peer certificate')
 
+class OpenPGPCredentials(_OpenPGPCredentials):
+    """A Twisted enhanced OpenPGPCredentials"""
+    verify_peer = False
+    verify_period = None
+
+    def verify_callback(self, peer_cert, preverify_status=None):
+        """Verifies the peer certificate and raises an exception if it cannot be accepted"""
+        if isinstance(preverify_status, Exception):
+            raise preverify_status
+        self.check_certificate(peer_cert, cert_name='peer certificate')
+
 
 class TLSMixin:
     """TLS specific functionality common to both clients and servers"""
@@ -137,9 +149,9 @@
 
 class TLSClient(TLSMixin, tcp.Client):
     """Add TLS capabilities to a TCP client"""
-    
+
     implementsOnly(interfaces.ISSLTransport, *[i for i in implementedBy(tcp.Client) if i != interfaces.ITLSTransport])
-    
+
     def __init__(self, host, port, bindAddress, credentials, connector, reactor=None, server_name=None):
         self.credentials = credentials
         self.server_name = server_name
@@ -172,9 +184,9 @@
             preverify_status = e
         else:
             preverify_status = CertificateOK
-        
+
         credentials.verify_callback(session.peer_certificate, preverify_status)
-        
+
         if credentials.verify_period > 0:
             self.__watchdog = RecurrentCall(credentials.verify_period, self._recurrentVerify)
 
@@ -190,11 +202,11 @@
             del self.doRead
             self.failIfNotConnected(err = e)
             return
-        
+
         ## reset any references to the old doRead
         del self.doRead
         self.stopReading()
-        
+
         try:
             self._verifyPeer()
         except GNUTLSError, e:
@@ -205,10 +217,10 @@
             self.closeTLSSession(e)
             self.failIfNotConnected(err = error.getConnectError(str(e)))
             return
-        
+
         ## TLS handshake (including certificate verification) finished succesfully
         tcp.Client._connectDone(self)
-        
+
     def startTLS(self):
         self.doRead = self.doHandshake
         self.startReading()
@@ -244,9 +256,9 @@
 
 class TLSServer(TLSMixin, tcp.Server):
     """Add TLS capabilities to a TCP server"""
-    
+
     implementsOnly(interfaces.ISSLTransport, *[i for i in implementedBy(tcp.Server) if i != interfaces.ITLSTransport])
-    
+
     def __init__(self, sock, protocol, client, server, sessionno, *args, **kw):
         self.__watchdog = None
         self.credentials = server.credentials
@@ -277,9 +289,9 @@
             preverify_status = e
         else:
             preverify_status = CertificateOK
-        
+
         credentials.verify_callback(session.peer_certificate, preverify_status)
-        
+
         if credentials.verify_period > 0:
             self.__watchdog = RecurrentCall(credentials.verify_period, self._recurrentVerify)
 
@@ -294,20 +306,20 @@
         except GNUTLSError, e:
             del self.doRead
             return e
-        
+
         ## reset any references to the old doRead
         del self.doRead
         self.stopReading()
         self.startReading()
-        
+
         try:
             self._verifyPeer()
         except Exception, e:
             self.loseConnection(e)
             return
-        
+
         ## TLS handshake (including certificate verification) finished succesfully
-        
+
         del self.protocol.makeConnection
         self.protocol.makeConnection(self)
 
