<?xml version="1.0" encoding="latin-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=latin-1" />
<meta name="generator" content="Docutils 0.2.10: http://docutils.sourceforge.net/" />
<title>Patterns for Twisted</title>
<meta name="author" content="Dave Kuhlman" />
<meta name="date" content="Sept. 22, 2003" />
<meta name="copyright" content="Copyright (c) 2003 Dave Kuhlman. This documentation is under The Artistic License: http://www.opensource.org/licenses/artistic-license." />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="patterns-for-twisted">
<h1 class="title">Patterns for Twisted</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Dave Kuhlman</td></tr>
<tr><th class="docinfo-name">Address:</th>
<td><pre class="address">
<a class="first reference" href="mailto:dkuhlman&#64;rexx.com">dkuhlman&#64;rexx.com</a>
<a class="last reference" href="http://www.rexx.com/~dkuhlman">http://www.rexx.com/~dkuhlman</a>
</pre>
</td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td>1.0c</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>Sept. 22, 2003</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Copyright (c) 2003 Dave Kuhlman. This documentation is
under The Artistic License:
<a class="reference" href="http://www.opensource.org/licenses/artistic-license">http://www.opensource.org/licenses/artistic-license</a>.</td></tr>
</tbody>
</table>
<div class="abstract topic">
<p class="topic-title">Abstract</p>
<p>This document describes and discusses several design
patterns for the development of Twisted Web applications.</p>
</div>
<div class="contents topic" id="contents">
<p class="topic-title"><a name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id7" name="id7">1   Introduction</a></li>
<li><a class="reference" href="#application-goals" id="id8" name="id8">2   Application Goals</a></li>
<li><a class="reference" href="#the-design-patterns" id="id9" name="id9">3   The Design Patterns</a></li>
<li><a class="reference" href="#the-dispatcher-pattern" id="id10" name="id10">4   The Dispatcher Pattern</a><ul class="auto-toc">
<li><a class="reference" href="#example" id="id11" name="id11">4.1   Example</a><ul class="auto-toc">
<li><a class="reference" href="#the-brute-force-pattern" id="id12" name="id12">4.1.1   The brute-force pattern</a></li>
<li><a class="reference" href="#the-name-prefix-pattern" id="id13" name="id13">4.1.2   The name-prefix pattern</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#the-database-update-pattern" id="id14" name="id14">5   The Database Update Pattern</a><ul class="auto-toc">
<li><a class="reference" href="#strategy" id="id15" name="id15">5.1   Strategy</a></li>
<li><a class="reference" href="#id1" id="id16" name="id16">5.2   Example</a><ul class="auto-toc">
<li><a class="reference" href="#the-application-logic-class" id="id17" name="id17">5.2.1   The application logic class</a></li>
<li><a class="reference" href="#repository-class" id="id18" name="id18">5.2.2   Repository class</a></li>
<li><a class="reference" href="#connection-pooling" id="id19" name="id19">5.2.3   Connection pooling</a></li>
</ul>
</li>
<li><a class="reference" href="#questions-and-discussion" id="id20" name="id20">5.3   Questions and discussion</a></li>
</ul>
</li>
<li><a class="reference" href="#the-text-repository-pattern" id="id21" name="id21">6   The Text Repository Pattern</a><ul class="auto-toc">
<li><a class="reference" href="#id2" id="id22" name="id22">6.1   Example</a><ul class="auto-toc">
<li><a class="reference" href="#application-logic-class" id="id23" name="id23">6.1.1   Application logic class</a></li>
<li><a class="reference" href="#id3" id="id24" name="id24">6.1.2   Repository class</a></li>
<li><a class="reference" href="#the-glimpse-library" id="id25" name="id25">6.1.3   The Glimpse library</a></li>
<li><a class="reference" href="#representation-formatting-class" id="id26" name="id26">6.1.4   Representation formatting class</a></li>
</ul>
</li>
<li><a class="reference" href="#id4" id="id27" name="id27">6.2   Questions and discussion</a></li>
</ul>
</li>
<li><a class="reference" href="#the-xml-rpc-pattern" id="id28" name="id28">7   The XML-RPC Pattern</a><ul class="auto-toc">
<li><a class="reference" href="#id5" id="id29" name="id29">7.1   Example</a><ul class="auto-toc">
<li><a class="reference" href="#id6" id="id30" name="id30">7.1.1   The application logic class</a></li>
<li><a class="reference" href="#the-xml-rpc-requester-class" id="id31" name="id31">7.1.2   The XML-RPC requester class</a></li>
<li><a class="reference" href="#the-xml-rpc-server" id="id32" name="id32">7.1.3   The XML-RPC server</a></li>
<li><a class="reference" href="#an-xml-rpc-server-implemented-with-twisted" id="id33" name="id33">7.1.4   An XML-RPC server implemented with Twisted</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#miscellaneous-hints-and-howto-s" id="id34" name="id34">8   Miscellaneous Hints and Howto's</a><ul class="auto-toc">
<li><a class="reference" href="#body-data-content" id="id35" name="id35">8.1   Body data/content</a></li>
<li><a class="reference" href="#debugging" id="id36" name="id36">8.2   Debugging</a></li>
<li><a class="reference" href="#a-test-harness" id="id37" name="id37">8.3   A test harness</a></li>
</ul>
</li>
<li><a class="reference" href="#summary-and-conclusions" id="id38" name="id38">9   Summary and Conclusions</a></li>
<li><a class="reference" href="#acknowledgements" id="id39" name="id39">10   Acknowledgements</a></li>
<li><a class="reference" href="#see-also" id="id40" name="id40">11   See Also</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id7" name="introduction">1   Introduction</a></h1>
<p>This document contains notes and examples that describe several
programming patterns for Twisted, including patterns for deferred
operations, for database access, for a client of a text search
engine, and for an XML-RPC client.</p>
<p>I've called these &quot;design patterns&quot;, although they are also
&quot;implementation patterns&quot; in an attempt to suggest that they are a
bit more abstract. My intent is to encourage you to use these
patterns both in the design of your Twisted Web application as
well as in implementing it (possibly by copying and editing the
examples providing).</p>
<p>These patterns may seem to have a <a class="reference" href="http://internet.conveyor.com/RESTwiki/moin.cgi/RestFaq">REST (REpresentational State
Transfer)</a> cast, and that is intentional.  My aims are to help
those attempting to treat the Web as a resource, in contrast to
dealing with the Web as an extended computer using some style of
RPC (e.g. XML-RPC or SOAP).  However, I'm also hoping that the
patterns described in this document are generic enough so that
they will be helpful in other styles of Web application as well.</p>
<p>I've read the Twisted documentation on deferreds as closely as I
could, but I do not feel that I am experienced enough to have
good intuitions here, so any suggestions and corrections would be
appreciated.</p>
</div>
<div class="section" id="application-goals">
<h1><a class="toc-backref" href="#id8" name="application-goals">2   Application Goals</a></h1>
<p>Here are some goals for applications developed with the use of
these patterns:</p>
<ul class="simple">
<li>REST-ful applications.</li>
<li>Business logic through finite state machines (FSM).</li>
<li>Support for the development of clients.</li>
<li>Support for down-loadable clients and for clients that can be
updated automatically from the server, e.g. by down-loading and
installing scripts.</li>
<li>Delivery on top of Twisted.</li>
<li>Tailored support for several specific application architectures,
for example:<ul>
<li>Database search, listings, and update (add, modify, delete).</li>
<li>Text repository search, display, update.  Use of a search
engine, e.g. Glimpse.</li>
<li>Use of XML-RPC as a client to access back-end resources
exposed by an XML-RPC server.</li>
<li>Multi-step, interactive, processes with complex logic
implemented on top of a finite state machine (FSM).</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="the-design-patterns">
<h1><a class="toc-backref" href="#id9" name="the-design-patterns">3   The Design Patterns</a></h1>
<p>These are the patterns that we describe in this document.  We hope
to also provide some support for implementing with these patterns.</p>
<p>We are interested in the following development patterns, which are
described in more detail below:</p>
<ul class="simple">
<li>The dispatcher pattern</li>
<li>The database update pattern</li>
<li>The FSM multi-step pattern</li>
<li>The text repository search and update pattern</li>
<li>The XML-RPC pattern</li>
</ul>
</div>
<div class="section" id="the-dispatcher-pattern">
<h1><a class="toc-backref" href="#id10" name="the-dispatcher-pattern">4   The Dispatcher Pattern</a></h1>
<p>This pattern takes the URL and translates it into a call to the
Python method intended to implement the request.  It does this by
inspecting the path on the URL.</p>
<div class="section" id="example">
<h2><a class="toc-backref" href="#id11" name="example">4.1   Example</a></h2>
<div class="section" id="the-brute-force-pattern">
<h3><a class="toc-backref" href="#id12" name="the-brute-force-pattern">4.1.1   The brute-force pattern</a></h3>
<p>Here is an example of a class that dispatches requests:</p>
<pre class="literal-block">
class ResourceDispatcher(resource.Resource):

    isLeaf = True

    def render(self, request):
        done = False
        if len(request.postpath) == 1 and request.postpath[0]:
            if request.postpath[0] == 'show_plants':
                dbaccess = dbmod.DBAccess(registry)
                dbaccess.show_plants(request)
                done = True
            elif request.postpath[0] == 'show_plants_by_rating':
                dbaccess = dbmod.DBAccess(registry)
                dbaccess.show_plants_by_rating(request)
                done = True
            elif request.postpath[0] == 'get_add_form':
                dbaccess = dbmod.DBAccess(registry)
                dbaccess.show_add_form(request)
                done = True
            elif request.postpath[0] == 'get_delete_form':
                dbaccess = dbmod.DBAccess(registry)
                dbaccess.show_delete_form(request)
                done = True
            elif request.postpath[0] == 'add_plant':
                dbaccess = dbmod.DBAccess(registry)
                dbaccess.add_plant(request)
                done = True
            elif request.postpath[0] == 'delete_plant':
                dbaccess = dbmod.DBAccess(registry)
                dbaccess.delete_plant(request)
                done = True
        if done:
            return NOT_DONE_YET
        else:
            content = Content_Dispatch % (
                request.postpath,
                request.args,
                time.ctime(),
                )
            request.write(content)
            request.finish()
</pre>
<p>Comments and explanation:</p>
<ul class="simple">
<li>Setting the class variable <tt class="literal"><span class="pre">isLeaf</span></tt> to <tt class="literal"><span class="pre">True</span></tt> tells Twisted
not to perform further processing on the URL path.</li>
<li>The list <tt class="literal"><span class="pre">request.postpath</span></tt> contains un-digested parts of
the URL path.</li>
</ul>
</div>
<div class="section" id="the-name-prefix-pattern">
<h3><a class="toc-backref" href="#id13" name="the-name-prefix-pattern">4.1.2   The name-prefix pattern</a></h3>
<p>For some purposes, this pattern is a bit simpler, although it may
not give you as much control over individual cases:</p>
<pre class="literal-block">
class ResourceDispatcher(resource.Resource):
    isLeaf = True
    def render(self, request):
        if len(request.postpath) == 1 and request.postpath[0]:
            name = request.postpath[0]
            dbaccess = dbmod.DBAccess(registry)
            try:
                method = getattr(dbaccess, 'webrequest_' + name)
            except AttributeError:
                pass
            else:
                method(request)
                return NOT_DONE_YET
        content = Content_Dispatch % (
            request.postpath,
            request.args,
            time.ctime(),
            )
        request.write(content)
        request.finish()
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>This dispatcher retrieves an attribute (the method) from a class
given a request name on the right end of the URL.</li>
<li>If your implementation is spread across several modules and/or
classes, then you might still have to do a bit of if-else stuff.
Or, you might consider using a dictionary that maps names to
modules and classes.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-database-update-pattern">
<h1><a class="toc-backref" href="#id14" name="the-database-update-pattern">5   The Database Update Pattern</a></h1>
<p>This pattern uses Twisted deferred objects to request database
operations.  Here is a description:</p>
<ul class="simple">
<li>A database class with one method for each database operation.
Note that if the &quot;slow&quot; resource is something else (XML-RPC, for
example), then this would be a class for that resource.  I'm
guessing that various slow resources are different enough so
that no single interface (API, set of public methods) could be
defined, but that would be nice.</li>
<li>A resource class with one operation for each request or resource
type.  A dispatcher (a Twisted .rpy page) parses the request URL
and dispatches/calls the appropriate method in this class.  This
class would also contain application logic.</li>
<li>For each step in the sequence, a (private) method in the
resource class that performs that step by calling the
appropriate method in the database class and (for all but the
last step) by providing as the callback function, the method
that implements the next step in the process.</li>
<li>My example code uses an PostgreSQL database, but other databases
that have Python support could also be used.</li>
</ul>
<div class="section" id="strategy">
<h2><a class="toc-backref" href="#id15" name="strategy">5.1   Strategy</a></h2>
<ul class="simple">
<li>Separate the deferring operations (for example, requests to the
PostgreSQL database) from the code that calls them and that also
contains application logic.</li>
<li>Execute operations in sequence.  Operation n+1 must not begin
operation n until is complete.  Implement this by chaining
callbacks.</li>
<li>Provide simple Web page and form definitions.  Enable editing
and delivery of simple HTML documents.</li>
</ul>
<!-- Data fill-in via Quixote template language or other template
and string interpolation language. -->
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id16" name="id1">5.2   Example</a></h2>
<div class="section" id="the-application-logic-class">
<h3><a class="toc-backref" href="#id17" name="the-application-logic-class">5.2.1   The application logic class</a></h3>
<p>And, here is the resource class that requests the slow operations
and provides a callback to be called when the slow operation is
complete.  This class also provides application logic. For each
operation that requires multiple sequential operations, it
provides multiple methods that each calls a database operation and
provides a callback (except, of course, for the last step):</p>
<pre class="literal-block">
class DBAccess:
    def __init__(self, registry):
        self.registry = registry
        get_globals(registry)

    o
    o
    o

    #
    # Delete a row.
    #
    def delete_plant(self, request):
        self.request = request
        self.db = PlantDatabase(&quot;pyPgSQL.PgSQL&quot;, CONNECTION_ARGS)
        self.content = Content_ShowPlants
        self.plant_name = request.args.get('plant_name')
        if self.plant_name and len(self.plant_name) &gt; 0:
            self.plant_name = self.plant_name[0]
        self.plant_desc = request.args.get('plant_desc')
        if self.plant_desc and len(self.plant_desc) &gt; 0:
            self.plant_desc = self.plant_desc[0]
        self.plant_rating = request.args.get('plant_rating')
        if self.plant_rating and len(self.plant_rating) &gt; 0:
            self.plant_rating = self.plant_rating[0]
        self.delete_plant_step_1()
        return NOT_DONE_YET

    def delete_plant_step_1(self):
        self.db.checkPlant(self.plant_name).addCallbacks(
            self.delete_plant_step_2,
            self.db.operationError)

    def delete_plant_step_2(self, resultlist):
        if resultlist:
            deferred = self.db.deletePlant(
                self.plant_name)
            deferred.addCallbacks(self.delete_plant_step_3,
                self.db.operationError)
        else:
            self.content = Content_Missing
            self.content = self.content % self.plant_name
            self.request.write(self.content)
            self.request.finish()
            

    def delete_plant_step_3(self, resultlist):
        self.db.getPlants().addCallbacks(self.gotPlants,
            self.db.operationError)

    #
    # Show the plants in the database.
    #
    def gotPlants(self, resultlist):
        plantlist = []
        plantlist.append('&lt;table border=&quot;5&quot; width=&quot;80%&quot;&gt;')
        plantlist.append('&lt;caption&gt;Plant DB&lt;/caption&gt;')
        plantlist.append('&lt;tr&gt;&lt;th width=&quot;25%&quot;&gt;Name&lt;/th&gt;&lt;th width=&quot;65%&quot;&gt;Description&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;Rating&lt;/th&gt;&lt;/tr&gt;')
        for plant in resultlist:
            plantlist.append('&lt;tr&gt;')
            s1 = '&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td align=&quot;right&quot;&gt;%s&lt;/td&gt;' % \
                (plant[0], plant[1], plant[2])
            plantlist.append(s1)
            plantlist.append('&lt;/tr&gt;')
        plantlist.append('&lt;/table&gt;')
        plantstr = '\n'.join(plantlist)
        content = self.content % (self.request.args, plantstr)
        self.request.write(content)
        self.request.finish()
</pre>
<p>The following second pattern uses a single method implemented as a
state machine, rather than using separate methods for each step
(as in the previous example).  Whereas the previous example,
deleted a plant, this example adds a plant if it is not already in
the database, or updates the plant if it is in the database:</p>
<pre class="literal-block">
STEP_1 = 1
STEP_2 = 2
STEP_3 = 3

class DBAccess:

    o
    o
    o

    #
    # Add or update a row.
    # This uses a state machine pattern.
    #
    def add_plant(self, request):
        self.request = request
        self.state = STEP_1
        self.add_plant_machine()

    def add_plant_machine(self, *args):
        if self.state == STEP_1:
            self.db = PlantDatabase(&quot;pyPgSQL.PgSQL&quot;, CONNECTION_ARGS)
            self.content = Content_ShowPlants
            self.plant_name = self.request.args.get('plant_name')
            if self.plant_name and len(self.plant_name) &gt; 0:
                self.plant_name = self.plant_name[0]
            self.plant_desc = self.request.args.get('plant_desc')
            if self.plant_desc and len(self.plant_desc) &gt; 0:
                self.plant_desc = self.plant_desc[0]
            self.plant_rating = self.request.args.get('plant_rating')
            if self.plant_rating and len(self.plant_rating) &gt; 0:
                self.plant_rating = self.plant_rating[0]
            self.state = STEP_2
            self.db.checkPlant(self.plant_name).addCallbacks(
                self.add_plant_machine,
                self.db.operationError)
            return NOT_DONE_YET
        elif self.state == STEP_2:
            resultlist = args[0]
            # Is the plant already in the database?
            if resultlist:
                self.state = STEP_3
                deferred = self.db.updatePlant(
                    self.plant_name, self.plant_desc, self.plant_rating)
                deferred.addCallbacks(self.add_plant_machine,
                    self.db.operationError)
            else:
                self.state = STEP_3
                deferred = self.db.addPlant(
                    self.plant_name, self.plant_desc, self.plant_rating)
                deferred.addCallbacks(self.add_plant_machine,
                    self.db.operationError)
            return NOT_DONE_YET
        elif self.state == STEP_3:
            self.db.getPlants().addCallbacks(self.gotPlants,
                self.db.operationError)
            return NOT_DONE_YET
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>This state machine is sequential: it executes step 1, 2, and 3
in order.</li>
<li>Each state is implemented by a clause in the if-elif statement.</li>
<li>Each state sets the variable <tt class="literal"><span class="pre">self.state</span></tt> to indicate the next
state to be executed.</li>
<li>Each state sets this method itself as the next callback.</li>
</ul>
<p>Comparison and analysis:</p>
<ul class="simple">
<li>The difference between the above two patterns is that the first
uses separate methods for each step whereas the second pattern
uses a single method with separate states (each implemented by a
clause in an if-elif statement.</li>
<li>Once you learn to recognize each pattern and its structure,
either is understandable and usable. The choice between them may
be a personal preference.</li>
<li>A good recommendation is to pick one of the above two patterns
and to use it consistently.  What you want is code that is
recognizable and clear, and that you can understand and debug.</li>
</ul>
<p>And, here is yet one more pattern for the same task.  This one
attempts to simplify things by replacing the <tt class="literal"><span class="pre">if-elif-...</span></tt>
statement.  It implements each state as a separate method, and
provides a dispatcher to these methods:</p>
<pre class="literal-block">
class DBAccess:

    o
    o
    o

    #
    # Add or update a row.
    # This method uses a state machine pattern.
    # It also has a dispatcher that retrieves and calls the
    #   method that implements the current state.
    #
    def add_plant(self, request):
        self.request = request
        self.state = 'step_1'
        self.add_plant_machine()

    #
    # This method is the dispatcher.
    #
    def add_plant_machine(self, *args):
        method = getattr(self, 'add_plant_machine_' + self.state)
        method(*args)
    
    def add_plant_machine_step_1(self, *args):
        self.db = PlantDatabase(&quot;pyPgSQL.PgSQL&quot;, CONNECTION_ARGS)
        self.content = Content_ShowPlants
        self.plant_name = self.request.args.get('plant_name')
        if self.plant_name and len(self.plant_name) &gt; 0:
            self.plant_name = self.plant_name[0]
        self.plant_desc = self.request.args.get('plant_desc')
        if self.plant_desc and len(self.plant_desc) &gt; 0:
            self.plant_desc = self.plant_desc[0]
        self.plant_rating = self.request.args.get('plant_rating')
        if self.plant_rating and len(self.plant_rating) &gt; 0:
            self.plant_rating = self.plant_rating[0]
        self.state = 'step_2'
        self.db.checkPlant(self.plant_name).addCallbacks(
            self.add_plant_machine,
            self.db.operationError)
        return NOT_DONE_YET

    def add_plant_machine_step_2(self, *args):
        resultlist = args[0]
        if resultlist:
            self.state = 'step_3'
            deferred = self.db.updatePlant(
                self.plant_name, self.plant_desc, self.plant_rating)
            deferred.addCallbacks(self.add_plant_machine,
                self.db.operationError)
        else:
            self.state = 'step_3'
            deferred = self.db.addPlant(
                self.plant_name, self.plant_desc, self.plant_rating)
            deferred.addCallbacks(self.add_plant_machine,
                self.db.operationError)
        return NOT_DONE_YET

    def add_plant_machine_step_3(self, *args):
        self.db.getPlants().addCallbacks(self.gotPlants,
            self.db.operationError)
        return NOT_DONE_YET
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Note the method <tt class="literal"><span class="pre">add_plant_machine</span></tt>.  It acts as a dispatcher
for our state machine.  It takes the current state (a string:
&quot;step_1&quot;, &quot;step_2, &quot;step_3&quot;), concatenates it to
&quot;add_plant_machine_&quot;, then retrieves and calls the method by
that name.</li>
<li>Each method that implements a state (except the last), sets
<tt class="literal"><span class="pre">self.state</span></tt> to the next state, and adds <tt class="literal"><span class="pre">add_plant_machine</span></tt>
as a callback.</li>
</ul>
</div>
<div class="section" id="repository-class">
<h3><a class="toc-backref" href="#id18" name="repository-class">5.2.2   Repository class</a></h3>
<p>Here is an example of the <em>repository access</em> class or database
class -- Each method implements a single operation that may cause
a delay, then returns a deferred:</p>
<pre class="literal-block">
class PlantDatabase(adbapi.ConnectionPool): 
    &quot;&quot;&quot;Update and retrieve from the Plant_DB database.
    &quot;&quot;&quot; 

    def checkPlant(self, name):
        deferred = self.runQuery(&quot;select * from Plant_DB where p_name = '%s'&quot; % name)
        return deferred

    def updatePlant(self, plant_name, plant_desc, plant_rating):
        sql = &quot;update Plant_DB set p_desc='%s', p_rating='%s' where p_name='%s'&quot; % \
            (plant_desc, plant_rating, plant_name)
        deferred = self.runOperation(sql)
        return deferred

    def addPlant(self, plant_name, plant_desc, plant_rating):
        sql = &quot;insert into Plant_DB values ('%s', '%s', '%s')&quot; % \
            (plant_name, plant_desc, plant_rating)
        deferred = self.runOperation(sql)
        return deferred

    def deletePlant(self, plant_name):
        sql = &quot;delete from Plant_DB where p_name='%s'&quot; % \
            (plant_name,)
        deferred = self.runOperation(sql)
        return deferred

    def getPlants(self): 
        sql = &quot;SELECT * FROM Plant_DB order by p_name&quot;
        deferred = self.runQuery(sql) 
        return deferred

    def operationError(self, error):
        log.msg(&quot;%s Operation Failed: %s&quot; % (reflect.qual(self.__class__), error))
        log.err(error)
</pre>
<p>Comments and explanation:</p>
<ul class="simple">
<li>There is one function in this class for each type of request. In
our example these are check for existence, update, add, delete,
and get all.</li>
<li>Each of these operations is a &quot;slow&quot; operation.  To prevent
blocking, it requests the operation and immediately returns a
deferred.  (Note: We will learn how to implement a slow
operation without blocking the in the text repository pattern.</li>
<li>By inheriting from <tt class="literal"><span class="pre">twisted.enterprise.adbapi.ConnectionPool</span></tt>,
we get get the ability to run database queries that use the
connection pool.  In order to do so, we pass to the constructor
for class <tt class="literal"><span class="pre">PlantDatabase</span></tt> the name of the database API and the
connection args. See the application logic class.</li>
</ul>
</div>
<div class="section" id="connection-pooling">
<h3><a class="toc-backref" href="#id19" name="connection-pooling">5.2.3   Connection pooling</a></h3>
<p><strong>Note:</strong> It is no longer necessary to explicitly do connection
pooling.  Class <tt class="literal"><span class="pre">PlantDatabase</span></tt> above inherits from
<tt class="literal"><span class="pre">adbapi.ConnectionPool</span></tt> directly.  However, I have retained the
example in this section because it serves as a pattern of how to
share values across sessions.</p>
<p>This section provides an example of how to share values across
sessions.  It is no longer necessary, however, to explicitly code
this important efficiency feature of Twisted in this example, i.e.
the ability to use a connection pool.  Either way,
<tt class="literal"><span class="pre">ConnectionPool</span></tt> saves the time needed to create a database
connection for each session.</p>
<p>Here is code that shares a single instance of the database
connection pool across all sessions:</p>
<pre class="literal-block">
class Globals:
    def __init__(self):
        self.dbpool = None
    def getDbpool(self):
        return self.dbpool
    def setDbpool(self, dbpool):
        self.dbpool = dbpool

def get_globals(registry):
    globalContainer = registry.getComponent(Globals)
    if not globalContainer:
        globalContainer = Globals()
        dbpool = adbapi.ConnectionPool(&quot;pyPgSQL.PgSQL&quot;,
            &quot;localhost:5432:test:postgres:**password**&quot;)
        globalContainer.setDbpool(dbpool)
        registry.setComponent(Globals, globalContainer)
    else:
        dbpool = globalContainer.getDbpool()
    return dbpool
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Class <tt class="literal"><span class="pre">Globals</span></tt> is our container for global values.  In this
example, the only value stored in it is the database connection
pool.</li>
<li>The function <tt class="literal"><span class="pre">get_globals</span></tt> attempts to get the existing,
shared globals container.  If the globals container exists, it
returns the DB connection pool from that container.  If it does
not exist, it creates a container and a DB connection pool, puts
the DB connection pool in the container, saves it, and returns
the new DB connection pool.</li>
<li>In order to use the database connection pool, we create an
instance of a class that subclasses
<tt class="literal"><span class="pre">twisted.enterprise.adbapi.Augmentation</span></tt> (in our example code
this class is <tt class="literal"><span class="pre">PlantDatabase</span></tt>) passing to the constructor the
instance of the database connection pool. The query functions
provided by that superclass know how to use the database
connection pool. See the &quot;Repository class&quot; example.</li>
</ul>
</div>
</div>
<div class="section" id="questions-and-discussion">
<h2><a class="toc-backref" href="#id20" name="questions-and-discussion">5.3   Questions and discussion</a></h2>
<p>Here are a few questions:</p>
<ul class="simple">
<li>We've presented two patterns for using deferreds, specifically
(1) chaining separate methods and (2) a state machine in a
single method.  Which is better?  Is there an approved or
commonly accepted Twisted pattern for using deferreds?  Putting
multiple steps in a single method seems to avoid some code
clutter at the expense of code density.</li>
<li>I've separated the slow operations into a separate class.  Is
that a good idea?  In my example, the operations are very
simple, in part because I've kept the logic in the resource
class. Perhaps, instead of putting them in a separate class, I
should just code them in-line in the resource class in the state
machine method.  One reason for separate methods is to make them
reusable.</li>
<li>The state-machine-pattern returns multiple times.  It returns
NOT_DONE_YET each time.  Is that the correct thing to do?</li>
<li>Twisted already has an API that creates and returns deferreds
for database operations.  What if I need to wrap some other long
lasting operation up in the same way?  How do I do
that?  Answer:  See <a class="reference" href="#the-text-repository-pattern">The Text Repository Pattern</a>.</li>
</ul>
</div>
</div>
<div class="section" id="the-text-repository-pattern">
<h1><a class="toc-backref" href="#id21" name="the-text-repository-pattern">6   The Text Repository Pattern</a></h1>
<p>Assumptions:</p>
<ul class="simple">
<li>There is a text search engine, e.g. Glimpse.  If the repository
is composed of XML documents, then sgrep/pysgrep or XPath might
be appropriate.</li>
<li>The documents form some kind of accessible collection.  For
example, they are all in a single disk directory or set of
sub-directories.</li>
</ul>
<p>Requirements:</p>
<ul class="simple">
<li>Searches may be slow, so we consider doing the following:<ul>
<li>In C code, release the Python global interpreter lock.</li>
<li>Wrap the slow operations with a Twisted deferred.</li>
</ul>
</li>
<li>Define a common API that can be wrapped around and can be
implemented for a variety search engines.</li>
<li>Provide patterns and code samples that that use the API.</li>
<li>Provide access to the (underlying) search engine from Python.
For example:<ul>
<li>Provide a Python extension for a search engine, e.g. Glimpse 
or Harvest (which uses Glimpse).</li>
<li>Provide a server-client connection to a search engine, e.g.
Glimpse or Harvest.</li>
</ul>
</li>
</ul>
<p>Definitions:</p>
<ul class="simple">
<li>In REST terms, the <em>resource</em> is the text repository. For
example, a resource might be:<ul>
<li>The search capability</li>
<li>The ability to retrieve the file in which a search string has
been found.</li>
</ul>
</li>
<li>Again, in REST terms, the <em>representation</em> is the content which
the Web application formats and sends to the client.  The
representation could be HTML, XML, PDF, etc.  For example, a
representation might be:<ul>
<li>A list of search results along with URI's for accessing each
result</li>
<li>A file that contains the string or target of the previous
search</li>
</ul>
</li>
</ul>
<p>Here is a description of the pattern:</p>
<ul class="simple">
<li>The search and update operations are collected in a separate
class.  Call it the <em>repository access</em> class.  This class
exposes the following methods:<ul>
<li><em>search(&lt;search_string&gt;)</em> -- Return a list of repository
locations that satisfy <em>&lt;search string&gt;</em>.</li>
<li><em>fetch_one(&lt;location&gt;)</em> -- Return the text chunk from the
repository pointed to by <em>&lt;location&gt;</em>.</li>
<li><em>replace_one(&lt;location&gt;, &lt;replacement_text&gt;)</em> -- Replace the
chunk at <em>&lt;location&gt;</em> with <em>&lt;replacement_text&gt;</em>.</li>
</ul>
</li>
<li>Application logic is in a separate class. Call it the
<em>application logic</em> class. This <em>application logic</em> class is a
client of and uses the <em>repository access</em> class.</li>
<li>Filtering of search results can be done in separate wrappers
that are called by the search engine.  The logic class can also
do some filtering, of course, but for some purposes it might be
preferable to remove unwanted earlier.</li>
<li>Formatting of the representation of the resource can be done in
the <em>application logic</em> class, or can be separated from
application logic by placing templates and formatting code in a
separate <em>representation formatting</em> class or even a separate
module.</li>
</ul>
<p>The implementation -- Here is a conceptual view of the
implementation pattern:</p>
<ul class="simple">
<li>The implementation is composed of the following layers:<ul>
<li>The dispatcher -- <tt class="literal"><span class="pre">dispatch.rpy/ResourceDispatcher</span></tt></li>
<li>The access class -- Class <tt class="literal"><span class="pre">GlimpseTextRepositoryAccess</span></tt></li>
<li>The repository class -- Class <tt class="literal"><span class="pre">glimpsetextmod.GlimpseTextRepository</span></tt></li>
<li>The service class -- Class <tt class="literal"><span class="pre">glimpsemod.GlimpseService</span></tt></li>
<li>The Glimpse library -- Class <tt class="literal"><span class="pre">glimpselib.Query</span></tt></li>
<li>The representation formatting class -- <tt class="literal"><span class="pre">glimpsetextmod.Formatter</span></tt></li>
</ul>
</li>
<li>The dispatcher -- Translates the URI path into a call to a
method in the access class.</li>
<li>The access class -- Contains application logic.</li>
<li>The repository class -- Calls the service class to create and
return a Twisted deferred.</li>
<li>The service class -- (1) Creates a Twisted deferred; (2) uses it
schedule the callbacks that request the &quot;slow&quot; operations; (3)
returns the deferred instance.</li>
<li>The Glimpse library -- Contains functions that make requests
Glimpse.</li>
<li>The representation formatting class -- Formats the results of
queries for delivery to the client.</li>
</ul>
<p>You may want to compare the structure of the text repository
pattern with that of the database update pattern.  I'm trying to
re-work these patterns so that they are as isomorphic
(structurally similar) as possible.  Hopefully, that will make
knowledge and understanding of one pattern transferable to the
other.</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id22" name="id2">6.1   Example</a></h2>
<div class="section" id="application-logic-class">
<h3><a class="toc-backref" href="#id23" name="application-logic-class">6.1.1   Application logic class</a></h3>
<p>Here is an example of the <em>application logic</em> class:</p>
<pre class="literal-block">
#
# Application logic class
#
class GlimpseTextRepositoryAccess:

    #
    # Produce a form to be used to search the text repository.
    #
    def show_search_form(self, request):
        self.request = request
        self.content = Content_SearchForm
        self.request.write(self.content)
        self.request.finish()

    #
    # Produce a list of the search results.
    #
    def show_search_results(self, request):
        self.request = request
        self.repository = GlimpseTextRepository()
        self.content = Content_ShowSearchResults
        self.querystr = request.args.get('querystr')
        if self.querystr and len(self.querystr) &gt; 0:
            self.querystr = self.querystr[0]
        self.casesensitive = request.args.get('casesensitive')
        if self.casesensitive and len(self.casesensitive) &gt; 0:
            self.casesensitive = self.casesensitive[0]
        self.state = STEP_1
        self.show_search_results_machine()
        return NOT_DONE_YET

    def show_search_results_machine(self, *args, **kw):
        if self.state == STEP_1:
            #dbglogmsg('*** (show_search_results Step_1)')
            self.repository.search_repository(
                self.show_search_results_machine,
                self.querystr,
                self.casesensitive)
            self.state = STEP_2
        elif self.state == STEP_2:
            resultlist = args[0]
            formatter = Formatter()
            content = formatter.format_search_results(self.content, resultlist)
            self.request.write(content)
            self.request.finish()

    #
    # Fetch and show one file from the repository.
    #
    def get_text_file(self, request, path):
        self.request = request
        infile = file(path, 'r')
        filecontent = infile.read()
        infile.close()
        formatter = Formatter()
        content = formatter.format_file(filecontent, path)
        self.request.write(content)
        self.request.finish()
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Method <tt class="literal"><span class="pre">show_search_form</span></tt> provides a form that can be used to
request a query.</li>
<li>Method <tt class="literal"><span class="pre">show_search_results_machine</span></tt> implements a small FSM
(finite state machine).  This FSM contains two steps (states)
which (1) get the deferred that starts the query and (2) format
the results for delivery to the client.  The variable
<tt class="literal"><span class="pre">self.state</span></tt> is used to keep track of state and to transfer
from one state to another.</li>
<li>In step (state) 1, method <tt class="literal"><span class="pre">show_search_results_machine</span></tt> (1)
calls the <tt class="literal"><span class="pre">search_repository</span></tt> method in the <em>repository</em>
class, (2) adds itself as a callback, and (3) sets the (next)
state to <tt class="literal"><span class="pre">STEP_2</span></tt> so that when the callback is called, step 2
will be executed.</li>
<li>In step (state) 2, which is executed when the method is called
as a <em>callback</em>, method <tt class="literal"><span class="pre">show_search_results_machine</span></tt> formats
the results and delivers them to the client.</li>
<li>Method <tt class="literal"><span class="pre">get_text_file</span></tt> responds to a request for one of the
files listed in the search results.  The right-end of the URL
contains the path to the requested file.  Note that the list of
search results contains the URLs needed to make these requests.
In effect, this enables the user to &quot;drill down&quot; into one of the
results (a file) returned by the text search engine.</li>
</ul>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id24" name="id3">6.1.2   Repository class</a></h3>
<p>Here is an example of the <em>repository access</em> class:</p>
<pre class="literal-block">
#
# Repository class
#
class GlimpseTextRepository:

    def search_repository(self, callback, querystr, casesensitive): 
        flags = ''
        if not casesensitive:
            flags = '-i'
        port = 2001
        queryobj = glimpselib.Query()
        deferred = queryobj.query_server(querystr, flags, port)
        deferred.addCallback(callback)
        return deferred
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Method <tt class="literal"><span class="pre">search_repository</span></tt> calls the method in the Glimpse to
initiate the search and create a deferred object.  It then adds
a callback to the deferred.</li>
<li>This class is intended a &quot;insulation&quot; from the Glimpse library
that actually does the work.  It would, hopefully, enable user
to easily switch to another implementation of text searching.</li>
</ul>
</div>
<div class="section" id="the-glimpse-library">
<h3><a class="toc-backref" href="#id25" name="the-glimpse-library">6.1.3   The Glimpse library</a></h3>
<p>This example from the <em>Glimpse library</em> directs its requests to
the Glimpse text search engine:</p>
<pre class="literal-block">
#
# This version uses glimpseserver.
# Doing so saves loading the index into memory for each query.
# It uses twisted.utils.getProcessOutput() to run the query, 
#   captures the results, then creates a list of tuples to return
#   to the callback.
#
class Query:
    def query_server(self, querystr, flags='-i', port=2001):
        executable = '/usr/local/bin/glimpse'
        args = ['-C', '-K', '%d' % port]
        if flags:
            args.append(flags)
        if querystr:
            args.append(querystr)
        self.deferred = utils.getProcessOutput(executable, args)
        self.deferred.addCallbacks(self._query_server_2, self.error_back)
        return self.deferred

    def _query_server_2(self, result):
        lines = result.split('\n')
        result = []
        for line in lines:
            pos = line.find(':')
            if pos &gt; -1:
                val = (line[:pos], line[pos+2:])
                result.append(val)
        return result
    
    def error_back(self, result):
        return [('***error***', result.getErrorMessage()),]
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>The method <tt class="literal"><span class="pre">query_server</span></tt> uses
<tt class="literal"><span class="pre">twisted.utils.getProcessOutput()</span></tt> to run the Glimpse search
engine (as if through the command line) and capture the results.
(Note to self: We really should wrap Glimpse as a Python
extension module.)</li>
<li>The <tt class="literal"><span class="pre">-C</span></tt> flag tells Glimpse to use the Glimpse server to
perform the search.  Doing so saves time that would have been
used to load the search engine's index for each search.</li>
<li><tt class="literal"><span class="pre">getProcessOutput()</span></tt> returns a deferred.  We add
<tt class="literal"><span class="pre">_query_server_2</span></tt> as a callback to that deferred.
<tt class="literal"><span class="pre">getProcessOutput()</span></tt> returns the output of the executable (in
our case <tt class="literal"><span class="pre">glimpse</span></tt>) as a string to the callback.</li>
<li>The callback <tt class="literal"><span class="pre">_query_server_2</span></tt> receives the results of the
query, then creates and returns a list of tuples, one tuple for
each match.  Each tuple has (1) the file name of the match and
(2) the line containing the match.</li>
</ul>
</div>
<div class="section" id="representation-formatting-class">
<h3><a class="toc-backref" href="#id26" name="representation-formatting-class">6.1.4   Representation formatting class</a></h3>
<p>And, finally, when the results have been returned, the <em>formatting
class</em> is used to produce a representation of the results.
Putting this formatting code in a separate class has at least two
benefits:</p>
<ul>
<li><p class="first">In a project of any size, there may be specialists working on
the user interface, the formatting of representations, etc.
Separating formatting code would provide a way to provide a
separate set of modules for those specialists to work on.</p>
</li>
<li><p class="first">It might be useful to do formatting with the Quixote PTL (Python
templating language), which is also available in Twisted.  By
putting formatting code in a separate class, we would be able to
put formatting code in <tt class="literal"><span class="pre">.ptl</span></tt> modules (for example) for
processing with PTL, then instructing Twisted to process them as
resource templates with something like the following:</p>
<pre class="literal-block">
$ mktap web --path=/var/www \
      --processor=.rtl=twisted.web.script.ResourceTemplate
</pre>
</li>
</ul>
<p>Our example, however, uses simple Python code to perform
formatting. Here is an example of the <em>representation formatting</em>
class:</p>
<pre class="literal-block">
#
# Representation Formatting class
#
class Formatter:

    def format_search_results(self, pagecontent, resultlist):
        contentlist = []
        contentlist.append('&lt;table border=&quot;1&quot;&gt;')
        contentlist.append('&lt;tr&gt;&lt;th&gt;File&lt;/th&gt;&lt;th&gt;Match&lt;/th&gt;&lt;/tr&gt;')
        idx = 0
        prevfilename = ''
        for result in resultlist:
            filename = result[0]
            line = result[1].replace('&lt;', '&amp;lt;')
            if filename != prevfilename:
                idx = 0
            target = '&lt;a href=&quot;/dispatch.rpy/get_text_file/%d%s&quot;&gt;%s&lt;/a&gt;' % \
                (idx, filename, filename)
            linecontent = '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % \
                (target, line)
            contentlist.append(linecontent)
            idx += 1
            prevfilename = filename
        contentlist.append('&lt;/table&gt;')
        contentstr = '\n'.join(contentlist)
        contentstr = pagecontent % contentstr
        return contentstr

    def format_file(self, incontent, path):
        stem, ext = os.path.splitext(path)
        if ext == '.html':
            return incontent
        else:
            content1 = incontent.replace('&lt;', '&amp;lt;')
            content2 = TextWrapper % (path, path, content1)
            return content2
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Method <tt class="literal"><span class="pre">format_search_results</span></tt> formats a list of search
results, one for each hit.  Note that it generates URLs that can
be used to request the file in which the pattern is found.</li>
<li>Method <tt class="literal"><span class="pre">format_file</span></tt> formats one file requested through a URL
generated by <tt class="literal"><span class="pre">format_search_results</span></tt>.  If the file contains
HTML, the file's contents are returned unchanged.  If the file
does <em>not</em> contain HTML, then left-corner-brackets are replaced
and a bit of HTML header and footer is wrapped around the
content.</li>
</ul>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id27" name="id4">6.2   Questions and discussion</a></h2>
<p>And, a few questions:</p>
<ul class="simple">
<li>How slow does a slow method have to be before it is worth
putting it into a deferred?  After all, the purpose of using a
search engine such as Glimpse is to speed up searches.  Perhaps
using deferred methods is over-kill.  Is there any down-side or
cost or over-head to using deferreds?</li>
</ul>
</div>
</div>
<div class="section" id="the-xml-rpc-pattern">
<h1><a class="toc-backref" href="#id28" name="the-xml-rpc-pattern">7   The XML-RPC Pattern</a></h1>
<p>This simple pattern can be used to make remote calls to an XML-RPC
server and then to deliver content that contains the results.  The
Twisted Web application is acting as an XML-RPC client .  The Web
application uses XML-RPC to request information that it will
return in its responses.</p>
<p>Requirements:</p>
<ul class="simple">
<li>Provide access to some resource through XML-RPC.  The Twisted
Web application acts as an XML-RPC client.</li>
<li>Deliver content that is formatted from the results of one or
more XML-RPC calls.</li>
</ul>
<p>Definitions:</p>
<ul class="simple">
<li>In REST terms, the back-end XML-RPC server is the <em>resource</em>.</li>
<li>And, the content that is formatted from the results of one or
more XML-RPC requests is the <em>representation</em>.</li>
</ul>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id29" name="id5">7.1   Example</a></h2>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id30" name="id6">7.1.1   The application logic class</a></h3>
<p>This class contains any application logic.  A typical example
would be the need to make more than one XML-RPC request, but to
include logic between the requests so that one request is
dependent on the results of a previous request.</p>
<p>Here is an example:</p>
<pre class="literal-block">
#
# XML-RPC applicationLogic class
#
class TemperatureAccess:

    #
    # Produce a form to be used to search the text repository.
    #
    def show_temperature_form(self, request):
        self.request = request
        self.content = Content_ConvertTemperatureForm
        self.request.write(self.content)
        self.request.finish()
        return NOT_DONE_YET

    #
    # Convert the temperature and produce the result.
    #
    def convert_temperature(self, request, direction):
        self.request = request
        intemp = None
        arg = request.args.get('intemp')
        if arg and len(arg) &gt; 0:
            intemp = arg[0]
        self.intemp = intemp
        self.converter = Conversion()
        self.direction = direction
        if direction == 'c2f':
            self.content = Content_ConvertC2FResults
            deferred = self.converter.c2f(intemp)
            deferred.addCallbacks(self.receiveTemperature, self.receiveError)
            return NOT_DONE_YET
        elif direction == 'f2c':
            self.content = Content_ConvertF2CResults
            deferred = self.converter.f2c(intemp)
            deferred.addCallbacks(self.receiveTemperature, self.receiveError)
        return NOT_DONE_YET
        
    def receiveTemperature(self, value):
        valuestr = '%.2f' % value
        self.outtemp = valuestr
        if self.direction == 'c2f':
            scale = 'F'
        else:
            scale = 'C'
        deferred = self.converter.category(scale, value)
        deferred.addCallbacks(self.receiveCategory, self.receiveError)
        return NOT_DONE_YET

    def receiveCategory(self, category):
        self.category = category
        deferred = self.converter.ranges()
        deferred.addCallbacks(self.receiveRanges, self.receiveError)
        return NOT_DONE_YET
        
    def receiveRanges(self, ranges):
        self.ranges = ranges
        rangelist = ['&lt;ul&gt;']
        for range in ranges:
            rangelist.append('&lt;li&gt;Less than %0.1f C is %s&lt;/li&gt;' % \
                (range[0], range[1]))
        rangelist.append('&lt;/ul&gt;')
        rangestr = '\n'.join(rangelist)
        content = self.content % \
            (self.intemp, self.outtemp, self.category, rangestr)
        self.request.write(content)
        self.request.finish()
        return NOT_DONE_YET
        
    def receiveError(self, error):
        raise RuntimeError, error
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Method <tt class="literal"><span class="pre">show_temperature_form</span></tt> delivers a form that enables
the client to provide a temperature and request a temperature
conversion.</li>
<li>Method <tt class="literal"><span class="pre">convert_temperature</span></tt> uses the XML-RPC class.  It (1)
creates and instance of the XML-RPC class, (2) calls the
conversion method in that class, which returns a deferred, then
(3) adds a callback function (<tt class="literal"><span class="pre">receiveTemperature</span></tt>) to that
deferred.</li>
<li>Method <tt class="literal"><span class="pre">receiveTemperature</span></tt> is called when the first XML-RPC
request has been completed.  It also uses the XML-RPC class.  It
(1) saves the converted temperature, (2) calls the <tt class="literal"><span class="pre">category</span></tt>
method in the XML-RPC class, which returns a deferred, then (3)
adds a callback function (<tt class="literal"><span class="pre">receiveCategory</span></tt>) to this (new)
deferred.</li>
<li>Method <tt class="literal"><span class="pre">receiveCategory</span></tt> (1) receives the next result (the
category) and (2) saves that value in an instance variable
(<tt class="literal"><span class="pre">self.category</span></tt>).  This method also (3) calls the <tt class="literal"><span class="pre">ranges</span></tt>
method in the XML-RPC class, which returns a deferred, then (4)
adds a callback function (<tt class="literal"><span class="pre">receiveRanges</span></tt>) to this (new)
deferred.</li>
<li>Method <tt class="literal"><span class="pre">receiveRanges</span></tt> (1) receives the final result (the
category), (2) formats the content, and (3) returns it to the
client.</li>
<li>The methods described above show how to chain methods together
when each method in a sequence is dependent on the results
returned by the previous method.  We could have alternatively
used a single method (in place of <tt class="literal"><span class="pre">receiveTemperature</span></tt>,
<tt class="literal"><span class="pre">receiveCategory</span></tt>, and <tt class="literal"><span class="pre">receiveRanges</span></tt>) which implemented a
finite state machine with separate states (for
<tt class="literal"><span class="pre">receiveTemperature</span></tt>, <tt class="literal"><span class="pre">receiveCategory</span></tt>, and
<tt class="literal"><span class="pre">receiveRanges</span></tt>).</li>
<li>Method <tt class="literal"><span class="pre">receiveError</span></tt> reports any errors raised by the XML-RPC
server.</li>
</ul>
</div>
<div class="section" id="the-xml-rpc-requester-class">
<h3><a class="toc-backref" href="#id31" name="the-xml-rpc-requester-class">7.1.2   The XML-RPC requester class</a></h3>
<p>This class makes the XML-RPC requests.  It acts as the XML-RPC
client. It uses Twisted's XML-RPC support, which returns a
deferred object.</p>
<p>Here is a sample class:</p>
<pre class="literal-block">
from twisted.web.xmlrpc import Proxy

#
# XML-RPC back-end resource class.
# This class makes the XML-RPC requests and returns deferreds.
#
class Conversion:
    def c2f(self, intempstr):
        intemp = -1
        try:
            intemp = float(intempstr)
        except:
            pass
        proxy = Proxy('http://localhost:8081')
        deferred = proxy.callRemote('c2f', intemp)
        return deferred

    def f2c(self, intempstr):
        intemp = -1
        try:
            intemp = float(intempstr)
        except:
            pass
        proxy = Proxy('http://localhost:8081')
        deferred = proxy.callRemote('f2c', intemp)
        return deferred

    def category(self, scale, intemp):
        proxy = Proxy('http://localhost:8081')
        deferred = proxy.callRemote('temperature_category', scale, intemp)
        return deferred

    def ranges(self):
        proxy = Proxy('http://localhost:8081')
        deferred = proxy.callRemote('temperature_ranges')
        return deferred
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Each method in this class makes an XML-RPC request and returns a
deferred.</li>
<li>These methods use Twisted's XML-RPC support (as opposed to using
module <tt class="literal"><span class="pre">xmlrpclib</span></tt> in the Python standard library, for
example).</li>
</ul>
</div>
<div class="section" id="the-xml-rpc-server">
<h3><a class="toc-backref" href="#id32" name="the-xml-rpc-server">7.1.3   The XML-RPC server</a></h3>
<p>This is the simple XML-RPC server written in Python that I used
while testing my examples:</p>
<pre class="literal-block">
import SimpleXMLRPCServer

def c2f(ctemp):
    #ftemp = ((212.0 - 32.0)/100.0 * ctemp) + 32.0
    ftemp = ((9.0 / 5.0) * ctemp) + 32
    return ftemp

def f2c(ftemp):
    #ctemp = 100.0/(212.0 - 32.0) * (ftemp - 32.0)
    ctemp = (5.0 / 9.0) * (ftemp - 32)
    return ctemp

Ranges = [
    (0.0, 'cold'),
    (20.0, 'cool'),
    (25.0, 'moderate'),
    (30.0, 'warm'),
    (35.0, 'hot'),
    (40.0, 'very hot'),
    (1000.0, 'extremely hot'),
    ]

def temperature_category(scale, intemp):
    if scale.upper() == 'F':
        temp = f2c(intemp)
    else:
        temp = intemp
    category = 'Unknown'
    for range in Ranges:
        if temp &lt;= range[0]:
            category = range[1]
            break
    return category

def temperature_ranges():
    return Ranges

def startup():
    server = SimpleXMLRPCServer.SimpleXMLRPCServer((&quot;localhost&quot;, 8081))
    server.register_function(c2f)
    server.register_function(f2c)
    server.register_function(temperature_category)
    server.register_function(temperature_ranges)
    server.serve_forever()
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>The functions <tt class="literal"><span class="pre">c2f</span></tt>, <tt class="literal"><span class="pre">f2c</span></tt>, <tt class="literal"><span class="pre">temperature_category</span></tt>, and
<tt class="literal"><span class="pre">temperature_ranges</span></tt> are exported and are available to be
called through XML-RPC requests.</li>
<li>Function <tt class="literal"><span class="pre">startup</span></tt> creates a server, registers the exported
functions, and starts the server.</li>
</ul>
</div>
<div class="section" id="an-xml-rpc-server-implemented-with-twisted">
<h3><a class="toc-backref" href="#id33" name="an-xml-rpc-server-implemented-with-twisted">7.1.4   An XML-RPC server implemented with Twisted</a></h3>
<p>And here is the same XML-RPC server implemented as a Twisted
applications:</p>
<pre class="literal-block">
from twisted.web import xmlrpc, server

Ranges = [
    (0.0, 'cold'),
    (20.0, 'cool'),
    (25.0, 'moderate'),
    (30.0, 'warm'),
    (35.0, 'hot'),
    (40.0, 'very hot'),
    (1000.0, 'extremely hot'),
    ]

class Converter(xmlrpc.XMLRPC):
    def xmlrpc_c2f(self, ctemp):
        #ftemp = ((212.0 - 32.0)/100.0 * ctemp) + 32.0
        ftemp = ((9.0 / 5.0) * ctemp) + 32
        return ftemp
    def xmlrpc_f2c(self, ftemp):
        #ctemp = 100.0/(212.0 - 32.0) * (ftemp - 32.0)
        ctemp = (5.0 / 9.0) * (ftemp - 32)
        return ctemp
    def xmlrpc_temperature_category(self, scale, intemp):
        if scale.upper() == 'F':
            temp = self.xmlrpc_f2c(intemp)
        else:
            temp = intemp
        category = 'Unknown'
        for range in Ranges:
            if temp &lt;= range[0]:
                category = range[1]
                break
        return category
    def xmlrpc_temperature_ranges(self):
        return Ranges

def main():
    from twisted.internet.app import Application
    app = Application(&quot;xmlrpc&quot;)
    r = Converter()
    app.listenTCP(8081, server.Site(r))
    return app

application = main()

if __name__ == '__main__':
    application.run(save=0)
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>This example is basically a copy of the previous example with
the functions encapsulated in a class.</li>
<li>To learn how to use Twisted to expose the methods in a class as
XML-RPC services, read <a class="reference" href="http://www.twistedmatrix.com/documents/howto/xmlrpc">Creating XML-RPC Servers and Clients
with Twisted</a>.  I followed the instructions and example in that
document.  It's simple enough so that I won't add much.</li>
</ul>
<ul class="simple">
<li>By default, methods prefixed with &quot;xmlrpc_&quot; are exposed to
clients as XML-RPC services.  See <tt class="literal"><span class="pre">twisted.web.xmlrpc.py</span></tt>.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="miscellaneous-hints-and-howto-s">
<h1><a class="toc-backref" href="#id34" name="miscellaneous-hints-and-howto-s">8   Miscellaneous Hints and Howto's</a></h1>
<p>Here are a few clues and examples that were not covered in the
patterns themselves.</p>
<div class="section" id="body-data-content">
<h2><a class="toc-backref" href="#id35" name="body-data-content">8.1   Body data/content</a></h2>
<p>In order to extract the data from the body of a request, use
<tt class="literal"><span class="pre">request.content</span></tt>.  If there is content, then
<tt class="literal"><span class="pre">request.content</span></tt> will contain an instance of <tt class="literal"><span class="pre">cStringIO</span></tt>.</p>
<p>Here is an example that shows how to use it:</p>
<pre class="literal-block">
data = ''
if request.content:
    data = request.content.getvalue()
</pre>
</div>
<div class="section" id="debugging">
<h2><a class="toc-backref" href="#id36" name="debugging">8.2   Debugging</a></h2>
<p>It is often helpful to produce some debugging information.  This
example shows how to print messages to a log file:</p>
<pre class="literal-block">
from twisted.python import log

# Set to 0 (debugging off) or 1 (debugging on).
_DEBUG = 0

def dbglogmsg(mesg):
    if _DEBUG:
        log.msg(mesg)
</pre>
<p>l
Sharing values across sessions
------------------------------</p>
<p>Twisted provides a mechanism for sharing values across sessions.
In order to do this, define a class, store the values you wish to
share in an instance of the class, then request the shared values
by asking Twisted for the shared value of that data type.  
The <a class="reference" href="#connection-pooling">Connection pooling</a> example above shows how to share values
across sessions.</p>
</div>
<div class="section" id="a-test-harness">
<h2><a class="toc-backref" href="#id37" name="a-test-harness">8.3   A test harness</a></h2>
<p>You may want to be able to create a testing harness that acts as a
client.  It can be used to send requests to your Twisted Web
application and to display or process the responses.  If expanded,
it can serve as a simple client that drives your application.  You
can use the following example as a starting point for the
implementation of a Python client that talks to your Twisted Web
application.</p>
<p>Here is the example:</p>
<pre class="literal-block">
import httplib, urllib

#
# Send a request to my Twisted Web application.
# Add a few arguments to the request and pack some content into
#   the body of the request.
# Get the response, display the status of the response, and
#   display the content received with the response.
#
def test():
    # Create some sample content to send as the body of the request.
    datalist = []
    datalist.append('&lt;testcontent&gt;')
    datalist.append('Here is stuff for a test.')
    datalist.append('&lt;/testcontent&gt;')
    data = '\n'.join(datalist)
    # Create a few dummy parameters.
    paramdict = {'aaa': 111, 'bbb': 222}
    params = urllib.urlencode(paramdict)
    # Here are headers for the request.  Note the &quot;Content-length&quot;.
    headers = {&quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;,
        &quot;Accept&quot;: &quot;text/html&quot;,
        &quot;Content-length&quot;: len(data),
        }
    conn = httplib.HTTPConnection(&quot;localhost:8080&quot;)
    conn.set_debuglevel(1)
    selector = '/dispatch.rpy/?%s' % params
    # Pick one: GET or POST?
    conn.putrequest(&quot;GET&quot;, selector)
    ## conn.putrequest(&quot;POST&quot;, selector)
    for key, val in headers.iteritems():
        conn.putheader(key, val)
    conn.endheaders()
    conn.send(data)
    response = conn.getresponse()
    print 'status/reason', response.status, response.reason
    data1 = response.read()
    print '=' * 50
    print data1
</pre>
<p>Explanation:</p>
<ul class="simple">
<li>Each call to function <tt class="literal"><span class="pre">test</span></tt> makes one request to the Web
application.</li>
<li>Local variables <tt class="literal"><span class="pre">datalist/data</span></tt> are used to create content to
be sent in the <em>body</em> of the request.</li>
<li>Note the commented lines that would enable you to choose between
making a <tt class="literal"><span class="pre">GET</span></tt> or a <tt class="literal"><span class="pre">POST</span></tt> request.</li>
<li>This example prints out the response from the Web application.
However, your own client implementation could process the
response in other ways.</li>
</ul>
</div>
</div>
<div class="section" id="summary-and-conclusions">
<h1><a class="toc-backref" href="#id38" name="summary-and-conclusions">9   Summary and Conclusions</a></h1>
<p>This document has tried to help Twisted developers of Web
applications in two ways:</p>
<ul class="simple">
<li>Help beginning Twisted users a set of examples (patterns) which
enable them to quickly construct Twisted Web applications.</li>
<li>Help experienced Twisted users by giving them a set of patterns
(examples) that improve their code through consistency and
clarity.</li>
</ul>
<p>Thanks in advance for suggestions and guidance.</p>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id39" name="acknowledgements">10   Acknowledgements</a></h1>
<p>Thanks to Andrew Bennetts for many suggestions and criticisms on
an earlier draft.</p>
<p>Thanks to the developers and supporters of Twisted for a powerful
product.</p>
</div>
<div class="section" id="see-also">
<h1><a class="toc-backref" href="#id40" name="see-also">11   See Also</a></h1>
<p><a class="reference" href="http://www.twistedmatrix.com/">Twisted</a>: The Twisted network framework at TwistedMatrix</p>
<p><a class="reference" href="http://www.python.org">Python home</a>: The Python Web site.</p>
<p><a class="reference" href="http://internet.conveyor.com/RESTwiki/moin.cgi/RestFaq">RestFaq</a>: The REST FAQ -- Information and links for
REpresentational State Transfer.</p>
<p><a class="reference" href="http://webglimpse.net/">Glimpse</a>: The Glimpse search engine Web site.</p>
<p><a class="reference" href="http://docutils.sourceforge.net/">Docutils</a>:  Python Documentation Utilities -- This document was
formatted with Docutils.</p>
</div>
</div>
<hr class="footer"/>
<div class="footer">
<a class="reference" href="twisted_patterns.txt">View document source</a>.
Generated on: 2003-09-22 21:17 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
