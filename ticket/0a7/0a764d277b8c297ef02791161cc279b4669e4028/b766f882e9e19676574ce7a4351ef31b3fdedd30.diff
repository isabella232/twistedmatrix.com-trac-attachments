Index: twisted/conch/test/test_transport.py
===================================================================
--- twisted/conch/test/test_transport.py	(revision 20596)
+++ twisted/conch/test/test_transport.py	(working copy)
@@ -5,6 +5,8 @@
 Tests for ssh/transport.py and the classes therein.
 """
 
+import md5, sha
+
 try:
     import Crypto
 except ImportError:
@@ -20,12 +22,11 @@
     from twisted.conch.ssh import transport, common, keys, factory
     from twisted.conch.test import test_keys
 
-import md5, sha
+from twisted.python import log
 from twisted.trial import unittest
-from twisted.conch.ssh import service
 from twisted.internet import defer
 from twisted.protocols import loopback
-from twisted.python import log
+from twisted.conch.ssh import service
 from twisted.test import proto_helpers
 
 
@@ -119,7 +120,7 @@
     name = "TestService"
     started = False
     stopped = False
-    protocolMessages = {0xff:"MSG_TEST", 71:"MSG_fiction"}
+    protocolMessages = {0xff: "MSG_TEST", 71: "MSG_fiction"}
 
     def logPrefix(self):
         return "TestService"
@@ -138,27 +139,27 @@
     A mocked-up factory based on twisted.conch.ssh.factory.SSHFactory.
     """
     services = {
-            'ssh-userauth':TestService
-            }
+        'ssh-userauth': TestService}
 
     def getPublicKeys(self):
         return {
-            'ssh-rsa':keys.getPublicKeyString(data=test_keys.publicRSA_openssh),
-            'ssh-dsa':keys.getPublicKeyString(data=test_keys.publicDSA_openssh),
-            }
+            'ssh-rsa': keys.getPublicKeyString(
+                data=test_keys.publicRSA_openssh),
+            'ssh-dsa': keys.getPublicKeyString(
+                data=test_keys.publicDSA_openssh)}
 
     def getPrivateKeys(self):
         return {
-        'ssh-rsa':keys.getPrivateKeyObject(data=test_keys.privateRSA_openssh),
-        'ssh-dsa':keys.getPrivateKeyObject(data=test_keys.privateDSA_openssh),
-        }
+            'ssh-rsa': keys.getPrivateKeyObject(
+                data=test_keys.privateRSA_openssh),
+            'ssh-dsa': keys.getPrivateKeyObject(
+                data=test_keys.privateDSA_openssh)}
 
     def getPrimes(self):
         return {
             1024: ((2, transport.DH_PRIME),),
             2048: ((3, transport.DH_PRIME),),
-            4096: ((5, 6),),
-            }
+            4096: ((5, 6),)}
 
 class TransportTestCase(unittest.TestCase):
     klass = None
@@ -197,7 +198,7 @@
         """
         # the other setup was done in the setup method
         self.assertEquals(self.transport.value().split('\r\n',1)[0],
-                "SSH-2.0-Twisted")
+                          "SSH-2.0-Twisted")
 
     def test_sendPacketPlain(self):
         """
@@ -231,7 +232,7 @@
 
     def test_sendPacketCompressed(self):
         """
-        Test that packets sent while compression is enabled are sent 
+        Test that packets sent while compression is enabled are sent
         correctly.
         """
         proto = TestTransportBase()
@@ -240,11 +241,13 @@
         self.transport.clear()
         proto.sendPacket(ord('A'), 'B')
         value = self.transport.value()
-        self.assertEquals(value, '\x00\x00\x00\x0c\x08BA\x66\x99\x99\x99\x99\x99\x99\x99\x99')
+        self.assertEquals(
+            value,
+            '\x00\x00\x00\x0c\x08BA\x66\x99\x99\x99\x99\x99\x99\x99\x99')
 
     def test_sendPacketBoth(self):
         """
-        Test that packets sent while compression and encryption are 
+        Test that packets sent while compression and encryption are
         enabled are sent correctly.
         """
         proto = TestTransportBase()
@@ -256,7 +259,10 @@
         self.transport.clear()
         proto.sendPacket(message, payload)
         value = self.transport.value()
-        self.assertEquals(value, '\x00\x00\x00\x0e\x09CBA\x66\x99\x99\x99\x99\x99\x99\x99\x99\x99\x01')
+        self.assertEquals(
+            value,
+            '\x00\x00\x00\x0e\x09CBA\x66\x99\x99\x99\x99\x99\x99\x99\x99\x99'
+            '\x01')
 
     def test_getPacketPlain(self):
         """
@@ -296,7 +302,8 @@
         proto = TestTransportBase()
         proto.makeConnection(self.transport)
         self.transport.clear()
-        proto.outgoingCompression = proto.incomingCompression = TestCompression()
+        proto.outgoingCompression = TestCompression()
+        proto.incomingCompression = proto.outgoingCompression
         proto.sendPacket(ord('A'), 'BCD')
         proto.buf = self.transport.value()
         self.assertEquals(proto.getPacket(), 'ABCD')
@@ -310,7 +317,8 @@
         proto.makeConnection(self.transport)
         self.transport.clear()
         proto.currentEncryptions = testCipher = TestCipher()
-        proto.outgoingCompression = proto.incomingCompression = TestCompression()
+        proto.outgoingCompression = TestCompression()
+        proto.incomingCompression = proto.outgoingCompression
         proto.sendPacket(ord('A'), 'BCDEFG')
         proto.buf = self.transport.value()
         self.assertEquals(proto.getPacket(), 'ABCDEFG')
@@ -320,7 +328,7 @@
         Test that all the supportedCiphers are valid.
         """
         ciphers = transport.SSHCiphers('A', 'B', 'C', 'D')
-        iv = key = '\x00'*16
+        iv = key = '\x00' * 16
         for cipName in self.proto.supportedCiphers:
             self.assertTrue(ciphers._getCipher(cipName, iv, key))
 
@@ -333,10 +341,10 @@
         self.proto.buf = value
         packet = self.proto.getPacket()
         self.assertEquals(packet[0], chr(transport.MSG_KEXINIT))
-        self.assertEquals(packet[1:17], '\x99'*16)
+        self.assertEquals(packet[1:17], '\x99' * 16)
         (kex, pubkeys, ciphers1, ciphers2, macs1, macs2, compressions1,
-                compressions2, languages1, languages2,
-                buf) = common.getNS(packet[17:], 10)
+         compressions2, languages1, languages2,
+         buf) = common.getNS(packet[17:], 10)
 
         self.assertEquals(kex, ','.join(self.proto.supportedKeyExchanges))
         self.assertEquals(pubkeys, ','.join(self.proto.supportedPublicKeys))
@@ -345,9 +353,9 @@
         self.assertEquals(macs1, ','.join(self.proto.supportedMACs))
         self.assertEquals(macs2, ','.join(self.proto.supportedMACs))
         self.assertEquals(compressions1,
-                ','.join(self.proto.supportedCompressions))
+                          ','.join(self.proto.supportedCompressions))
         self.assertEquals(compressions2,
-                ','.join(self.proto.supportedCompressions))
+                          ','.join(self.proto.supportedCompressions))
         self.assertEquals(languages1, ','.join(self.proto.supportedLanguages))
         self.assertEquals(languages2, ','.join(self.proto.supportedLanguages))
         self.assertEquals(buf, '\x00' * 5)
@@ -357,14 +365,17 @@
         Test that debug messages are sent correctly.
         """
         self.proto.sendDebug("test", True, 'en')
-        self.assertEquals(self.packets, [(transport.MSG_DEBUG,
-            "\x01\x00\x00\x00\x04test\x00\x00\x00\x02en")])
+        self.assertEquals(
+            self.packets,
+            [(transport.MSG_DEBUG,
+              "\x01\x00\x00\x00\x04test\x00\x00\x00\x02en")])
 
     def test_receiveDebug(self):
         """
         Test that debug messages are received correctly.
         """
-        self.proto.dispatchMessage(transport.MSG_DEBUG,
+        self.proto.dispatchMessage(
+            transport.MSG_DEBUG,
             '\x01\x00\x00\x00\x04test\x00\x00\x00\x02en')
         self.assertEquals(self.proto.debugs, [(True, 'test', 'en')])
 
@@ -373,8 +384,9 @@
         Test that ignored messages are sent correctly.
         """
         self.proto.sendIgnore("test")
-        self.assertEquals(self.packets, [(transport.MSG_IGNORE,
-            '\x00\x00\x00\x04test')])
+        self.assertEquals(
+            self.packets, [(transport.MSG_IGNORE,
+                            '\x00\x00\x00\x04test')])
 
     def test_receiveIgnore(self):
         """
@@ -388,15 +400,16 @@
         Test that unimplemented messages are sent correctly.
         """
         self.proto.sendUnimplemented()
-        self.assertEquals(self.packets, [(transport.MSG_UNIMPLEMENTED,
-            '\x00\x00\x00\x00')])
+        self.assertEquals(
+            self.packets, [(transport.MSG_UNIMPLEMENTED,
+                            '\x00\x00\x00\x00')])
 
     def test_receiveUnimplemented(self):
         """
         Test that unimplemented messages are received correctly.
         """
         self.proto.dispatchMessage(transport.MSG_UNIMPLEMENTED,
-                '\x00\x00\x00\xff')
+                                   '\x00\x00\x00\xff')
         self.assertEquals(self.proto.unimplementeds, [255])
 
     def test_sendDisconnect(self):
@@ -408,8 +421,10 @@
             disconnected[0] = True
         self.transport.loseConnection = _
         self.proto.sendDisconnect(0xff, "test")
-        self.assertEquals(self.packets, [(transport.MSG_DISCONNECT,
-            "\x00\x00\x00\xff\x00\x00\x00\x04test\x00\x00\x00\x00")])
+        self.assertEquals(
+            self.packets,
+            [(transport.MSG_DISCONNECT,
+              "\x00\x00\x00\xff\x00\x00\x00\x04test\x00\x00\x00\x00")])
         self.assertTrue(disconnected[0])
 
     def test_receiveDisconnect(self):
@@ -421,7 +436,7 @@
             disconnected[0] = True
         self.transport.loseConnection = _
         self.proto.dispatchMessage(transport.MSG_DISCONNECT,
-                '\x00\x00\x00\xff\x00\x00\x00\x04test')
+                                   '\x00\x00\x00\xff\x00\x00\x00\x04test')
         self.assertEquals(self.proto.errors, [(255, 'test')])
         self.assertTrue(disconnected[0])
 
@@ -436,7 +451,7 @@
         self.proto.dataReceived(self.transport.value())
         self.assertTrue(self.proto.gotVersion)
         self.assertEquals(self.proto.ourVersionString,
-                self.proto.otherVersionString)
+                          self.proto.otherVersionString)
         self.assertTrue(kexInit[0])
 
     def test_service(self):
@@ -483,7 +498,7 @@
         self.assertTrue(self.proto.isEncrypted('out'))
         self.assertTrue(self.proto.isEncrypted('both'))
         self.proto.currentEncryptions = transport.SSHCiphers('none', 'none',
-                'none', 'none')
+                                                             'none', 'none')
         self.assertFalse(self.proto.isVerified('in'))
         self.assertFalse(self.proto.isVerified('out'))
         self.assertFalse(self.proto.isVerified('both'))
@@ -500,7 +515,7 @@
         self.assertTrue(self.proto.isVerified('out'))
         self.assertTrue(self.proto.isVerified('both'))
         self.proto.currentEncryptions = transport.SSHCiphers('none', 'none',
-                'none', 'none')
+                                                             'none', 'none')
         self.assertFalse(self.proto.isVerified('in'))
         self.assertFalse(self.proto.isVerified('out'))
         self.assertFalse(self.proto.isVerified('both'))
@@ -517,7 +532,7 @@
         self.proto.loseConnection()
         self.assertEquals(self.packets[0][0], transport.MSG_DISCONNECT)
         self.assertEquals(self.packets[0][1][3],
-                chr(transport.DISCONNECT_CONNECTION_LOST))
+                          chr(transport.DISCONNECT_CONNECTION_LOST))
 
     def test_badVersion(self):
         """
@@ -530,12 +545,13 @@
             def _():
                 disconnected[0] = True
             self.transport.loseConnection = _
-            for c in version+'\r\n':
+            for c in version + '\r\n':
                 self.proto.dataReceived(c)
             self.assertTrue(disconnected[0])
             self.assertEquals(self.packets[0][0], transport.MSG_DISCONNECT)
-            self.assertEquals(self.packets[0][1][3],
-                    chr(transport.DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED))
+            self.assertEquals(
+                self.packets[0][1][3],
+                chr(transport.DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED))
         testBad('SSH-1.5-OpenSSH')
         testBad('SSH-3.0-Twisted')
         testBad('GET / HTTP/1.1')
@@ -548,7 +564,7 @@
         proto.makeConnection(proto_helpers.StringTransport())
         data = ("""here's some stuff beforehand
 here's some other stuff
-""" + proto.ourVersionString+"\r\n")
+""" + proto.ourVersionString + "\r\n")
         [proto.dataReceived(c) for c in data]
         self.assertTrue(proto.gotVersion)
         self.assertEquals(proto.otherVersionString, proto.ourVersionString)
@@ -579,7 +595,7 @@
             self.assertEquals(self.packets[0][0], transport.MSG_DISCONNECT)
             self.assertEquals(self.packets[0][1][3], chr(error))
 
-        testBad('\xff'*8) # big packet
+        testBad('\xff' * 8) # big packet
         testBad('\x00\x00\x00\x05\x00BCDE') # length not modulo blocksize
         oldEncryptions = self.proto.currentEncryptions
         self.proto.currentEncryptions = TestCipher()
@@ -602,7 +618,7 @@
         seqnum = self.proto.incomingPacketSequence
         def checkUnimplemented(seqnum=seqnum):
             self.assertEquals(self.packets[0][0],
-                    transport.MSG_UNIMPLEMENTED)
+                              transport.MSG_UNIMPLEMENTED)
             self.assertEquals(self.packets[0][1][3], chr(seqnum))
             self.proto.packets = []
             seqnum += 1
@@ -627,7 +643,7 @@
         self.proto.sessionID = 'EF'
 
         k1 = sha.new('AB' + 'CD'
-                + 'K' + self.proto.sessionID).digest()
+                     + 'K' + self.proto.sessionID).digest()
         k2 = sha.new('ABCD' + k1).digest()
         self.assertEquals(self.proto._getKey('K', 'AB', 'CD'), k1 + k2)
 
@@ -648,11 +664,11 @@
         self.failIfEquals(proto.gotVersion, proto2.gotVersion)
         self.failIfEquals(proto.transport, proto2.transport)
         self.failIfEquals(proto.outgoingPacketSequence,
-                proto2.outgoingPacketSequence)
+                          proto2.outgoingPacketSequence)
         self.failIfEquals(proto.incomingPacketSequence,
-                proto2.incomingPacketSequence)
+                          proto2.incomingPacketSequence)
         self.failIfEquals(proto.currentEncryptions,
-                proto2.currentEncryptions)
+                          proto2.currentEncryptions)
         self.failIfEquals(proto.service, proto2.service)
 
 class ServerAndClientSSHTransportBaseCase:
@@ -663,13 +679,13 @@
         """
         self.proto.dataReceived(self.transport.value())
         self.assertEquals(self.proto.kexAlg,
-                self.proto.supportedKeyExchanges[0])
+                          self.proto.supportedKeyExchanges[0])
         self.assertEquals(self.proto.keyAlg,
-                self.proto.supportedPublicKeys[0])
+                          self.proto.supportedPublicKeys[0])
         self.assertEquals(self.proto.outgoingCompressionType,
-                self.proto.supportedCompressions[0])
+                          self.proto.supportedCompressions[0])
         self.assertEquals(self.proto.incomingCompressionType,
-                self.proto.supportedCompressions[0])
+                          self.proto.supportedCompressions[0])
         ne = self.proto.nextEncryptions
         self.assertEquals(ne.outCipType, self.proto.supportedCiphers[0])
         self.assertEquals(ne.inCipType, self.proto.supportedCiphers[0])
@@ -757,24 +773,26 @@
 
     def test_ignoreGuessPacketKex(self):
         """
-        The client is allowed to send a guessed key exchange packet 
+        The client is allowed to send a guessed key exchange packet
         after it sends the KEXINIT packet.  However, if the key exchanges
         do not match, that guess packet must be ignored.  This tests that
-        the packet is ignored in the case of the key exchange method not 
+        the packet is ignored in the case of the key exchange method not
         matching.
         """
-        kexInitPacket = '\x00'*16 + (''.join([common.NS(x) for x in
-            [','.join(y) for y in
-                [self.proto.supportedKeyExchanges[::-1],
-                    self.proto.supportedPublicKeys,
-                    self.proto.supportedCiphers,
-                    self.proto.supportedCiphers,
-                    self.proto.supportedMACs,
-                    self.proto.supportedMACs,
-                    self.proto.supportedCompressions,
-                    self.proto.supportedCompressions,
-                    self.proto.supportedLanguages,
-                    self.proto.supportedLanguages]]]))+'\xff\x00\x00\x00\x00'
+        kexInitPacket = '\x00' * 16 + (
+            ''.join([common.NS(x) for x in
+                     [','.join(y) for y in
+                      [self.proto.supportedKeyExchanges[::-1],
+                       self.proto.supportedPublicKeys,
+                       self.proto.supportedCiphers,
+                       self.proto.supportedCiphers,
+                       self.proto.supportedMACs,
+                       self.proto.supportedMACs,
+                       self.proto.supportedCompressions,
+                       self.proto.supportedCompressions,
+                       self.proto.supportedLanguages,
+                       self.proto.supportedLanguages]]])) + (
+            '\xff\x00\x00\x00\x00')
         self.proto.ssh_KEXINIT(kexInitPacket)
         self.assertTrue(self.proto.ignoreNextPacket)
         self.proto.ssh_DEBUG("\x01\x00\x00\x00\x04test\x00\x00\x00\x00")
@@ -795,18 +813,20 @@
         Like test_ignoreGuessPacketKex, but for an incorrectly guessed
         public key format.
         """
-        kexInitPacket = '\x00'*16 + (''.join([common.NS(x) for x in
-            [','.join(y) for y in
-                [self.proto.supportedKeyExchanges,
-                    self.proto.supportedPublicKeys[::-1],
-                    self.proto.supportedCiphers,
-                    self.proto.supportedCiphers,
-                    self.proto.supportedMACs,
-                    self.proto.supportedMACs,
-                    self.proto.supportedCompressions,
-                    self.proto.supportedCompressions,
-                    self.proto.supportedLanguages,
-                    self.proto.supportedLanguages]]]))+'\xff\x00\x00\x00\x00'
+        kexInitPacket = '\x00' * 16 + (
+            ''.join([common.NS(x) for x in
+                     [','.join(y) for y in
+                      [self.proto.supportedKeyExchanges,
+                       self.proto.supportedPublicKeys[::-1],
+                       self.proto.supportedCiphers,
+                       self.proto.supportedCiphers,
+                       self.proto.supportedMACs,
+                       self.proto.supportedMACs,
+                       self.proto.supportedCompressions,
+                       self.proto.supportedCompressions,
+                       self.proto.supportedLanguages,
+                       self.proto.supportedLanguages]]])) + (
+            '\xff\x00\x00\x00\x00')
         self.proto.ssh_KEXINIT(kexInitPacket)
         self.assertTrue(self.proto.ignoreNextPacket)
         self.proto.ssh_DEBUG("\x01\x00\x00\x00\x04test\x00\x00\x00\x00")
@@ -846,12 +866,14 @@
         exchangeHash = h.digest()
 
         signature = keys.signData(self.proto.factory.privateKeys['ssh-rsa'],
-                exchangeHash)
+                                  exchangeHash)
 
-        self.assertEquals(self.packets, [(transport.MSG_KEXDH_REPLY,
-            common.NS(self.proto.factory.publicKeys['ssh-rsa'])
-            + f + common.NS(signature)),
-            (transport.MSG_NEWKEYS, '')])
+        self.assertEquals(
+            self.packets,
+            [(transport.MSG_KEXDH_REPLY,
+              common.NS(self.proto.factory.publicKeys['ssh-rsa'])
+              + f + common.NS(signature)),
+             (transport.MSG_NEWKEYS, '')])
 
     def test_KEX_DH_GEX_REQUEST_OLD(self):
         """
@@ -863,8 +885,10 @@
         self.proto.supportedPublicKeys = ['ssh-rsa']
         self.proto.dataReceived(self.transport.value())
         self.proto.ssh_KEX_DH_GEX_REQUEST_OLD('\x00\x00\x04\x00')
-        self.assertEquals(self.packets, [(transport.MSG_KEX_DH_GEX_GROUP,
-            common.MP(transport.DH_PRIME) +'\x00\x00\x00\x01\x02')])
+        self.assertEquals(
+            self.packets,
+            [(transport.MSG_KEX_DH_GEX_GROUP,
+              common.MP(transport.DH_PRIME) +'\x00\x00\x00\x01\x02')])
         self.assertEquals(self.proto.g, 2)
         self.assertEquals(self.proto.p, transport.DH_PRIME)
 
@@ -873,13 +897,15 @@
         Test that the KEX_DH_GEX_REQUEST message is processed correctly.
         """
         self.proto.supportedKeyExchanges = [
-                'diffie-hellman-group-exchange-sha1']
+            'diffie-hellman-group-exchange-sha1']
         self.proto.supportedPublicKeys = ['ssh-rsa']
         self.proto.dataReceived(self.transport.value())
         self.proto.ssh_KEX_DH_GEX_REQUEST('\x00\x00\x04\x00\x00\x00\x08\x00' +
-                '\x00\x00\x0c\x00')
-        self.assertEquals(self.packets, [(transport.MSG_KEX_DH_GEX_GROUP,
-            common.MP(transport.DH_PRIME) + '\x00\x00\x00\x01\x03')])
+                                          '\x00\x00\x0c\x00')
+        self.assertEquals(
+            self.packets,
+            [(transport.MSG_KEX_DH_GEX_GROUP,
+              common.MP(transport.DH_PRIME) + '\x00\x00\x00\x01\x03')])
         self.assertEquals(self.proto.g, 3)
         self.assertEquals(self.proto.p, transport.DH_PRIME)
 
@@ -890,12 +916,12 @@
         """
         self.test_KEX_DH_GEX_REQUEST()
         e = pow(self.proto.g, 3, self.proto.p)
-        y = common.getMP('\x00\x00\x00\x80'+'\x99'*128)[0]
+        y = common.getMP('\x00\x00\x00\x80' + '\x99' * 128)[0]
         f = common._MPpow(self.proto.g, y, self.proto.p)
         sharedSecret = common._MPpow(e, y, self.proto.p)
         h = sha.new()
-        h.update(common.NS(self.proto.ourVersionString)*2)
-        h.update(common.NS(self.proto.ourKexInitPayload)*2)
+        h.update(common.NS(self.proto.ourVersionString) * 2)
+        h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.proto.factory.publicKeys['ssh-rsa']))
         h.update('\x00\x00\x04\x00\x00\x00\x08\x00\x00\x00\x0c\x00')
         h.update(common.MP(self.proto.p))
@@ -905,11 +931,13 @@
         h.update(sharedSecret)
         exchangeHash = h.digest()
         self.proto.ssh_KEX_DH_GEX_INIT(common.MP(e))
-        self.assertEquals(self.packets[1], (transport.MSG_KEX_DH_GEX_REPLY,
-            common.NS(self.proto.factory.publicKeys['ssh-rsa']) +
-            f + common.NS(keys.signData(
-                self.proto.factory.privateKeys['ssh-rsa'],
-                exchangeHash))))
+        self.assertEquals(
+            self.packets[1],
+            (transport.MSG_KEX_DH_GEX_REPLY,
+             common.NS(self.proto.factory.publicKeys['ssh-rsa']) +
+             f + common.NS(keys.signData(
+                        self.proto.factory.privateKeys['ssh-rsa'],
+                        exchangeHash))))
 
     def test_KEX_DH_GEX_INIT_after_REQUEST_OLD(self):
         """
@@ -918,12 +946,12 @@
         """
         self.test_KEX_DH_GEX_REQUEST_OLD()
         e = pow(self.proto.g, 3, self.proto.p)
-        y = common.getMP('\x00\x00\x00\x80'+'\x99'*128)[0]
+        y = common.getMP('\x00\x00\x00\x80'+'\x99' * 128)[0]
         f = common._MPpow(self.proto.g, y, self.proto.p)
         sharedSecret = common._MPpow(e, y, self.proto.p)
         h = sha.new()
-        h.update(common.NS(self.proto.ourVersionString)*2)
-        h.update(common.NS(self.proto.ourKexInitPayload)*2)
+        h.update(common.NS(self.proto.ourVersionString) * 2)
+        h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.proto.factory.publicKeys['ssh-rsa']))
         h.update('\x00\x00\x04\x00')
         h.update(common.MP(self.proto.p))
@@ -933,12 +961,14 @@
         h.update(sharedSecret)
         exchangeHash = h.digest()
         self.proto.ssh_KEX_DH_GEX_INIT(common.MP(e))
-        self.assertEquals(self.packets[1:], [(transport.MSG_KEX_DH_GEX_REPLY,
-            common.NS(self.proto.factory.publicKeys['ssh-rsa']) +
-            f + common.NS(keys.signData(
-                self.proto.factory.privateKeys['ssh-rsa'],
-                exchangeHash))),
-            (transport.MSG_NEWKEYS, '')])
+        self.assertEquals(
+            self.packets[1:],
+            [(transport.MSG_KEX_DH_GEX_REPLY,
+              common.NS(self.proto.factory.publicKeys['ssh-rsa']) +
+              f + common.NS(keys.signData(
+                            self.proto.factory.privateKeys['ssh-rsa'],
+                            exchangeHash))),
+             (transport.MSG_NEWKEYS, '')])
 
     def test_keySetup(self):
         """
@@ -951,9 +981,10 @@
         self.assertEquals(self.proto.sessionID, 'CD')
         self.assertEquals(self.packets[-1], (transport.MSG_NEWKEYS, ''))
         newKeys = [self.proto._getKey(c, 'AB', 'EF') for c in 'ABCDEF']
-        self.assertEquals(self.proto.nextEncryptions.keys,
-                (newKeys[1], newKeys[3], newKeys[0], newKeys[2], newKeys[5],
-                    newKeys[4]))
+        self.assertEquals(
+            self.proto.nextEncryptions.keys,
+            (newKeys[1], newKeys[3], newKeys[0], newKeys[2], newKeys[5],
+             newKeys[4]))
 
     def test_NEWKEYS(self):
         """
@@ -962,10 +993,10 @@
         self.test_KEXINIT()
 
         self.proto.nextEncryptions = transport.SSHCiphers('none', 'none',
-                'none', 'none')
+                                                          'none', 'none')
         self.proto.ssh_NEWKEYS('')
         self.assertIdentical(self.proto.currentEncryptions,
-                self.proto.nextEncryptions)
+                             self.proto.nextEncryptions)
         self.assertIdentical(self.proto.outgoingCompression, None)
         self.assertIdentical(self.proto.incomingCompression, None)
         self.proto.outgoingCompressionType = 'zlib'
@@ -981,7 +1012,7 @@
         """
         self.proto.ssh_SERVICE_REQUEST(common.NS('ssh-userauth'))
         self.assertEquals(self.packets, [(transport.MSG_SERVICE_ACCEPT,
-            common.NS('ssh-userauth'))])
+                                          common.NS('ssh-userauth'))])
 
     def test_disconnectNEWKEYSData(self):
         self.proto.ssh_NEWKEYS("bad packet")
@@ -998,14 +1029,14 @@
     def verifyHostKey(self, pubKey, fingerprint):
         self.assertEquals(pubKey, self.blob)
         self.assertEquals(fingerprint.replace(':',''),
-                md5.new(pubKey).hexdigest())
+                          md5.new(pubKey).hexdigest())
         return defer.succeed(True)
 
     def setUp(self):
         TransportTestCase.setUp(self)
         self.blob = keys.getPublicKeyString(data=test_keys.publicRSA_openssh)
         self.privObj = keys.getPrivateKeyObject(
-                data=test_keys.privateRSA_openssh)
+            data=test_keys.privateRSA_openssh)
         self.proto.verifyHostKey = self.verifyHostKey
 
     def test_KEXINIT_groupexchange(self):
@@ -1013,11 +1044,11 @@
         Test that a KEXINIT packet with a group-exchange key exchange is
         continued correctly.
         """
-        self.proto.supportedKeyExchanges = \
-                ['diffie-hellman-group-exchange-sha1']
+        self.proto.supportedKeyExchanges = [
+            'diffie-hellman-group-exchange-sha1']
         self.proto.dataReceived(self.transport.value())
         self.assertEquals(self.packets, [(transport.MSG_KEXDH_INIT,
-            '\x00\x00\x08\x00')])
+                                          '\x00\x00\x08\x00')])
 
     def test_KEXINIT_group1(self):
         """
@@ -1025,9 +1056,10 @@
         """
         self.proto.supportedKeyExchanges = ['diffie-hellman-group1-sha1']
         self.proto.dataReceived(self.transport.value())
-        self.assertEquals(common.MP(self.proto.x)[5:], '\x99'*64)
-        self.assertEquals(self.packets, [(transport.MSG_KEX_DH_GEX_REQUEST_OLD,
-            self.proto.e)])
+        self.assertEquals(common.MP(self.proto.x)[5:], '\x99' * 64)
+        self.assertEquals(self.packets,
+                          [(transport.MSG_KEX_DH_GEX_REQUEST_OLD,
+                            self.proto.e)])
 
     def test_KEXDH_REPLY(self):
         """
@@ -1036,7 +1068,7 @@
         self.test_KEXINIT_group1()
 
         sharedSecret = common._MPpow(transport.DH_GENERATOR,
-            self.proto.x, transport.DH_PRIME)
+                                     self.proto.x, transport.DH_PRIME)
         h = sha.new()
         h.update(common.NS(self.proto.ourVersionString)*2)
         h.update(common.NS(self.proto.ourKexInitPayload)*2)
@@ -1053,8 +1085,8 @@
         signature = keys.signData(self.privObj, exchangeHash)
 
         d = self.proto.ssh_KEX_DH_GEX_GROUP(
-                (common.NS(self.blob) + '\x00\x00\x00\x01\x02' +
-                    common.NS(signature)))
+            (common.NS(self.blob) + '\x00\x00\x00\x01\x02' +
+             common.NS(signature)))
         d.addCallback(_cbTestKEXDH_REPLY)
         return d
 
@@ -1064,14 +1096,14 @@
         """
         self.test_KEXINIT_groupexchange()
         self.proto.ssh_KEX_DH_GEX_GROUP(
-                '\x00\x00\x00\x01\x0f\x00\x00\x00\x01\x02')
+            '\x00\x00\x00\x01\x0f\x00\x00\x00\x01\x02')
         self.assertEquals(self.proto.p, 15)
         self.assertEquals(self.proto.g, 2)
         self.assertEquals(common.MP(self.proto.x)[5:], '\x99'*40)
         self.assertEquals(self.proto.e,
-                common.MP(pow(2, self.proto.x, 15)))
+                          common.MP(pow(2, self.proto.x, 15)))
         self.assertEquals(self.packets[1:], [(transport.MSG_KEX_DH_GEX_INIT,
-            self.proto.e)])
+                                              self.proto.e)])
 
     def test_KEX_DH_GEX_REPLY(self):
         """
@@ -1081,8 +1113,8 @@
         self.test_KEX_DH_GEX_GROUP()
         sharedSecret = common._MPpow(3, self.proto.x, self.proto.p)
         h = sha.new()
-        h.update(common.NS(self.proto.ourVersionString)*2)
-        h.update(common.NS(self.proto.ourKexInitPayload)*2)
+        h.update(common.NS(self.proto.ourVersionString) * 2)
+        h.update(common.NS(self.proto.ourKexInitPayload) * 2)
         h.update(common.NS(self.blob))
         h.update('\x00\x00\x08\x00\x00\x00\x00\x01\x0f\x00\x00\x00\x01\x02')
         h.update(self.proto.e)
@@ -1096,8 +1128,10 @@
 
         signature = keys.signData(self.privObj, exchangeHash)
 
-        d = self.proto.ssh_KEX_DH_GEX_REPLY(common.NS(self.blob)
-                + '\x00\x00\x00\x01\x03' + common.NS(signature))
+        d = self.proto.ssh_KEX_DH_GEX_REPLY(
+            common.NS(self.blob) +
+            '\x00\x00\x00\x01\x03' +
+            common.NS(signature))
         d.addCallback(_cbTestKEX_DH_GEX_REPLY)
         return d
 
@@ -1115,8 +1149,8 @@
         self.assertEquals(self.packets[-1], (transport.MSG_NEWKEYS, ''))
         newKeys = [self.proto._getKey(c, 'AB', 'EF') for c in 'ABCDEF']
         self.assertEquals(self.proto.nextEncryptions.keys,
-                (newKeys[0], newKeys[2], newKeys[1], newKeys[3],
-                    newKeys[4], newKeys[5]))
+                          (newKeys[0], newKeys[2], newKeys[1], newKeys[3],
+                           newKeys[4], newKeys[5]))
 
     def test_NEWKEYS(self):
         """
@@ -1129,18 +1163,18 @@
         self.proto.connectionSecure = _
 
         self.proto.nextEncryptions = transport.SSHCiphers('none', 'none',
-                'none', 'none')
+                                                          'none', 'none')
         self.proto.ssh_NEWKEYS('')
 
         self.failIfIdentical(self.proto.currentEncryptions,
-                self.proto.nextEncryptions)
+                             self.proto.nextEncryptions)
 
         self.proto.nextEncryptions = TestCipher()
         self.proto._keySetup('AB', 'EF')
         self.assertIdentical(self.proto.outgoingCompression, None)
         self.assertIdentical(self.proto.incomingCompression, None)
         self.assertIdentical(self.proto.currentEncryptions,
-                self.proto.nextEncryptions)
+                             self.proto.nextEncryptions)
         self.assertTrue(secure[0])
         self.proto.outgoingCompressionType = 'zlib'
         self.proto.ssh_NEWKEYS('')
@@ -1163,7 +1197,7 @@
         """
         self.proto.requestService(TestService())
         self.assertEquals(self.packets, [(transport.MSG_SERVICE_REQUEST,
-            '\x00\x00\x00\x0bTestService')])
+                                          '\x00\x00\x00\x0bTestService')])
 
 
     def test_disconnectKEXDH_REPLYBadSignature(self):
@@ -1218,7 +1252,7 @@
         Test that the _getCipher method returns the correct cipher.
         """
         ciphers = transport.SSHCiphers('A','B','C','D')
-        iv = key = '\x00'*16
+        iv = key = '\x00' * 16
         for cipName, (modName, keySize, counter) in ciphers.cipherMap.items():
             cip = ciphers._getCipher(cipName, iv, key)
             if cipName == 'none':
@@ -1231,7 +1265,7 @@
         Test that the _getMAC method returns the correct MAC.
         """
         ciphers = transport.SSHCiphers('A', 'B', 'C', 'D')
-        key = '\x00'*64
+        key = '\x00' * 64
         for macName, mac in ciphers.macMap.items():
             mod = ciphers._getMAC(macName, key)
             if macName == 'none':
@@ -1239,9 +1273,9 @@
             else:
                 self.assertEquals(mod[0], mac)
                 self.assertEquals(mod[1],
-                        Crypto.Cipher.XOR.new('\x36').encrypt(key))
+                                  Crypto.Cipher.XOR.new('\x36').encrypt(key))
                 self.assertEquals(mod[2],
-                        Crypto.Cipher.XOR.new('\x5c').encrypt(key))
+                                  Crypto.Cipher.XOR.new('\x5c').encrypt(key))
                 self.assertEquals(mod[3], len(mod[0].new().digest()))
 
     def test_setKeysCiphers(self):
@@ -1249,8 +1283,8 @@
         Test that setKeys properly sets up the ciphers.
         """
         key = '\x00' * 64
-        for cipName, (modName,
-                keySize, counter) in transport.SSHCiphers.cipherMap.items():
+        cipherItems = transport.SSHCiphers.cipherMap.items()
+        for cipName, (modName, keySize, counter) in cipherItems:
             encCipher = transport.SSHCiphers(cipName, 'none', 'none', 'none')
             decCipher = transport.SSHCiphers('none', cipName, 'none', 'none')
             cip = encCipher._getCipher(cipName, key, key)
@@ -1287,7 +1321,7 @@
                 mod, i, o, ds = outMac._getMAC(macName, key)
             seqid = 0
             data = key
-            packet = '\x00'*4 + key
+            packet = '\x00' * 4 + key
             if mod:
                 mac = mod.new(o+mod.new(i+packet).digest()).digest()
             else:
@@ -1304,9 +1338,9 @@
         """
         Test that the counter is initialized correctly.
         """
-        counter = transport._Counter('\x00'*8+'\xff'*8, 8)
+        counter = transport._Counter('\x00' * 8 + '\xff' * 8, 8)
         self.assertEquals(counter.blockSize, 8)
-        self.assertEquals(counter.count.tostring(), '\x00'*8)
+        self.assertEquals(counter.count.tostring(), '\x00' * 8)
 
     def test_count(self):
         """
@@ -1339,24 +1373,24 @@
         factory.startFactory()
         server.errors = []
         server.receiveError = lambda code, desc: server.errors.append((
-            code, desc))
+                code, desc))
         client = transport.SSHClientTransport()
         client.verifyHostKey = lambda x,y: defer.succeed(None)
         client.errors = []
         client.receiveError = lambda code, desc: client.errors.append((
-            code, desc))
+                code, desc))
         client.connectionSecure = lambda: client.loseConnection()
         server = mod(server)
         client = mod(client)
         def check(ignored, server, client):
             name = repr([server.supportedCiphers[0],
-                server.supportedMACs[0],
-                server.supportedKeyExchanges[0],
-                server.supportedCompressions[0]])
+                         server.supportedMACs[0],
+                         server.supportedKeyExchanges[0],
+                         server.supportedCompressions[0]])
             self.assertEquals(client.errors, [])
             self.assertEquals(server.errors, [(
-                transport.DISCONNECT_CONNECTION_LOST,
-                "user closed connection")])
+                        transport.DISCONNECT_CONNECTION_LOST,
+                        "user closed connection")])
             if server.supportedCiphers[0] == 'none':
                 self.assertFalse(server.isEncrypted(), name)
                 self.assertFalse(client.isEncrypted(), name)
@@ -1370,8 +1404,9 @@
                 self.assertTrue(server.isVerified(), name)
                 self.assertTrue(client.isVerified(), name)
 
-        return loopback.loopbackAsync(server, client).addCallback(check,
-                server, client)
+        d = loopback.loopbackAsync(server, client)
+        d.addCallback(check, server, client)
+        return d
 
     def test_ciphers(self):
         """
Index: twisted/conch/ssh/transport.py
===================================================================
--- twisted/conch/ssh/transport.py	(revision 20596)
+++ twisted/conch/ssh/transport.py	(working copy)
@@ -3,17 +3,15 @@
 # Copyright (c) 2001-2004 Twisted Matrix Laboratories.
 # See LICENSE for details.
 
-# 
+"""
+The lowest level SSH protocol.  This handles the key negotiation, the
+encryption and the compression.
 
-"""The lowest level SSH protocol.  This handles the key negotiation, the encryption and the compression.
-
 This module is unstable.
 
 Maintainer: U{Paul Swartz<mailto:z3p@twistedmatrix.com>}
 """
 
-from __future__ import nested_scopes
-
 # base library imports
 import struct
 import md5
@@ -26,13 +24,12 @@
 from Crypto.Cipher import XOR
 
 # twisted imports
+from twisted.python import log
+from twisted.internet import protocol, defer
 from twisted.conch import error
-from twisted.internet import protocol, defer
-from twisted.python import log
+from twisted.conch.ssh import keys
+from twisted.conch.ssh.common import NS, getNS, MP, getMP, _MPpow, ffs, entropy
 
-# sibling importsa
-from common import NS, getNS, MP, getMP, _MPpow, ffs, entropy # ease of use
-import keys
 
 
 class SSHTransportBase(protocol.Protocol):
@@ -108,7 +105,7 @@
         log.msg('connection lost')
 
     def connectionMade(self):
-        self.transport.write('%s\r\n'%(self.ourVersionString))
+        self.transport.write('%s\r\n' % (self.ourVersionString,))
         self.currentEncryptions = SSHCiphers('none', 'none', 'none', 'none')
         self.currentEncryptions.setKeys('', '', '', '', '', '')
         self.sendKexInit()
@@ -142,20 +139,22 @@
         payload = chr(messageType)+payload
         if self.outgoingCompression:
             payload = (self.outgoingCompression.compress(payload)
-                        + self.outgoingCompression.flush(2))
+                       + self.outgoingCompression.flush(2))
         bs = self.currentEncryptions.encBlockSize
-        totalSize = 5 + len(payload)  # 4 for the packet length and 1 for the
-                                    # padding length
-        lenPad = bs - (totalSize%bs)
+        # 4 for the packet length and 1 for the padding length
+        totalSize = 5 + len(payload)
+        lenPad = bs - (totalSize % bs)
         if lenPad < 4:
             lenPad = lenPad+bs
-        packet = (struct.pack('!LB', totalSize + lenPad - 4, lenPad) +
-                    payload + entropy.get_bytes(lenPad))
-        assert len(packet) % bs == 0, '%s extra bytes in packet'%(len(packet)
-                % bs)
-        encPacket = (self.currentEncryptions.encrypt(packet) +
-                        self.currentEncryptions.makeMAC(
-                                        self.outgoingPacketSequence, packet))
+        packet = (struct.pack('!LB',
+                              totalSize + lenPad - 4, lenPad) +
+                  payload + entropy.get_bytes(lenPad))
+        assert len(packet) % bs == 0, '%s extra bytes in packet' % (
+            len(packet) % bs)
+        encPacket = (
+            self.currentEncryptions.encrypt(packet) +
+            self.currentEncryptions.makeMAC(
+                self.outgoingPacketSequence, packet))
         self.transport.write(encPacket)
         self.outgoingPacketSequence += 1
 
@@ -177,26 +176,27 @@
         packetLen, paddingLen = struct.unpack('!LB', first[:5])
         if packetLen > 1048576: # 1024 ** 2
             self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR,
-                    'bad packet length %s' % packetLen)
+                                'bad packet length %s' % packetLen)
             return
         if len(self.buf) < packetLen + 4 + ms:
             self.first = first
             return # not enough packet
         if(packetLen + 4) % bs != 0:
-            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR,
-                    'bad packet mod (%i%%%i == %i)' % (packetLen + 4, bs,
-                        (packetLen + 4) % bs))
+            self.sendDisconnect(
+                DISCONNECT_PROTOCOL_ERROR,
+                'bad packet mod (%i%%%i == %i)' % (packetLen + 4, bs,
+                                                   (packetLen + 4) % bs))
             return
         encData, self.buf = self.buf[:4+packetLen], self.buf[4+packetLen:]
         packet = first + self.currentEncryptions.decrypt(encData[bs:])
         if len(packet) != 4 + packetLen:
             self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR,
-                              'bad decryption')
+                                'bad decryption')
             return
         if ms:
-            macData, self.buf = self.buf[:ms],  self.buf[ms:]
+            macData, self.buf = self.buf[:ms], self.buf[ms:]
             if not self.currentEncryptions.verify(self.incomingPacketSequence,
-                    packet, macData):
+                                                  packet, macData):
                 self.sendDisconnect(DISCONNECT_MAC_ERROR, 'bad MAC')
                 return
         payload = packet[5:-paddingLen]
@@ -206,7 +206,7 @@
             except: # bare except, because who knows what kind of errors
                     # decompression can raise
                 self.sendDisconnect(DISCONNECT_COMPRESSION_ERROR,
-                        'compression error')
+                                    'compression error')
                 return
         self.incomingPacketSequence += 1
         return payload
@@ -230,8 +230,8 @@
                     self.otherVersionString = p.strip()
                     if p.split('-')[1] not in ('1.99', '2.0'): # bad version
                         self.sendDisconnect(
-                                DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED,
-                                'bad version ' + p.split('-')[1])
+                            DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED,
+                            'bad version ' + p.split('-')[1])
                         return
                     i = lines.index(p)
                     self.buf = '\n'.join(lines[i+1:])
@@ -259,7 +259,7 @@
                 self.sendUnimplemented()
         elif self.service:
             log.callWithLogger(self.service, self.service.packetReceived,
-                                             messageNum, payload)
+                               messageNum, payload)
         else:
             log.msg("couldn't handle %s" % messageNum)
             log.msg(repr(payload))
@@ -289,7 +289,7 @@
         k = getNS(packet[16:], 10)
         strings, rest = k[:-1], k[-1]
         (kexAlgs, keyAlgs, encCS, encSC, macCS, macSC, compCS, compSC, langCS,
-            langSC) = [s.split(',')for s in strings]
+         langSC) = [s.split(',') for s in strings]
         self.kexAlg = ffs(kexAlgs, self.supportedKeyExchanges)
         self.keyAlg = ffs(keyAlgs, self.supportedPublicKeys)
         # these are the server directions
@@ -304,17 +304,17 @@
             ffs(outs[1], self.supportedMACs),
             ffs(ins[1], self.supportedMACs))
         self.outgoingCompressionType = ffs(outs[2],
-                self.supportedCompressions)
+                                           self.supportedCompressions)
         self.incomingCompressionType = ffs(ins[2],
-                self.supportedCompressions)
+                                           self.supportedCompressions)
         if None in (self.kexAlg, self.keyAlg, self.outgoingCompressionType,
-                self.incomingCompressionType):
+                    self.incomingCompressionType):
             self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED,
-                    "couldn't match all kex parts")
+                                "couldn't match all kex parts")
             return
         if None in self.nextEncryptions.__dict__.values():
             self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED,
-                    "couldn't match all kex parts")
+                                "couldn't match all kex parts")
             return
         log.msg('kex alg, key alg: %s %s' % (self.kexAlg, self.keyAlg))
         log.msg('outgoing: %s %s %s' % (self.nextEncryptions.outCipType,
@@ -372,7 +372,7 @@
 
         @type service: C{SSHService}
         """
-        log.msg('starting service %s'%service.name)
+        log.msg('starting service %s' % service.name)
         if self.service:
             self.service.serviceStopped()
         self.service = service
@@ -392,7 +392,7 @@
         @type lang: C{str}
         """
         self.sendPacket(MSG_DEBUG, chr(alwaysDisplay) + NS(message) +
-                NS(language))
+                        NS(language))
 
     def sendIgnore(self, message):
         """
@@ -423,9 +423,10 @@
         @param desc: a descrption of the reason for the disconnection.
         @type desc: C{str}
         """
-        self.sendPacket(MSG_DISCONNECT, struct.pack('>L',
-            reason) + NS(desc) + NS(''))
-        log.msg('Disconnecting with error, code %s\nreason: %s'%(reason, desc))
+        self.sendPacket(
+            MSG_DISCONNECT, struct.pack('>L', reason) + NS(desc) + NS(''))
+        log.msg('Disconnecting with error, code %s\nreason: %s' % (reason,
+                                                                   desc))
         self.transport.loseConnection()
 
     def _getKey(self, c, sharedSecret, exchangeHash):
@@ -466,10 +467,10 @@
         if self.isClient: # reverse for the client
             outs, ins = ins, outs
         self.nextEncryptions.setKeys(outs[0], outs[1], ins[0], ins[1],
-                outs[2], ins[2])
+                                     outs[2], ins[2])
         self.sendPacket(MSG_NEWKEYS, '')
 
-    def isEncrypted(self, direction = "out"):
+    def isEncrypted(self, direction="out"):
         """
         Return True if the connection is encrypted in the given direction.
         Direction must be one of ["out", "in", "both"].
@@ -481,9 +482,9 @@
         elif direction == "both":
             return self.isEncrypted("in") and self.isEncrypted("out")
         else:
-            raise TypeError, 'direction must be "out", "in", or "both"'
+            raise TypeError('direction must be "out", "in", or "both"')
 
-    def isVerified(self, direction = "out"):
+    def isVerified(self, direction="out"):
         """
         Return True if the connecction is verified/authenticated in the
         given direction.  Direction must be one of ["out", "in", "both"].
@@ -495,7 +496,7 @@
         elif direction == "both":
             return self.isVerified("in")and self.isVerified("out")
         else:
-            raise TypeError, 'direction must be "out", "in", or "both"'
+            raise TypeError('direction must be "out", "in", or "both"')
 
     def loseConnection(self):
         """
@@ -503,7 +504,7 @@
         DISCONNECT_CONNECTION_LOST message.
         """
         self.sendDisconnect(DISCONNECT_CONNECTION_LOST,
-                "user closed connection")
+                            "user closed connection")
 
     # client methods
     def receiveError(self, reasonCode, description):
@@ -519,7 +520,7 @@
         @type description: C{str}
         """
         log.msg('Got remote error, code %s\nreason: %s' % (reasonCode,
-            description))
+                                                           description))
 
     def receiveUnimplemented(self, seqnum):
         """
@@ -529,7 +530,7 @@
         @param seqnum: the sequence number that was not understood.
         @type seqnum: C{int}
         """
-        log.msg('other side unimplemented packet #%s'%seqnum)
+        log.msg('other side unimplemented packet #%s' % seqnum)
 
     def receiveDebug(self, alwaysDisplay, message, lang):
         """
@@ -571,7 +572,7 @@
             kexAlgs, keyAlgs, rest = retval
         if ord(rest[0]): # first_kex_packet_follows
             if (kexAlgs[0] != self.supportedKeyExchanges[0] or
-                    keyAlgs[0] != self.supportedPublicKeys[0]):
+                keyAlgs[0] != self.supportedPublicKeys[0]):
                 self.ignoreNextPacket = True # guess was wrong
 
     def ssh_KEX_DH_GEX_REQUEST_OLD(self, packet):
@@ -609,10 +610,12 @@
             h.update(serverDHpublicKey)
             h.update(sharedSecret)
             exchangeHash = h.digest()
-            self.sendPacket(MSG_KEXDH_REPLY,
-                    NS(self.factory.publicKeys[self.keyAlg]) +
-                    serverDHpublicKey + NS(keys.signData(
-                        self.factory.privateKeys[self.keyAlg], exchangeHash)))
+            self.sendPacket(
+                MSG_KEXDH_REPLY,
+                NS(self.factory.publicKeys[self.keyAlg]) +
+                serverDHpublicKey +
+                NS(keys.signData(self.factory.privateKeys[self.keyAlg],
+                                 exchangeHash)))
             self._keySetup(sharedSecret, exchangeHash)
         elif self.kexAlg == 'diffie-hellman-group-exchange-sha1':
             self.dhGexRequest = packet
@@ -620,7 +623,7 @@
             self.g, self.p = self.factory.getDHPrime(self.ideal)
             self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p)+MP(self.g))
         else:
-            raise error.ConchError('bad kexalg: %s'%self.kexAlg)
+            raise error.ConchError('bad kexalg: %s' % self.kexAlg)
 
     def ssh_KEX_DH_GEX_REQUEST(self, packet):
         """
@@ -640,7 +643,7 @@
         self.dhGexRequest = packet
         self.min, self.ideal, self.max = struct.unpack('>3L', packet)
         self.g, self.p = self.factory.getDHPrime(self.ideal)
-        self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p)+MP(self.g))
+        self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p) + MP(self.g))
 
     def ssh_KEX_DH_GEX_INIT(self, packet):
         """
@@ -675,10 +678,12 @@
         h.update(serverDHpublicKey)
         h.update(sharedSecret)
         exchangeHash = h.digest()
-        self.sendPacket(MSG_KEX_DH_GEX_REPLY,
-                NS(self.factory.publicKeys[self.keyAlg]) + serverDHpublicKey
-                + NS(keys.signData(self.factory.privateKeys[self.keyAlg],
-                        exchangeHash)))
+        self.sendPacket(
+            MSG_KEX_DH_GEX_REPLY,
+            NS(self.factory.publicKeys[self.keyAlg]) +
+            serverDHpublicKey +
+            NS(keys.signData(self.factory.privateKeys[self.keyAlg],
+                             exchangeHash)))
         self._keySetup(sharedSecret, exchangeHash)
 
     def ssh_NEWKEYS(self, packet):
@@ -689,7 +694,7 @@
         """
         if packet != '':
             self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR,
-                    "NEWKEYS takes no data")
+                                "NEWKEYS takes no data")
             return
         self.currentEncryptions = self.nextEncryptions
         if self.outgoingCompressionType == 'zlib':
@@ -709,7 +714,7 @@
         cls = self.factory.getService(self, service)
         if not cls:
             self.sendDisconnect(DISCONNECT_SERVICE_NOT_AVAILABLE,
-                    "don't have service %s"%service)
+                                "don't have service %s" % service)
             return
         else:
             self.sendPacket(MSG_SERVICE_ACCEPT, NS(service))
@@ -751,7 +756,7 @@
             self.sendPacket(MSG_KEX_DH_GEX_REQUEST_OLD, '\x00\x00\x08\x00')
         else:
             raise error.ConchError("somehow, the kexAlg has been set "
-                "to something we don't support")
+                                   "to something we don't support")
 
     def ssh_KEX_DH_GEX_GROUP(self, packet):
         """
@@ -763,7 +768,7 @@
             string signature
         We verify the host key by calling verifyHostKey, then continue in
         _continueKEXDH_REPLY.
-        
+
         If the key exchange is diffie-hellman-group-exchange-sha1, this is
         MSG_KEX_DH_GEX_GROUP.  Payload:
             string g (group generator)
@@ -780,9 +785,9 @@
                                     md5.new(pubKey).digest()])
             d = self.verifyHostKey(pubKey, fingerprint)
             d.addCallback(self._continueKEXDH_REPLY, pubKey, f, signature)
-            d.addErrback(lambda unused:
-                    self.sendDisconnect(DISCONNECT_HOST_KEY_NOT_VERIFIABLE,
-                        'bad host key'))
+            d.addErrback(
+                lambda unused: self.sendDisconnect(
+                    DISCONNECT_HOST_KEY_NOT_VERIFIABLE, 'bad host key'))
             return d
         else:
             self.p, rest = getMP(packet)
@@ -809,7 +814,7 @@
         exchangeHash = h.digest()
         if not keys.verifySignature(serverKey, signature, exchangeHash):
             self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED,
-                    'bad signature')
+                                'bad signature')
             return
         self._keySetup(sharedSecret, exchangeHash)
 
@@ -828,9 +833,9 @@
             md5.new(pubKey).digest()))
         d = self.verifyHostKey(pubKey, fingerprint)
         d.addCallback(self._continueGEX_REPLY, pubKey, f, signature)
-        d.addErrback(lambda unused:
-                self.sendDisconnect(DISCONNECT_HOST_KEY_NOT_VERIFIABLE,
-                    'bad host key'))
+        d.addErrback(
+            lambda unused: self.sendDisconnect(
+                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, 'bad host key'))
         return d
 
     def _continueGEX_REPLY(self, ignored, pubKey, f, signature):
@@ -851,7 +856,7 @@
         exchangeHash = h.digest()
         if not keys.verifySignature(serverKey, signature, exchangeHash):
             self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED,
-                    'bad signature')
+                                'bad signature')
             return
         self._keySetup(sharedSecret, exchangeHash)
 
@@ -871,7 +876,7 @@
         """
         if packet != '':
             self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR,
-                    "NEWKEYS takes no data")
+                                "NEWKEYS takes no data")
             return
         if not self.nextEncryptions.encBlockSize:
             self._gotNewKeys = 1
@@ -891,8 +896,9 @@
         """
         name = getNS(packet)[0]
         if name != self.instance.name:
-            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR,
-                    "received accept for service we did not request")
+            self.sendDisconnect(
+                DISCONNECT_PROTOCOL_ERROR,
+                "received accept for service we did not request")
         self.setService(self.instance)
 
     def requestService(self, instance):
@@ -914,12 +920,12 @@
         @type fingerprint:  C{str}
         @rtype:             L{Deferred}
         """
-        # return  if it's good
+        # return if it's good
         return defer.fail(NotImplementedError)
 
     def connectionSecure(self):
         """
-        Called when the encryption has been set up.  Generally, 
+        Called when the encryption has been set up.  Generally,
         requestService() is called to run another service over the transport.
         """
         raise NotImplementedError
@@ -930,7 +936,7 @@
 
     @ivar block_size
     """
-    block_size = 8 
+    block_size = 8
 
     def encrypt(self, x):
         return x
@@ -1014,14 +1020,14 @@
         mod = __import__('Crypto.Cipher.%s'%modName, {}, {}, 'x')
         if counterMode:
             return mod.new(key[:keySize], mod.MODE_CTR, iv[:mod.block_size],
-                    counter=_Counter(iv, mod.block_size))
+                           counter=_Counter(iv, mod.block_size))
         else:
-            return mod.new(key[: keySize], mod.MODE_CBC, iv[: mod.block_size])
+            return mod.new(key[:keySize], mod.MODE_CBC, iv[:mod.block_size])
 
     def _getMAC(self, mac, key):
         """
         Gets a 4-tuple representing the message authentication code:
-            (<hash module>, <inner hash value>, <outer hash value>, 
+            (<hash module>, <inner hash value>, <outer hash value>,
              <digest size>)
 
         @param mac: a key mapping into macMap
@@ -1034,10 +1040,10 @@
         #     ds = len(mod.new().digest())
         #else:
         ds = mod.digest_size
-        key = key[: ds]+'\x00'*(64-ds)
+        key = key[:ds] + '\x00' * (64 - ds)
         i = XOR.new('\x36').encrypt(key)
         o = XOR.new('\x5c').encrypt(key)
-        return mod, i,o, ds
+        return mod, i, o, ds
 
     def encrypt(self, blocks):
         """
@@ -1066,11 +1072,12 @@
         @type data: C{str}
         @rtype: C{str}
         """
-        if not self.outMAC[0]: return ''
-        data = struct.pack('>L', seqid)+data
+        if not self.outMAC[0]:
+            return ''
+        data = struct.pack('>L', seqid) + data
         mod, i, o, ds = self.outMAC
-        inner = mod.new(i+data)
-        outer = mod.new(o+inner.digest())
+        inner = mod.new(i + data)
+        outer = mod.new(o + inner.digest())
         return outer.digest()
 
     def verify(self, seqid, data, mac):
@@ -1089,9 +1096,9 @@
         if not self.inMAC[0]:
             return mac == ''
         data = struct.pack('>L', seqid)+data
-        mod, i,o, ds = self.inMAC
-        inner = mod.new(i+data)
-        outer = mod.new(o+inner.digest())
+        mod, i, o, ds = self.inMAC
+        inner = mod.new(i + data)
+        outer = mod.new(o + inner.digest())
         return mac == outer.digest()
 
 class _Counter:
@@ -1136,14 +1143,14 @@
 def buffer_dump(b, title = None):
     r = title or ''
     while b:
-        c, b = b[: 16], b[16:]
+        c, b = b[:16], b[16:]
         while c:
-            a, c = c[: 2], c[2:]
+            a, c = c[:2], c[2:]
             if len(a) == 2:
-                r = r+'%02x%02x '%(ord(a[0]), ord(a[1]))
+                r = r + '%02x%02x ' % (ord(a[0]), ord(a[1]))
             else:
-                r = r+'%02x'%ord(a[0])
-        r = r+'\n'
+                r = r + '%02x' % ord(a[0])
+        r = r + '\n'
     return r
 
 # Diffie-Hellman primes from Oakley Group 2 [RFC 2409]
@@ -1190,4 +1197,3 @@
 for name, value in globals().items():
     if name.startswith('MSG_'):
         messages[value] = name
-
