Index: twisted/protocols/sip.py
===================================================================
--- twisted/protocols/sip.py	(revision 29927)
+++ twisted/protocols/sip.py	(working copy)
@@ -94,7 +94,7 @@
     488: "Not Acceptable Here",
     491: "Request Pending",
     493: "Undecipherable",
-    
+
     500: "Internal Server Error",
     501: "Not Implemented",
     502: "Bad Gateway", # no donut
@@ -102,7 +102,7 @@
     504: "Server Time-out",
     505: "SIP Version not supported",
     513: "Message Too Large",
-    
+
     600: "Busy Everywhere",
     603: "Decline",
     604: "Does not exist anywhere",
@@ -110,8 +110,13 @@
 }
 
 #SIP symbolic error codes
+OK = 200
 BAD_REQUEST = 400
+UNAUTHORIZED = 401
+NOT_FOUND = 404
 UNSUPPORTED_URI = 416
+INTERNAL_SERVER_ERROR = 500
+NOT_IMPLEMENTED = 501
 
 specialCases = {
     'cseq': 'CSeq',
@@ -119,41 +124,41 @@
     'www-authenticate': 'WWW-Authenticate',
 }
 
-def dashCapitalize(s):
+def dashCapitalize( s ):
     ''' Capitalize a string, making sure to treat - as a word seperator '''
-    return '-'.join([ x.capitalize() for x in s.split('-')])
+    return '-'.join( [ x.capitalize() for x in s.split( '-' )] )
 
-def unq(s):
+def unq( s ):
     if s[0] == s[-1] == '"':
         return s[1:-1]
     return s
 
-def DigestCalcHA1(
+def DigestCalcHA1( 
     pszAlg,
     pszUserName,
     pszRealm,
     pszPassword,
     pszNonce,
     pszCNonce,
-):
+ ):
     m = md5()
-    m.update(pszUserName)
-    m.update(":")
-    m.update(pszRealm)
-    m.update(":")
-    m.update(pszPassword)
+    m.update( pszUserName )
+    m.update( ":" )
+    m.update( pszRealm )
+    m.update( ":" )
+    m.update( pszPassword )
     HA1 = m.digest()
     if pszAlg == "md5-sess":
         m = md5()
-        m.update(HA1)
-        m.update(":")
-        m.update(pszNonce)
-        m.update(":")
-        m.update(pszCNonce)
+        m.update( HA1 )
+        m.update( ":" )
+        m.update( pszNonce )
+        m.update( ":" )
+        m.update( pszCNonce )
         HA1 = m.digest()
-    return HA1.encode('hex')
+    return HA1.encode( 'hex' )
 
-def DigestCalcResponse(
+def DigestCalcResponse( 
     HA1,
     pszNonce,
     pszNonceCount,
@@ -162,37 +167,37 @@
     pszMethod,
     pszDigestUri,
     pszHEntity,
-):
+ ):
     m = md5()
-    m.update(pszMethod)
-    m.update(":")
-    m.update(pszDigestUri)
+    m.update( pszMethod )
+    m.update( ":" )
+    m.update( pszDigestUri )
     if pszQop == "auth-int":
-        m.update(":")
-        m.update(pszHEntity)
-    HA2 = m.digest().encode('hex')
-    
+        m.update( ":" )
+        m.update( pszHEntity )
+    HA2 = m.digest().encode( 'hex' )
+
     m = md5()
-    m.update(HA1)
-    m.update(":")
-    m.update(pszNonce)
-    m.update(":")
+    m.update( HA1 )
+    m.update( ":" )
+    m.update( pszNonce )
+    m.update( ":" )
     if pszNonceCount and pszCNonce: # pszQop:
-        m.update(pszNonceCount)
-        m.update(":")
-        m.update(pszCNonce)
-        m.update(":")
-        m.update(pszQop)
-        m.update(":")
-    m.update(HA2)
-    hash = m.digest().encode('hex')
+        m.update( pszNonceCount )
+        m.update( ":" )
+        m.update( pszCNonce )
+        m.update( ":" )
+        m.update( pszQop )
+        m.update( ":" )
+    m.update( HA2 )
+    hash = m.digest().encode( 'hex' )
     return hash
 
 class Via:
     """A SIP Via header."""
 
-    def __init__(self, host, port=PORT, transport="UDP", ttl=None, hidden=False,
-                 received=None, rport=None, branch=None, maddr=None):
+    def __init__( self, host, port=PORT, transport="UDP", ttl=None, hidden=False,
+                 received=None, rport=None, branch=None, maddr=None ):
         self.transport = transport
         self.host = host
         self.port = port
@@ -203,63 +208,63 @@
         self.branch = branch
         self.maddr = maddr
 
-    def toString(self):
-        s = "SIP/2.0/%s %s:%s" % (self.transport, self.host, self.port)
+    def toString( self ):
+        s = "SIP/2.0/%s %s:%s" % ( self.transport, self.host, self.port )
         if self.hidden:
             s += ";hidden"
         for n in "ttl", "branch", "maddr", "received", "rport":
-            value = getattr(self, n)
+            value = getattr( self, n )
             if value == True:
                 s += ";" + n
             elif value != None:
-                s += ";%s=%s" % (n, value)
+                s += ";%s=%s" % ( n, value )
         return s
 
 
-def parseViaHeader(value):
+def parseViaHeader( value ):
     """Parse a Via header, returning Via class instance."""
-    parts = value.split(";")
+    parts = value.split( ";" )
     sent, params = parts[0], parts[1:]
-    protocolinfo, by = sent.split(" ", 1)
+    protocolinfo, by = sent.split( " ", 1 )
     by = by.strip()
     result = {}
-    pname, pversion, transport = protocolinfo.split("/")
+    pname, pversion, transport = protocolinfo.split( "/" )
     if pname != "SIP" or pversion != "2.0":
         raise ValueError, "wrong protocol or version: %r" % value
     result["transport"] = transport
     if ":" in by:
-        host, port = by.split(":")
-        result["port"] = int(port)
+        host, port = by.split( ":" )
+        result["port"] = int( port )
         result["host"] = host
     else:
         result["host"] = by
     for p in params:
         # it's the comment-striping dance!
-        p = p.strip().split(" ", 1)
-        if len(p) == 1:
+        p = p.strip().split( " ", 1 )
+        if len( p ) == 1:
             p, comment = p[0], ""
         else:
             p, comment = p
         if p == "hidden":
             result["hidden"] = True
             continue
-        parts = p.split("=", 1)
-        if len(parts) == 1:
+        parts = p.split( "=", 1 )
+        if len( parts ) == 1:
             name, value = parts[0], True
         else:
             name, value = parts
-            if name in ("rport", "ttl"):
-                value = int(value)
+            if name in ( "rport", "ttl" ):
+                value = int( value )
         result[name] = value
-    return Via(**result)
+    return Via( **result )
 
 
 class URL:
     """A SIP URL."""
 
-    def __init__(self, host, username=None, password=None, port=None,
+    def __init__( self, host, username=None, password=None, port=None,
                  transport=None, usertype=None, method=None,
-                 ttl=None, maddr=None, tag=None, other=None, headers=None):
+                 ttl=None, maddr=None, tag=None, other=None, headers=None ):
         self.username = username
         self.host = host
         self.password = password
@@ -279,64 +284,64 @@
         else:
             self.headers = headers
 
-    def toString(self):
+    def toString( self ):
         l = []; w = l.append
-        w("sip:")
+        w( "sip:" )
         if self.username != None:
-            w(self.username)
+            w( self.username )
             if self.password != None:
-                w(":%s" % self.password)
-            w("@")
-        w(self.host)
+                w( ":%s" % self.password )
+            w( "@" )
+        w( self.host )
         if self.port != None:
-            w(":%d" % self.port)
+            w( ":%d" % self.port )
         if self.usertype != None:
-            w(";user=%s" % self.usertype)
-        for n in ("transport", "ttl", "maddr", "method", "tag"):
-            v = getattr(self, n)
+            w( ";user=%s" % self.usertype )
+        for n in ( "transport", "ttl", "maddr", "method", "tag" ):
+            v = getattr( self, n )
             if v != None:
-                w(";%s=%s" % (n, v))
+                w( ";%s=%s" % ( n, v ) )
         for v in self.other:
-            w(";%s" % v)
+            w( ";%s" % v )
         if self.headers:
-            w("?")
-            w("&".join([("%s=%s" % (specialCases.get(h) or dashCapitalize(h), v)) for (h, v) in self.headers.items()]))
-        return "".join(l)
+            w( "?" )
+            w( "&".join( [( "%s=%s" % ( specialCases.get( h ) or dashCapitalize( h ), v ) ) for ( h, v ) in self.headers.items()] ) )
+        return "".join( l )
 
-    def __str__(self):
+    def __str__( self ):
         return self.toString()
-    
-    def __repr__(self):
-        return '<URL %s:%s@%s:%r/%s>' % (self.username, self.password, self.host, self.port, self.transport)
 
+    def __repr__( self ):
+        return '<URL %s:%s@%s:%r/%s>' % ( self.username, self.password, self.host, self.port, self.transport )
 
-def parseURL(url, host=None, port=None):
+
+def parseURL( url, host=None, port=None ):
     """Return string into URL object.
 
     URIs are of of form 'sip:user@example.com'.
     """
     d = {}
-    if not url.startswith("sip:"):
-        raise ValueError("unsupported scheme: " + url[:4])
-    parts = url[4:].split(";")
+    if not url.startswith( "sip:" ):
+        raise ValueError( "unsupported scheme: " + url[:4] )
+    parts = url[4:].split( ";" )
     userdomain, params = parts[0], parts[1:]
-    udparts = userdomain.split("@", 1)
-    if len(udparts) == 2:
+    udparts = userdomain.split( "@", 1 )
+    if len( udparts ) == 2:
         userpass, hostport = udparts
-        upparts = userpass.split(":", 1)
-        if len(upparts) == 1:
+        upparts = userpass.split( ":", 1 )
+        if len( upparts ) == 1:
             d["username"] = upparts[0]
         else:
             d["username"] = upparts[0]
             d["password"] = upparts[1]
     else:
         hostport = udparts[0]
-    hpparts = hostport.split(":", 1)
-    if len(hpparts) == 1:
+    hpparts = hostport.split( ":", 1 )
+    if len( hpparts ) == 1:
         d["host"] = hpparts[0]
     else:
         d["host"] = hpparts[0]
-        d["port"] = int(hpparts[1])
+        d["port"] = int( hpparts[1] )
     if host != None:
         d["host"] = host
     if port != None:
@@ -344,27 +349,27 @@
     for p in params:
         if p == params[-1] and "?" in p:
             d["headers"] = h = {}
-            p, headers = p.split("?", 1)
-            for header in headers.split("&"):
-                k, v = header.split("=")
+            p, headers = p.split( "?", 1 )
+            for header in headers.split( "&" ):
+                k, v = header.split( "=" )
                 h[k] = v
-        nv = p.split("=", 1)
-        if len(nv) == 1:
-            d.setdefault("other", []).append(p)
+        nv = p.split( "=", 1 )
+        if len( nv ) == 1:
+            d.setdefault( "other", [] ).append( p )
             continue
         name, value = nv
         if name == "user":
             d["usertype"] = value
-        elif name in ("transport", "ttl", "maddr", "method", "tag"):
+        elif name in ( "transport", "ttl", "maddr", "method", "tag" ):
             if name == "ttl":
-                value = int(value)
+                value = int( value )
             d[name] = value
         else:
-            d.setdefault("other", []).append(p)
-    return URL(**d)
+            d.setdefault( "other", [] ).append( p )
+    return URL( **d )
 
 
-def cleanRequestURL(url):
+def cleanRequestURL( url ):
     """Clean a URL from a Request line."""
     url.transport = None
     url.maddr = None
@@ -372,30 +377,30 @@
     url.headers = {}
 
 
-def parseAddress(address, host=None, port=None, clean=0):
+def parseAddress( address, host=None, port=None, clean=0 ):
     """Return (name, uri, params) for From/To/Contact header.
 
     @param clean: remove unnecessary info, usually for From and To headers.
     """
     address = address.strip()
     # simple 'sip:foo' case
-    if address.startswith("sip:"):
-        return "", parseURL(address, host=host, port=port), {}
+    if address.startswith( "sip:" ):
+        return "", parseURL( address, host=host, port=port ), {}
     params = {}
-    name, url = address.split("<", 1)
+    name, url = address.split( "<", 1 )
     name = name.strip()
-    if name.startswith('"'):
+    if name.startswith( '"' ):
         name = name[1:]
-    if name.endswith('"'):
+    if name.endswith( '"' ):
         name = name[:-1]
-    url, paramstring = url.split(">", 1)
-    url = parseURL(url, host=host, port=port)
+    url, paramstring = url.split( ">", 1 )
+    url = parseURL( url, host=host, port=port )
     paramstring = paramstring.strip()
     if paramstring:
-        for l in paramstring.split(";"):
+        for l in paramstring.split( ";" ):
             if not l:
                 continue
-            k, v = l.split("=")
+            k, v = l.split( "=" )
             params[k] = v
     if clean:
         # rfc 2543 6.21
@@ -406,16 +411,16 @@
     return name, url, params
 
 
-class SIPError(Exception):
-    def __init__(self, code, phrase=None):
+class SIPError( Exception ):
+    def __init__( self, code, phrase=None ):
         if phrase is None:
             phrase = statusCodes[code]
-        Exception.__init__(self, "SIP error (%d): %s" % (code, phrase))
+        Exception.__init__( self, "SIP error (%d): %s" % ( code, phrase ) )
         self.code = code
         self.phrase = phrase
 
 
-class RegistrationError(SIPError):
+class RegistrationError( SIPError ):
     """Registration was not possible."""
 
 
@@ -423,78 +428,78 @@
     """A SIP message."""
 
     length = None
-    
-    def __init__(self):
+
+    def __init__( self ):
         self.headers = util.OrderedDict() # map name to list of values
         self.body = ""
         self.finished = 0
-    
-    def addHeader(self, name, value):
+
+    def addHeader( self, name, value ):
         name = name.lower()
-        name = longHeaders.get(name, name)
+        name = longHeaders.get( name, name )
         if name == "content-length":
-            self.length = int(value)
-        self.headers.setdefault(name,[]).append(value)
+            self.length = int( value )
+        self.headers.setdefault( name, [] ).append( value )
 
-    def bodyDataReceived(self, data):
+    def bodyDataReceived( self, data ):
         self.body += data
-    
-    def creationFinished(self):
-        if (self.length != None) and (self.length != len(self.body)):
+
+    def creationFinished( self ):
+        if ( self.length != None ) and ( self.length != len( self.body ) ):
             raise ValueError, "wrong body length"
         self.finished = 1
 
-    def toString(self):
+    def toString( self ):
         s = "%s\r\n" % self._getHeaderLine()
         for n, vs in self.headers.items():
             for v in vs:
-                s += "%s: %s\r\n" % (specialCases.get(n) or dashCapitalize(n), v)
+                s += "%s: %s\r\n" % ( specialCases.get( n ) or dashCapitalize( n ), v )
         s += "\r\n"
         s += self.body
         return s
 
-    def _getHeaderLine(self):
+    def _getHeaderLine( self ):
         raise NotImplementedError
 
 
-class Request(Message):
+class Request( Message ):
     """A Request for a URI"""
 
 
-    def __init__(self, method, uri, version="SIP/2.0"):
-        Message.__init__(self)
+    def __init__( self, method, uri, version="SIP/2.0" ):
+        Message.__init__( self )
         self.method = method
-        if isinstance(uri, URL):
+        if isinstance( uri, URL ):
             self.uri = uri
         else:
-            self.uri = parseURL(uri)
-            cleanRequestURL(self.uri)
-    
-    def __repr__(self):
-        return "<SIP Request %d:%s %s>" % (id(self), self.method, self.uri.toString())
+            self.uri = parseURL( uri )
+            cleanRequestURL( self.uri )
+
+    def __repr__( self ):
+        return "<SIP Request %d:%s %s>" % ( id( self ), self.method, self.uri.toString() )
 
-    def _getHeaderLine(self):
-        return "%s %s SIP/2.0" % (self.method, self.uri.toString())
+    def _getHeaderLine( self ):
+        return "%s %s SIP/2.0" % ( self.method, self.uri.toString() )
 
 
-class Response(Message):
+class Response( Message ):
     """A Response to a URI Request"""
 
-    def __init__(self, code, phrase=None, version="SIP/2.0"):
-        Message.__init__(self)
+    def __init__( self, code, phrase=None, version="SIP/2.0" ):
+        Message.__init__( self )
         self.code = code
         if phrase == None:
             phrase = statusCodes[code]
         self.phrase = phrase
 
-    def __repr__(self):
-        return "<SIP Response %d:%s>" % (id(self), self.code)
+    def __repr__( self ):
+        return "<SIP Response %d:%s>" % ( id( self ), self.code )
 
-    def _getHeaderLine(self):
-        return "SIP/2.0 %s %s" % (self.code, self.phrase)
+    def _getHeaderLine( self ):
+        return "SIP/2.0 %s %s" % ( self.code, self.phrase )
 
 
-class MessagesParser(basic.LineReceiver):
+class MessagesParser( basic.LineReceiver ):
     """
     A SIP messages parser.
 
@@ -517,15 +522,15 @@
     acceptResponses = 1
     acceptRequests = 1
     state = "firstline" # or "headers", "body"
-    _multiheaders = ['accept','accept-encoding', 'accept-language',
+    _multiheaders = ['accept', 'accept-encoding', 'accept-language',
                     'alert-info', 'allow', 'authentication-info',
-                    'call-info',  'content-encoding', 'content-language',
-                    'error-info', 'in-reply-to', 'proxy-require',  'require',
+                    'call-info', 'content-encoding', 'content-language',
+                    'error-info', 'in-reply-to', 'proxy-require', 'require',
                     'supported', 'unsupported', 'via', 'warning']
     _multiAddressHeaders = ['route', 'record-route', 'contact']
 
 
-    def __init__(self, messageReceivedCallback):
+    def __init__( self, messageReceivedCallback ):
         """
         @param messageReceivedCallback: A one-argument callable, to be invoked
         when a complete message has been parsed.
@@ -534,25 +539,25 @@
         self.reset()
 
 
-    def reset(self, remainingData=""):
+    def reset( self, remainingData="" ):
         """
         Prepare the parser to accept a new message.
         """
         self.state = "firstline"
         self.bodyReceived = 0 # how much of the body we received
         self.message = None
-        self.setLineMode(remainingData)
+        self.setLineMode( remainingData )
 
 
-    def invalidMessage(self):
+    def invalidMessage( self ):
         """
         Raise an exception, indicating failure to parse a valid SIP message.
         """
         self.dataDone()
-        raise SIPError(400)
+        raise SIPError( BAD_REQUEST )
 
 
-    def dataDone(self):
+    def dataDone( self ):
         """
         Signal the end of the message if a complete message has been received,
         and reset internal state to prepare for a new message.
@@ -572,11 +577,11 @@
             msg = self.message
             self.reset()
             # RFC 3261, section 18.3
-            if isinstance(msg, Request):
-                raise SIPError(BAD_REQUEST)
+            if isinstance( msg, Request ):
+                raise SIPError( BAD_REQUEST )
 
 
-    def lineLengthExceeded(self, line):
+    def lineLengthExceeded( self, line ):
         """
         Raise L{SIPError} if lines longer than L{LineReceiver.MAX_LENGTH} are
         received.
@@ -584,30 +589,30 @@
         self.invalidMessage()
 
 
-    def lineReceived(self, line):
+    def lineReceived( self, line ):
         """
         Handle a single SIP message line.
         """
         if self.state == "firstline":
-            while line.startswith("\n") or line.startswith("\r"):
+            while line.startswith( "\n" ) or line.startswith( "\r" ):
                 line = line[1:]
             if not line:
                 return
             try:
-                a, b, c = line.split(" ", 2)
+                a, b, c = line.split( " ", 2 )
             except ValueError:
                 self.invalidMessage()
             if a == "SIP/2.0" and self.acceptResponses:
                 # response
                 try:
-                    code = int(b)
+                    code = int( b )
                 except ValueError:
                     self.invalidMessage()
-                self.message = Response(code, c)
+                self.message = Response( code, c )
             elif c == "SIP/2.0" and self.acceptRequests:
-                if not b.startswith("sip:"):
-                    raise SIPError(416)
-                self.message = Request(a, b)
+                if not b.startswith( "sip:" ):
+                    raise SIPError( 416 )
+                self.message = Request( a, b )
             else:
                 self.invalidMessage()
                 return
@@ -625,7 +630,7 @@
                 #new header
                 if self.prevline:
                     try:
-                        self._processHeaderLine(self.prevline)
+                        self._processHeaderLine( self.prevline )
                     except ValueError:
                         self.invalidMessage()
                 self.prevline = line
@@ -636,7 +641,7 @@
             # from the connection sending us data.
             self.state = "body"
             try:
-                self._processHeaderLine(self.prevline)
+                self._processHeaderLine( self.prevline )
             except ValueError:
                 self.invalidMessage()
                 return
@@ -646,111 +651,111 @@
             self.setRawMode()
 
 
-    def _splitMultiHeader(self, s):
+    def _splitMultiHeader( self, s ):
         """
         Split a header on commas, ignoring commas in quotes and escaped quotes.
         """
         headers = []
         last = 0
         quoted = False
-        for i in xrange(len(s)):
+        for i in xrange( len( s ) ):
             if s[i] == '"':
                 quoted = ~quoted
                 if i == 0:
                     continue
-                j = i-1
+                j = i - 1
                 while s[j] == '\\':
                     quoted = not quoted
-                    j = j-1
+                    j = j - 1
             if not quoted and s[i] == ',':
-                headers.append(s[last:i])
-                last = i+1
-        headers.append(s[last:])
+                headers.append( s[last:i] )
+                last = i + 1
+        headers.append( s[last:] )
         return headers
 
 
-    def _processHeaderLine(self, line):
+    def _processHeaderLine( self, line ):
         """
         Parse a single SIP header.
         """
-        name, value = line.split(":", 1)
+        name, value = line.split( ":", 1 )
         name, value = name.rstrip().lower(), value.lstrip()
 
         if name in self._multiheaders:
-            multi = value.split(',')
+            multi = value.split( ',' )
             if multi:
                 for v in multi:
-                    self.message.addHeader(name, v.strip())
+                    self.message.addHeader( name, v.strip() )
             else:
-                self.message.addHeader(v)
+                self.message.addHeader( v )
         elif name in self._multiAddressHeaders:
-            for val in self._splitMultiHeader(value):
-                self.message.addHeader(name, val)
+            for val in self._splitMultiHeader( value ):
+                self.message.addHeader( name, val )
         else:
-            self.message.addHeader(name, value)
+            self.message.addHeader( name, value )
 
 
-    def messageDone(self, remainingData=""):
+    def messageDone( self, remainingData="" ):
         """
         Invoke the C{messageReceived} callback with the completed message
         object and prepare to receive a new message.
         """
         assert self.state == "body"
         self.message.creationFinished()
-        self.messageReceived(self.message)
-        self.reset(remainingData)
+        self.messageReceived( self.message )
+        self.reset( remainingData )
 
 
-    def rawDataReceived(self, data):
+    def rawDataReceived( self, data ):
         """
         Handle message body data.
         """
         if self.message.length == None:
-            self.message.bodyDataReceived(data)
+            self.message.bodyDataReceived( data )
         else:
-            dataLen = len(data)
+            dataLen = len( data )
             expectedLen = self.message.length - self.bodyReceived
             if dataLen > expectedLen:
-                self.message.bodyDataReceived(data[:expectedLen])
-                self.messageDone(data[expectedLen:])
+                self.message.bodyDataReceived( data[:expectedLen] )
+                self.messageDone( data[expectedLen:] )
                 return
             else:
                 self.bodyReceived += dataLen
-                self.message.bodyDataReceived(data)
+                self.message.bodyDataReceived( data )
                 if self.bodyReceived == self.message.length:
                     self.messageDone()
 
 
-class Base(protocol.DatagramProtocol):
+class Base( protocol.DatagramProtocol ):
     """Base class for SIP clients and servers."""
-    
+
     PORT = PORT
     debug = False
-    
-    def __init__(self):
+
+    def __init__( self ):
         self.messages = []
-        self.parser = MessagesParser(self.addMessage)
+        self.parser = MessagesParser( self.addMessage )
 
-    def addMessage(self, msg):
-        self.messages.append(msg)
+    def addMessage( self, msg ):
+        self.messages.append( msg )
 
-    def datagramReceived(self, data, addr):
-        self.parser.dataReceived(data)
+    def datagramReceived( self, data, addr ):
+        self.parser.dataReceived( data )
         self.parser.dataDone()
         for m in self.messages:
-            self._fixupNAT(m, addr)
+            self._fixupNAT( m, addr )
             if self.debug:
-                log.msg("Received %r from %r" % (m.toString(), addr))
-            if isinstance(m, Request):
-                self.handle_request(m, addr)
+                log.msg( "Received %r from %r" % ( m.toString(), addr ) )
+            if isinstance( m, Request ):
+                self.handle_request( m, addr )
             else:
-                self.handle_response(m, addr)
+                self.handle_response( m, addr )
         self.messages[:] = []
 
-    def _fixupNAT(self, message, (srcHost, srcPort)):
+    def _fixupNAT( self, message, ( srcHost, srcPort ) ):
         # RFC 2543 6.40.2,
-        senderVia = parseViaHeader(message.headers["via"][0])
-        if senderVia.host != srcHost:            
+        senderVia = parseViaHeader( message.headers["via"][0] )
+        if senderVia.host != srcHost:
             senderVia.received = srcHost
             if senderVia.port != srcPort:
                 senderVia.rport = srcPort
@@ -760,38 +765,38 @@
             senderVia.rport = srcPort
             message.headers["via"][0] = senderVia.toString()
 
-    def deliverResponse(self, responseMessage):
+    def deliverResponse( self, responseMessage ):
         """Deliver response.
 
         Destination is based on topmost Via header."""
-        destVia = parseViaHeader(responseMessage.headers["via"][0])
+        destVia = parseViaHeader( responseMessage.headers["via"][0] )
         # XXX we don't do multicast yet
         host = destVia.received or destVia.host
         port = destVia.rport or destVia.port or self.PORT
-        destAddr = URL(host=host, port=port)
-        self.sendMessage(destAddr, responseMessage)
+        destAddr = URL( host=host, port=port )
+        self.sendMessage( destAddr, responseMessage )
 
-    def responseFromRequest(self, code, request):
+    def responseFromRequest( self, code, request ):
         """Create a response to a request message."""
-        response = Response(code)
-        for name in ("via", "to", "from", "call-id", "cseq"):
-            response.headers[name] = request.headers.get(name, [])[:]
+        response = Response( code )
+        for name in ( "via", "to", "from", "call-id", "cseq" ):
+            response.headers[name] = request.headers.get( name, [] )[:]
 
         return response
 
-    def sendMessage(self, destURL, message):
+    def sendMessage( self, destURL, message ):
         """Send a message.
 
         @param destURL: C{URL}. This should be a *physical* URL, not a logical one.
         @param message: The message to send.
         """
-        if destURL.transport not in ("udp", None):
+        if destURL.transport not in ( "udp", None ):
             raise RuntimeError, "only UDP currently supported"
         if self.debug:
-            log.msg("Sending %r to %r" % (message.toString(), destURL))
-        self.transport.write(message.toString(), (destURL.host, destURL.port or self.PORT))
+            log.msg( "Sending %r to %r" % ( message.toString(), destURL ) )
+        self.transport.write( message.toString(), ( destURL.host, destURL.port or self.PORT ) )
 
-    def handle_request(self, message, addr):
+    def handle_request( self, message, addr ):
         """Override to define behavior for requests received
 
         @type message: C{Message}
@@ -799,7 +804,7 @@
         """
         raise NotImplementedError
 
-    def handle_response(self, message, addr):
+    def handle_response( self, message, addr ):
         """Override to define behavior for responses received.
         
         @type message: C{Message}
@@ -808,41 +813,41 @@
         raise NotImplementedError
 
 
-class IContact(Interface):
+class IContact( Interface ):
     """A user of a registrar or proxy"""
 
 
 class Registration:
-    def __init__(self, secondsToExpiry, contactURL):
+    def __init__( self, secondsToExpiry, contactURL ):
         self.secondsToExpiry = secondsToExpiry
         self.contactURL = contactURL
 
-class IRegistry(Interface):
+class IRegistry( Interface ):
     """Allows registration of logical->physical URL mapping."""
 
-    def registerAddress(domainURL, logicalURL, physicalURL):
+    def registerAddress( domainURL, logicalURL, physicalURL ):
         """Register the physical address of a logical URL.
 
         @return: Deferred of C{Registration} or failure with RegistrationError.
         """
 
-    def unregisterAddress(domainURL, logicalURL, physicalURL):
+    def unregisterAddress( domainURL, logicalURL, physicalURL ):
         """Unregister the physical address of a logical URL.
 
         @return: Deferred of C{Registration} or failure with RegistrationError.
         """
 
-    def getRegistrationInfo(logicalURL):
+    def getRegistrationInfo( logicalURL ):
         """Get registration info for logical URL.
 
         @return: Deferred of C{Registration} object or failure of LookupError.
         """
 
 
-class ILocator(Interface):
+class ILocator( Interface ):
     """Allow looking up physical address for logical URL."""
 
-    def getAddress(logicalURL):
+    def getAddress( logicalURL ):
         """Return physical URL of server for logical URL of user.
 
         @param logicalURL: a logical C{URL}.
@@ -850,14 +855,14 @@
         """
 
 
-class Proxy(Base):
+class Proxy( Base ):
     """SIP proxy."""
-    
+
     PORT = PORT
 
     locator = None # object implementing ILocator
-    
-    def __init__(self, host=None, port=PORT):
+
+    def __init__( self, host=None, port=PORT ):
         """Create new instance.
 
         @param host: our hostname/IP as set in Via headers.
@@ -865,32 +870,32 @@
         """
         self.host = host or socket.getfqdn()
         self.port = port
-        Base.__init__(self)
-        
-    def getVia(self):
+        Base.__init__( self )
+
+    def getVia( self ):
         """Return value of Via header for this proxy."""
-        return Via(host=self.host, port=self.port)
+        return Via( host=self.host, port=self.port )
 
-    def handle_request(self, message, addr):
+    def handle_request( self, message, addr ):
         # send immediate 100/trying message before processing
         #self.deliverResponse(self.responseFromRequest(100, message))
-        f = getattr(self, "handle_%s_request" % message.method, None)
+        f = getattr( self, "handle_%s_request" % message.method, None )
         if f is None:
             f = self.handle_request_default
         try:
-            d = f(message, addr)
+            d = f( message, addr )
         except SIPError, e:
-            self.deliverResponse(self.responseFromRequest(e.code, message))
+            self.deliverResponse( self.responseFromRequest( e.code, message ) )
         except:
             log.err()
-            self.deliverResponse(self.responseFromRequest(500, message))
+            self.deliverResponse( self.responseFromRequest( INTERNAL_SERVER_ERROR, message ) )
         else:
             if d is not None:
-                d.addErrback(lambda e:
-                    self.deliverResponse(self.responseFromRequest(e.code, message))
+                d.addErrback( lambda e:
+                    self.deliverResponse( self.responseFromRequest( e.code, message ) )
                 )
-        
-    def handle_request_default(self, message, (srcHost, srcPort)):
+
+    def handle_request_default( self, message, ( srcHost, srcPort ) ):
         """Default request handler.
         
         Default behaviour for OPTIONS and unknown methods for proxies
@@ -899,70 +904,70 @@
         Since at the moment we are stateless proxy, thats basically
         everything.
         """
-        def _mungContactHeader(uri, message):
-            message.headers['contact'][0] = uri.toString()            
-            return self.sendMessage(uri, message)
-        
+        def _mungContactHeader( uri, message ):
+            message.headers['contact'][0] = uri.toString()
+            return self.sendMessage( uri, message )
+
         viaHeader = self.getVia()
         if viaHeader.toString() in message.headers["via"]:
             # must be a loop, so drop message
-            log.msg("Dropping looped message.")
+            log.msg( "Dropping looped message." )
             return
 
-        message.headers["via"].insert(0, viaHeader.toString())
-        name, uri, tags = parseAddress(message.headers["to"][0], clean=1)
+        message.headers["via"].insert( 0, viaHeader.toString() )
+        name, uri, tags = parseAddress( message.headers["to"][0], clean=1 )
 
         # this is broken and needs refactoring to use cred
-        d = self.locator.getAddress(uri)
-        d.addCallback(self.sendMessage, message)
-        d.addErrback(self._cantForwardRequest, message)
-    
-    def _cantForwardRequest(self, error, message):
-        error.trap(LookupError)
+        d = self.locator.getAddress( uri )
+        d.addCallback( self.sendMessage, message )
+        d.addErrback( self._cantForwardRequest, message )
+
+    def _cantForwardRequest( self, error, message ):
+        error.trap( LookupError )
         del message.headers["via"][0] # this'll be us
-        self.deliverResponse(self.responseFromRequest(404, message))
-    
-    def deliverResponse(self, responseMessage):
+        self.deliverResponse( self.responseFromRequest( NOT_FOUND, message ) )
+
+    def deliverResponse( self, responseMessage ):
         """Deliver response.
 
         Destination is based on topmost Via header."""
-        destVia = parseViaHeader(responseMessage.headers["via"][0])
+        destVia = parseViaHeader( responseMessage.headers["via"][0] )
         # XXX we don't do multicast yet
         host = destVia.received or destVia.host
         port = destVia.rport or destVia.port or self.PORT
-        
-        destAddr = URL(host=host, port=port)
-        self.sendMessage(destAddr, responseMessage)
 
-    def responseFromRequest(self, code, request):
+        destAddr = URL( host=host, port=port )
+        self.sendMessage( destAddr, responseMessage )
+
+    def responseFromRequest( self, code, request ):
         """Create a response to a request message."""
-        response = Response(code)
-        for name in ("via", "to", "from", "call-id", "cseq"):
-            response.headers[name] = request.headers.get(name, [])[:]
+        response = Response( code )
+        for name in ( "via", "to", "from", "call-id", "cseq" ):
+            response.headers[name] = request.headers.get( name, [] )[:]
         return response
-    
-    def handle_response(self, message, addr):
+
+    def handle_response( self, message, addr ):
         """Default response handler."""
-        v = parseViaHeader(message.headers["via"][0])
-        if (v.host, v.port) != (self.host, self.port):
+        v = parseViaHeader( message.headers["via"][0] )
+        if ( v.host, v.port ) != ( self.host, self.port ):
             # we got a message not intended for us?
             # XXX note this check breaks if we have multiple external IPs
             # yay for suck protocols
-            log.msg("Dropping incorrectly addressed message")
+            log.msg( "Dropping incorrectly addressed message" )
             return
         del message.headers["via"][0]
         if not message.headers["via"]:
             # this message is addressed to us
-            self.gotResponse(message, addr)
+            self.gotResponse( message, addr )
             return
-        self.deliverResponse(message)
-    
-    def gotResponse(self, message, addr):
+        self.deliverResponse( message )
+
+    def gotResponse( self, message, addr ):
         """Called with responses that are addressed at this server."""
         pass
 
-class IAuthorizer(Interface):
-    def getChallenge(peer):
+class IAuthorizer( Interface ):
+    def getChallenge( peer ):
         """Generate a challenge the client may respond to.
         
         @type peer: C{tuple}
@@ -971,118 +976,118 @@
         @rtype: C{str}
         @return: The challenge string
         """
-    
-    def decode(response):
+
+    def decode( response ):
         """Create a credentials object from the given response.
         
         @type response: C{str}
         """
- 
+
 class BasicAuthorizer:
     """Authorizer for insecure Basic (base64-encoded plaintext) authentication.
     
     This form of authentication is broken and insecure.  Do not use it.
     """
 
-    implements(IAuthorizer)
-    
-    def getChallenge(self, peer):
+    implements( IAuthorizer )
+
+    def getChallenge( self, peer ):
         return None
-    
-    def decode(self, response):
+
+    def decode( self, response ):
         # At least one SIP client improperly pads its Base64 encoded messages
-        for i in range(3):
+        for i in range( 3 ):
             try:
-                creds = (response + ('=' * i)).decode('base64')
+                creds = ( response + ( '=' * i ) ).decode( 'base64' )
             except:
                 pass
             else:
                 break
         else:
             # Totally bogus
-            raise SIPError(400)
-        p = creds.split(':', 1)
-        if len(p) == 2:
-            return cred.credentials.UsernamePassword(*p)
-        raise SIPError(400)
+            raise SIPError( BAD_REQUEST )
+        p = creds.split( ':', 1 )
+        if len( p ) == 2:
+            return cred.credentials.UsernamePassword( *p )
+        raise SIPError( BAD_REQUEST )
 
 
-class DigestedCredentials(cred.credentials.UsernameHashedPassword):
+class DigestedCredentials( cred.credentials.UsernameHashedPassword ):
     """Yet Another Simple Digest-MD5 authentication scheme"""
-    
-    def __init__(self, username, fields, challenges):
+
+    def __init__( self, username, fields, challenges ):
         self.username = username
         self.fields = fields
         self.challenges = challenges
-    
-    def checkPassword(self, password):
+
+    def checkPassword( self, password ):
         method = 'REGISTER'
-        response = self.fields.get('response')
-        uri = self.fields.get('uri')
-        nonce = self.fields.get('nonce')
-        cnonce = self.fields.get('cnonce')
-        nc = self.fields.get('nc')
-        algo = self.fields.get('algorithm', 'MD5')
-        qop = self.fields.get('qop-options', 'auth')
-        opaque = self.fields.get('opaque')
+        response = self.fields.get( 'response' )
+        uri = self.fields.get( 'uri' )
+        nonce = self.fields.get( 'nonce' )
+        cnonce = self.fields.get( 'cnonce' )
+        nc = self.fields.get( 'nc' )
+        algo = self.fields.get( 'algorithm', 'MD5' )
+        qop = self.fields.get( 'qop-options', 'auth' )
+        opaque = self.fields.get( 'opaque' )
 
         if opaque not in self.challenges:
             return False
         del self.challenges[opaque]
-        
-        user, domain = self.username.split('@', 1)
+
+        user, domain = self.username.split( '@', 1 )
         if uri is None:
             uri = 'sip:' + domain
 
-        expected = DigestCalcResponse(
-            DigestCalcHA1(algo, user, domain, password, nonce, cnonce),
+        expected = DigestCalcResponse( 
+            DigestCalcHA1( algo, user, domain, password, nonce, cnonce ),
             nonce, nc, cnonce, qop, method, uri, None,
         )
-        
+
         return expected == response
 
 class DigestAuthorizer:
     CHALLENGE_LIFETIME = 15
-    
-    implements(IAuthorizer)
-    
-    def __init__(self):
+
+    implements( IAuthorizer )
+
+    def __init__( self ):
         self.outstanding = {}
-    
-    def generateNonce(self):
-        c = tuple([random.randrange(sys.maxint) for _ in range(3)])
+
+    def generateNonce( self ):
+        c = tuple( [random.randrange( sys.maxint ) for _ in range( 3 )] )
         c = '%d%d%d' % c
         return c
 
-    def generateOpaque(self):
-        return str(random.randrange(sys.maxint))
+    def generateOpaque( self ):
+        return str( random.randrange( sys.maxint ) )
 
-    def getChallenge(self, peer):
+    def getChallenge( self, peer ):
         c = self.generateNonce()
         o = self.generateOpaque()
         self.outstanding[o] = c
-        return ','.join((
+        return ','.join( ( 
             'nonce="%s"' % c,
             'opaque="%s"' % o,
             'qop-options="auth"',
             'algorithm="MD5"',
-        ))
-        
-    def decode(self, response):
-        response = ' '.join(response.splitlines())
-        parts = response.split(',')
-        auth = dict([(k.strip(), unq(v.strip())) for (k, v) in [p.split('=', 1) for p in parts]])
+        ) )
+
+    def decode( self, response ):
+        response = ' '.join( response.splitlines() )
+        parts = response.split( ',' )
+        auth = dict( [( k.strip(), unq( v.strip() ) ) for ( k, v ) in [p.split( '=', 1 ) for p in parts]] )
         try:
             username = auth['username']
         except KeyError:
-            raise SIPError(401)
+            raise SIPError( UNAUTHORIZED )
         try:
-            return DigestedCredentials(username, auth, self.outstanding)
+            return DigestedCredentials( username, auth, self.outstanding )
         except:
-            raise SIPError(400)
+            raise SIPError( BAD_REQUEST )
 
 
-class RegisterProxy(Proxy):
+class RegisterProxy( Proxy ):
     """A proxy that allows registration for a specific domain.
 
     Unregistered users won't be handled.
@@ -1095,12 +1100,12 @@
     authorizers = {
         'digest': DigestAuthorizer(),
     }
-    
-    def __init__(self, *args, **kw):
-        Proxy.__init__(self, *args, **kw)
+
+    def __init__( self, *args, **kw ):
+        Proxy.__init__( self, *args, **kw )
         self.liveChallenges = {}
-        
-    def handle_ACK_request(self, message, (host, port)):
+
+    def handle_ACK_request( self, message, ( host, port ) ):
         # XXX
         # ACKs are a client's way of indicating they got the last message
         # Responding to them is not a good idea.
@@ -1108,175 +1113,175 @@
         # if no ACK is received.
         pass
 
-    def handle_REGISTER_request(self, message, (host, port)):
+    def handle_REGISTER_request( self, message, ( host, port ) ):
         """Handle a registration request.
 
         Currently registration is not proxied.
         """
         if self.portal is None:
             # There is no portal.  Let anyone in.
-            self.register(message, host, port)
+            self.register( message, host, port )
         else:
             # There is a portal.  Check for credentials.
-            if not message.headers.has_key("authorization"):
-                return self.unauthorized(message, host, port)
+            if not message.headers.has_key( "authorization" ):
+                return self.unauthorized( message, host, port )
             else:
-                return self.login(message, host, port)
+                return self.login( message, host, port )
 
-    def unauthorized(self, message, host, port):
-        m = self.responseFromRequest(401, message)
-        for (scheme, auth) in self.authorizers.iteritems():
-            chal = auth.getChallenge((host, port))
+    def unauthorized( self, message, host, port ):
+        m = self.responseFromRequest( UNAUTHORIZED, message )
+        for ( scheme, auth ) in self.authorizers.iteritems():
+            chal = auth.getChallenge( ( host, port ) )
             if chal is None:
-                value = '%s realm="%s"' % (scheme.title(), self.host)
+                value = '%s realm="%s"' % ( scheme.title(), self.host )
             else:
-                value = '%s %s,realm="%s"' % (scheme.title(), chal, self.host)
-            m.headers.setdefault('www-authenticate', []).append(value)
-        self.deliverResponse(m)
+                value = '%s %s,realm="%s"' % ( scheme.title(), chal, self.host )
+            m.headers.setdefault( 'www-authenticate', [] ).append( value )
+        self.deliverResponse( m )
 
- 
-    def login(self, message, host, port):
-        parts = message.headers['authorization'][0].split(None, 1)
-        a = self.authorizers.get(parts[0].lower())
+
+    def login( self, message, host, port ):
+        parts = message.headers['authorization'][0].split( None, 1 )
+        a = self.authorizers.get( parts[0].lower() )
         if a:
             try:
-                c = a.decode(parts[1])
+                c = a.decode( parts[1] )
             except SIPError:
                 raise
             except:
                 log.err()
-                self.deliverResponse(self.responseFromRequest(500, message))
+                self.deliverResponse( self.responseFromRequest( INTERNAL_SERVER_ERROR, message ) )
             else:
                 c.username += '@' + self.host
-                self.portal.login(c, None, IContact
-                    ).addCallback(self._cbLogin, message, host, port
-                    ).addErrback(self._ebLogin, message, host, port
-                    ).addErrback(log.err
+                self.portal.login( c, None, IContact
+                    ).addCallback( self._cbLogin, message, host, port
+                    ).addErrback( self._ebLogin, message, host, port
+                    ).addErrback( log.err
                     )
         else:
-            self.deliverResponse(self.responseFromRequest(501, message))
+            self.deliverResponse( self.responseFromRequest( NOT_IMPLEMENTED, message ) )
 
-    def _cbLogin(self, (i, a, l), message, host, port):
+    def _cbLogin( self, ( i, a, l ), message, host, port ):
         # It's stateless, matey.  What a joke.
-        self.register(message, host, port)
-    
-    def _ebLogin(self, failure, message, host, port):
-        failure.trap(cred.error.UnauthorizedLogin)
-        self.unauthorized(message, host, port)
+        self.register( message, host, port )
 
-    def register(self, message, host, port):
+    def _ebLogin( self, failure, message, host, port ):
+        failure.trap( cred.error.UnauthorizedLogin )
+        self.unauthorized( message, host, port )
+
+    def register( self, message, host, port ):
         """Allow all users to register"""
-        name, toURL, params = parseAddress(message.headers["to"][0], clean=1)
+        name, toURL, params = parseAddress( message.headers["to"][0], clean=1 )
         contact = None
-        if message.headers.has_key("contact"):
+        if message.headers.has_key( "contact" ):
             contact = message.headers["contact"][0]
 
-        if message.headers.get("expires", [None])[0] == "0":
-            self.unregister(message, toURL, contact)
+        if message.headers.get( "expires", [None] )[0] == "0":
+            self.unregister( message, toURL, contact )
         else:
             # XXX Check expires on appropriate URL, and pass it to registry
             # instead of having registry hardcode it.
             if contact is not None:
-                name, contactURL, params = parseAddress(contact, host=host, port=port)
-                d = self.registry.registerAddress(message.uri, toURL, contactURL)
+                name, contactURL, params = parseAddress( contact, host=host, port=port )
+                d = self.registry.registerAddress( message.uri, toURL, contactURL )
             else:
-                d = self.registry.getRegistrationInfo(toURL)
-            d.addCallbacks(self._cbRegister, self._ebRegister,
-                callbackArgs=(message,),
-                errbackArgs=(message,)
+                d = self.registry.getRegistrationInfo( toURL )
+            d.addCallbacks( self._cbRegister, self._ebRegister,
+                callbackArgs=( message, ),
+                errbackArgs=( message, )
             )
 
-    def _cbRegister(self, registration, message):
-        response = self.responseFromRequest(200, message)
+    def _cbRegister( self, registration, message ):
+        response = self.responseFromRequest( OK, message )
         if registration.contactURL != None:
-            response.addHeader("contact", registration.contactURL.toString())
-            response.addHeader("expires", "%d" % registration.secondsToExpiry)
-        response.addHeader("content-length", "0")
-        self.deliverResponse(response)
+            response.addHeader( "contact", registration.contactURL.toString() )
+            response.addHeader( "expires", "%d" % registration.secondsToExpiry )
+        response.addHeader( "content-length", "0" )
+        self.deliverResponse( response )
 
-    def _ebRegister(self, error, message):
-        error.trap(RegistrationError, LookupError)
+    def _ebRegister( self, error, message ):
+        error.trap( RegistrationError, LookupError )
         # XXX return error message, and alter tests to deal with
         # this, currently tests assume no message sent on failure
 
-    def unregister(self, message, toURL, contact):
+    def unregister( self, message, toURL, contact ):
         try:
-            expires = int(message.headers["expires"][0])
+            expires = int( message.headers["expires"][0] )
         except ValueError:
-            self.deliverResponse(self.responseFromRequest(400, message))
+            self.deliverResponse( self.responseFromRequest( BAD_REQUEST, message ) )
         else:
             if expires == 0:
                 if contact == "*":
                     contactURL = "*"
                 else:
-                    name, contactURL, params = parseAddress(contact)
-                d = self.registry.unregisterAddress(message.uri, toURL, contactURL)
-                d.addCallback(self._cbUnregister, message
-                    ).addErrback(self._ebUnregister, message
+                    name, contactURL, params = parseAddress( contact )
+                d = self.registry.unregisterAddress( message.uri, toURL, contactURL )
+                d.addCallback( self._cbUnregister, message
+                    ).addErrback( self._ebUnregister, message
                     )
 
-    def _cbUnregister(self, registration, message):
-        msg = self.responseFromRequest(200, message)
-        msg.headers.setdefault('contact', []).append(registration.contactURL.toString())
-        msg.addHeader("expires", "0")
-        self.deliverResponse(msg)
+    def _cbUnregister( self, registration, message ):
+        msg = self.responseFromRequest( OK, message )
+        msg.headers.setdefault( 'contact', [] ).append( registration.contactURL.toString() )
+        msg.addHeader( "expires", "0" )
+        self.deliverResponse( msg )
 
-    def _ebUnregister(self, registration, message):
+    def _ebUnregister( self, registration, message ):
         pass
 
 
 class InMemoryRegistry:
     """A simplistic registry for a specific domain."""
 
-    implements(IRegistry, ILocator)
-    
-    def __init__(self, domain):
+    implements( IRegistry, ILocator )
+
+    def __init__( self, domain ):
         self.domain = domain # the domain we handle registration for
         self.users = {} # map username to (IDelayedCall for expiry, address URI)
 
-    def getAddress(self, userURI):
+    def getAddress( self, userURI ):
         if userURI.host != self.domain:
-            return defer.fail(LookupError("unknown domain"))
-        if self.users.has_key(userURI.username):
+            return defer.fail( LookupError( "unknown domain" ) )
+        if self.users.has_key( userURI.username ):
             dc, url = self.users[userURI.username]
-            return defer.succeed(url)
+            return defer.succeed( url )
         else:
-            return defer.fail(LookupError("no such user"))
-            
-    def getRegistrationInfo(self, userURI):
+            return defer.fail( LookupError( "no such user" ) )
+
+    def getRegistrationInfo( self, userURI ):
         if userURI.host != self.domain:
-            return defer.fail(LookupError("unknown domain"))
-        if self.users.has_key(userURI.username):
+            return defer.fail( LookupError( "unknown domain" ) )
+        if self.users.has_key( userURI.username ):
             dc, url = self.users[userURI.username]
-            return defer.succeed(Registration(int(dc.getTime() - time.time()), url))
+            return defer.succeed( Registration( int( dc.getTime() - time.time() ), url ) )
         else:
-            return defer.fail(LookupError("no such user"))
-        
-    def _expireRegistration(self, username):
+            return defer.fail( LookupError( "no such user" ) )
+
+    def _expireRegistration( self, username ):
         try:
             dc, url = self.users[username]
         except KeyError:
-            return defer.fail(LookupError("no such user"))
+            return defer.fail( LookupError( "no such user" ) )
         else:
             dc.cancel()
             del self.users[username]
-        return defer.succeed(Registration(0, url))
-    
-    def registerAddress(self, domainURL, logicalURL, physicalURL):
+        return defer.succeed( Registration( 0, url ) )
+
+    def registerAddress( self, domainURL, logicalURL, physicalURL ):
         if domainURL.host != self.domain:
-            log.msg("Registration for domain we don't handle.")
-            return defer.fail(RegistrationError(404))
+            log.msg( "Registration for domain we don't handle." )
+            return defer.fail( RegistrationError( 404 ) )
         if logicalURL.host != self.domain:
-            log.msg("Registration for domain we don't handle.")
-            return defer.fail(RegistrationError(404))
-        if self.users.has_key(logicalURL.username):
+            log.msg( "Registration for domain we don't handle." )
+            return defer.fail( RegistrationError( 404 ) )
+        if self.users.has_key( logicalURL.username ):
             dc, old = self.users[logicalURL.username]
-            dc.reset(3600)
+            dc.reset( 3600 )
         else:
-            dc = reactor.callLater(3600, self._expireRegistration, logicalURL.username)
-        log.msg("Registered %s at %s" % (logicalURL.toString(), physicalURL.toString()))
-        self.users[logicalURL.username] = (dc, physicalURL)
-        return defer.succeed(Registration(int(dc.getTime() - time.time()), physicalURL))
+            dc = reactor.callLater( 3600, self._expireRegistration, logicalURL.username )
+        log.msg( "Registered %s at %s" % ( logicalURL.toString(), physicalURL.toString() ) )
+        self.users[logicalURL.username] = ( dc, physicalURL )
+        return defer.succeed( Registration( int( dc.getTime() - time.time() ), physicalURL ) )
 
-    def unregisterAddress(self, domainURL, logicalURL, physicalURL):
-        return self._expireRegistration(logicalURL.username)
+    def unregisterAddress( self, domainURL, logicalURL, physicalURL ):
+        return self._expireRegistration( logicalURL.username )
