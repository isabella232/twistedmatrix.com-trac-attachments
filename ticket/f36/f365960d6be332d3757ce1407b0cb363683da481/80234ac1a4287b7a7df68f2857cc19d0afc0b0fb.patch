diff --git a/twisted/protocols/amp.py b/twisted/protocols/amp.py
index a744882..5b353e3 100644
--- a/twisted/protocols/amp.py
+++ b/twisted/protocols/amp.py
@@ -171,16 +171,19 @@ has several features:
       which always issue NUL as the first byte.
 """
 
+from __future__ import unicode_literals
+
 __metaclass__ = type
 
 import types, warnings
 
-from cStringIO import StringIO
+from io import BytesIO
 from struct import pack
 import decimal, datetime
+from functools import partial
 from itertools import count
 
-from zope.interface import Interface, implements
+from zope.interface import Interface, implementer
 
 from twisted.python.reflect import accumulateClassDict
 from twisted.python.failure import Failure
@@ -196,6 +199,9 @@ from twisted.internet.error import PeerVerifyError, ConnectionLost
 from twisted.internet.error import ConnectionClosed
 from twisted.internet.defer import Deferred, maybeDeferred, fail
 from twisted.protocols.basic import Int16StringReceiver, StatefulStringProtocol
+from twisted.python.compat import (
+    iteritems, unicode, nativeString, intToBytes, _PY3, long,
+)
 
 try:
     from twisted.internet import ssl
@@ -269,19 +275,43 @@ __all__ = [
 
 
 
-ASK = '_ask'
-ANSWER = '_answer'
-COMMAND = '_command'
-ERROR = '_error'
-ERROR_CODE = '_error_code'
-ERROR_DESCRIPTION = '_error_description'
-UNKNOWN_ERROR_CODE = 'UNKNOWN'
-UNHANDLED_ERROR_CODE = 'UNHANDLED'
+ASK = b'_ask'
+ANSWER = b'_answer'
+COMMAND = b'_command'
+ERROR = b'_error'
+ERROR_CODE = b'_error_code'
+ERROR_DESCRIPTION = b'_error_description'
+UNKNOWN_ERROR_CODE = b'UNKNOWN'
+UNHANDLED_ERROR_CODE = b'UNHANDLED'
 
 MAX_KEY_LENGTH = 0xff
 MAX_VALUE_LENGTH = 0xffff
 
 
+
+def byteString(string, encoding="ascii"):
+    """Coerce C{string} to a byte string.
+
+    If C{string} is already a byte string, it is returned unchanged. If it's a
+    Unicode string, it is encoded with C{encoding}, ASCII by default.
+
+    @raise TypeError: If C{string} is neither a Unicode nor a byte string.
+    @raise LookupError: If C{encoding} is not a recognised encoding.
+    @raise UnicodeEncodeError: If encoding C{string} fails.
+
+    @rtype: C{bytes}
+    """
+    if isinstance(string, bytes):
+        return string
+    elif isinstance(string, unicode):
+        return string.encode(encoding)
+    else:
+        raise TypeError(
+            "Expected Unicode string or byte string, got: %r (%r)"
+            % (string, type(string)))
+
+
+
 class IArgumentType(Interface):
     """
     An L{IArgumentType} can serialize a Python object into an AMP box and
@@ -588,6 +618,15 @@ class AmpBox(dict):
                                 # acquire a __dict__...
 
 
+    def __init__(self, *args, **kw):
+        super(AmpBox, self).__init__(*args, **kw)
+        if _PY3:
+            non_byte_names = [n for n in self if not isinstance(n, bytes)]
+            for non_byte_name in non_byte_names:
+                byte_name = byteString(non_byte_name)
+                self[byte_name] = self.pop(non_byte_name)
+
+
     def copy(self):
         """
         Return another AmpBox just like me.
@@ -604,8 +643,7 @@ class AmpBox(dict):
         @return: a str encoded according to the rules described in the module
         docstring.
         """
-        i = self.items()
-        i.sort()
+        i = sorted(iteritems(self))
         L = []
         w = L.append
         for k, v in i:
@@ -622,7 +660,7 @@ class AmpBox(dict):
                 w(pack("!H", len(kv)))
                 w(kv)
         w(pack("!H", 0))
-        return ''.join(L)
+        return b''.join(L)
 
 
     def _sendTo(self, proto):
@@ -703,6 +741,7 @@ class _SwitchBox(AmpBox):
 
 
 
+@implementer(IBoxReceiver)
 class BoxDispatcher:
     """
     A L{BoxDispatcher} dispatches '_ask', '_answer', and '_error' L{AmpBox}es,
@@ -728,11 +767,9 @@ class BoxDispatcher:
     @type boxSender: L{IBoxSender}
     """
 
-    implements(IBoxReceiver)
-
     _failAllReason = None
     _outstandingRequests = None
-    _counter = 0L
+    _counter = long(0)
     boxSender = None
 
     def __init__(self, locator):
@@ -778,7 +815,12 @@ class BoxDispatcher:
         @return: a string that has not yet been used on this connection.
         """
         self._counter += 1
-        return '%x' % (self._counter,)
+        if _PY3:
+            # Python 3.4 cannot do % interpolation on byte strings so we must
+            # work with a Unicode string and then encode.
+            return (u'%x' % self._counter).encode("ascii")
+        else:
+            return (b'%x' % self._counter)
 
 
     def _sendBoxCommand(self, command, box, requiresAnswer=True):
@@ -918,6 +960,8 @@ class BoxDispatcher:
         question.addErrback(self.unhandledError)
         errorCode = box[ERROR_CODE]
         description = box[ERROR_DESCRIPTION]
+        if _PY3 and isinstance(description, bytes):
+            description = description.decode("utf-8", "replace")
         if errorCode in PROTOCOL_ERRORS:
             exc = PROTOCOL_ERRORS[errorCode](errorCode, description)
         else:
@@ -937,6 +981,8 @@ class BoxDispatcher:
             if error.check(RemoteAmpError):
                 code = error.value.errorCode
                 desc = error.value.description
+                if _PY3 and isinstance(desc, unicode):
+                    desc = desc.encode("utf-8", "replace")
                 if error.value.fatal:
                     errorBox = QuitBox()
                 else:
@@ -946,7 +992,7 @@ class BoxDispatcher:
                 log.err(error) # here is where server-side logging happens
                                # if the error isn't handled
                 code = UNKNOWN_ERROR_CODE
-                desc = "Unknown Error"
+                desc = b"Unknown Error"
             errorBox[ERROR] = box[ASK]
             errorBox[ERROR_DESCRIPTION] = desc
             errorBox[ERROR_CODE] = code
@@ -1005,13 +1051,14 @@ class BoxDispatcher:
         if responder is None:
             return fail(RemoteAmpError(
                     UNHANDLED_ERROR_CODE,
-                    "Unhandled Command: %r" % (cmd,),
+                    byteString("Unhandled Command: %r" % (cmd,)),
                     False,
                     local=Failure(UnhandledCommand())))
         return maybeDeferred(responder, box)
 
 
 
+@implementer(IResponderLocator)
 class CommandLocator:
     """
     A L{CommandLocator} is a collection of responders to AMP L{Command}s, with
@@ -1059,9 +1106,6 @@ class CommandLocator:
             return subcls
 
 
-    implements(IResponderLocator)
-
-
     def _wrapWithSerialization(self, aCallable, command):
         """
         Wrap aCallable with its command's argument de-serialization
@@ -1131,21 +1175,31 @@ class CommandLocator:
         cd = self._commandDispatch
         if name in cd:
             commandClass, responderFunc = cd[name]
-            responderMethod = types.MethodType(
-                responderFunc, self, self.__class__)
+            if _PY3:
+                responderMethod = types.MethodType(
+                    responderFunc, self)
+            else:
+                responderMethod = types.MethodType(
+                    responderFunc, self, self.__class__)
             return self._wrapWithSerialization(responderMethod, commandClass)
 
 
 
+if _PY3:
+    # Apply __metaclass__ to CommandLocator.
+    CommandLocator = CommandLocator.__metaclass__(
+        "CommandLocator", (CommandLocator, ), {})
+
+
+
+@implementer(IResponderLocator)
 class SimpleStringLocator(object):
     """
     Implement the L{locateResponder} method to do simple, string-based
     dispatch.
     """
 
-    implements(IResponderLocator)
-
-    baseDispatchPrefix = 'amp_'
+    baseDispatchPrefix = b'amp_'
 
     def locateResponder(self, name):
         """
@@ -1157,7 +1211,7 @@ class SimpleStringLocator(object):
 
         @param name: the normalized name (from the wire) of the command.
         """
-        fName = self.baseDispatchPrefix + (name.upper())
+        fName = nativeString(self.baseDispatchPrefix + name.upper())
         return getattr(self, fName, None)
 
 
@@ -1193,13 +1247,15 @@ def _wireNameToPythonIdentifier(key):
     @return: a str which is a valid python identifier, looking something like
     'foo_bar_baz' or 'From'.
     """
-    lkey = key.replace("-", "_")
+    assert isinstance(key, bytes), repr(key)
+    lkey = nativeString(key.replace(b"-", b"_"))
     if lkey in PYTHON_KEYWORDS:
         return lkey.title()
     return lkey
 
 
 
+@implementer(IArgumentType)
 class Argument:
     """
     Base-class of all objects that take values from Amp packets and convert
@@ -1210,7 +1266,6 @@ class Argument:
     which will be used to define the behavior of L{IArgumentType.toBox} and
     L{IArgumentType.fromBox}, respectively.
     """
-    implements(IArgumentType)
 
     optional = False
 
@@ -1271,6 +1326,9 @@ class Argument:
         if self.optional and st is None:
             objects[nk] = None
         else:
+            assert isinstance(st, bytes), (
+                "%s.fromStringProto(...) should only receive byte strings, "
+                "got: %r" % (self.__class__.__name__, st))
             objects[nk] = self.fromStringProto(st, proto)
 
 
@@ -1299,7 +1357,11 @@ class Argument:
             # strings[name] = None
             pass
         else:
-            strings[name] = self.toStringProto(obj, proto)
+            value = self.toStringProto(obj, proto)
+            assert not isinstance(value, unicode), (
+                "%s.toStringProto(...) should not return Unicode strings, "
+                "got: %r" % (self.__class__.__name__, value))
+            strings[name] = value
 
 
     def fromStringProto(self, inString, proto):
@@ -1361,7 +1423,7 @@ class Integer(Argument):
     """
     fromString = int
     def toString(self, inObject):
-        return str(int(inObject))
+        return intToBytes(inObject)
 
 
 
@@ -1372,8 +1434,8 @@ class String(Argument):
     def toString(self, inObject):
         return inObject
 
-
     def fromString(self, inString):
+        assert isinstance(inString, bytes), repr(inString)
         return inString
 
 
@@ -1392,9 +1454,9 @@ class Boolean(Argument):
     Encode True or False as "True" or "False" on the wire.
     """
     def fromString(self, inString):
-        if inString == 'True':
+        if inString == b'True':
             return True
-        elif inString == 'False':
+        elif inString == b'False':
             return False
         else:
             raise TypeError("Bad boolean value: %r" % (inString,))
@@ -1402,9 +1464,9 @@ class Boolean(Argument):
 
     def toString(self, inObject):
         if inObject:
-            return 'True'
+            return b'True'
         else:
-            return 'False'
+            return b'False'
 
 
 
@@ -1414,12 +1476,12 @@ class Unicode(String):
     """
 
     def toString(self, inObject):
-        # assert isinstance(inObject, unicode)
+        assert isinstance(inObject, unicode), repr(inObject)
         return String.toString(self, inObject.encode('utf-8'))
 
 
     def fromString(self, inString):
-        # assert isinstance(inString, str)
+        assert isinstance(inString, bytes), repr(inString)
         return String.fromString(self, inString).decode('utf-8')
 
 
@@ -1438,7 +1500,7 @@ class Path(Unicode):
 
 
     def toString(self, inObject):
-        return Unicode.toString(self, inObject.path)
+        return Unicode.toString(self, inObject.asTextMode().path)
 
 
 
@@ -1483,7 +1545,8 @@ class ListOf(Argument):
         parser = Int16StringReceiver()
         parser.stringReceived = strings.append
         parser.dataReceived(inString)
-        return map(self.elementType.fromString, strings)
+        elementFromString = self.elementType.fromString
+        return [elementFromString(string) for string in strings]
 
 
     def toString(self, inObject):
@@ -1495,7 +1558,7 @@ class ListOf(Argument):
             serialized = self.elementType.toString(obj)
             strings.append(pack('!H', len(serialized)))
             strings.append(serialized)
-        return ''.join(strings)
+        return b''.join(strings)
 
 
 
@@ -1522,6 +1585,7 @@ class AmpList(Argument):
         @param optional: a boolean indicating whether this argument can be
         omitted in the protocol.
         """
+        assert all(isinstance(name, bytes) for name, _ in subargs), repr(subargs)
         self.subargs = subargs
         Argument.__init__(self, optional)
 
@@ -1534,7 +1598,7 @@ class AmpList(Argument):
 
 
     def toStringProto(self, inObject, proto):
-        return ''.join([_objectsToStrings(
+        return b''.join([_objectsToStrings(
                     objects, self.subargs, Box(), proto
                     ).serialize() for objects in inObject])
 
@@ -1656,18 +1720,55 @@ class Command:
             reverseErrors = attrs['reverseErrors'] = {}
             er = attrs['allErrors'] = {}
             if 'commandName' not in attrs:
-                attrs['commandName'] = name
+                if _PY3:
+                    attrs['commandName'] = name.encode("ascii")
+                else:
+                    attrs['commandName'] = name
             newtype = type.__new__(cls, name, bases, attrs)
+
+            if not isinstance(newtype.commandName, bytes):
+                raise TypeError(
+                    "Command names must be byte strings, got: %r"
+                    % (newtype.commandName, ))
+            for name, _ in newtype.arguments:
+                if not isinstance(name, bytes):
+                    raise TypeError(
+                        "Argument names must be byte strings, got: %r"
+                        % (name, ))
+            for name, _ in newtype.response:
+                if not isinstance(name, bytes):
+                    raise TypeError(
+                        "Response names must be byte strings, got: %r"
+                        % (name, ))
+
             errors = {}
             fatalErrors = {}
             accumulateClassDict(newtype, 'errors', errors)
             accumulateClassDict(newtype, 'fatalErrors', fatalErrors)
-            for v, k in errors.iteritems():
+
+            if not isinstance(newtype.errors, dict):
+                newtype.errors = dict(newtype.errors)
+            if not isinstance(newtype.fatalErrors, dict):
+                newtype.fatalErrors = dict(newtype.fatalErrors)
+
+            for v, k in iteritems(errors):
                 reverseErrors[k] = v
                 er[v] = k
-            for v, k in fatalErrors.iteritems():
+            for v, k in iteritems(fatalErrors):
                 reverseErrors[k] = v
                 er[v] = k
+
+            for _, name in iteritems(newtype.errors):
+                if not isinstance(name, bytes):
+                    raise TypeError(
+                        "Error names must be byte strings, got: %r"
+                        % (name, ))
+            for _, name in iteritems(newtype.fatalErrors):
+                if not isinstance(name, bytes):
+                    raise TypeError(
+                        "Fatal error names must be byte strings, got: %r"
+                        % (name, ))
+
             return newtype
 
     arguments = []
@@ -1693,15 +1794,14 @@ class Command:
         @raise InvalidSignature: if you forgot any required arguments.
         """
         self.structured = kw
-        givenArgs = kw.keys()
         forgotten = []
         for name, arg in self.arguments:
             pythonName = _wireNameToPythonIdentifier(name)
-            if pythonName not in givenArgs and not arg.optional:
+            if pythonName not in self.structured and not arg.optional:
                 forgotten.append(pythonName)
         if forgotten:
             raise InvalidSignature("forgot %s for %s" % (
-                    ', '.join(forgotten), self.commandName))
+                ', '.join(forgotten), self.commandName))
         forgotten = []
 
 
@@ -1850,6 +1950,12 @@ class Command:
 
 
 
+if _PY3:
+    # Apply __metaclass__ to Command.
+    Command = Command.__metaclass__("Command", (Command, ), {})
+
+
+
 class _NoCertificate:
     """
     This is for peers which don't want to use a local certificate.  Used by
@@ -1912,7 +2018,7 @@ class _TLSBox(AmpBox):
 
     def __init__(self):
         if ssl is None:
-            raise RemoteAmpError("TLS_ERROR", "TLS not available")
+            raise RemoteAmpError(b"TLS_ERROR", "TLS not available")
         AmpBox.__init__(self)
 
 
@@ -1921,16 +2027,16 @@ class _TLSBox(AmpBox):
 
 
     # These properties are described in startTLS
-    certificate = _keyprop('tls_localCertificate', _NoCertificate(False))
-    verify = _keyprop('tls_verifyAuthorities', None)
+    certificate = _keyprop(b'tls_localCertificate', _NoCertificate(False))
+    verify = _keyprop(b'tls_verifyAuthorities', None)
 
     def _sendTo(self, proto):
         """
         Send my encoded value to the protocol, then initiate TLS.
         """
         ab = AmpBox(self)
-        for k in ['tls_localCertificate',
-                  'tls_verifyAuthorities']:
+        for k in [b'tls_localCertificate',
+                  b'tls_verifyAuthorities']:
             ab.pop(k, None)
         ab._sendTo(proto)
         proto._startTLS(self.certificate, self.verify)
@@ -1968,11 +2074,11 @@ class StartTLS(Command):
     response dictionary.
     """
 
-    arguments = [("tls_localCertificate", _LocalArgument(optional=True)),
-                 ("tls_verifyAuthorities", _LocalArgument(optional=True))]
+    arguments = [(b"tls_localCertificate", _LocalArgument(optional=True)),
+                 (b"tls_verifyAuthorities", _LocalArgument(optional=True))]
 
-    response = [("tls_localCertificate", _LocalArgument(optional=True)),
-                ("tls_verifyAuthorities", _LocalArgument(optional=True))]
+    response = [(b"tls_localCertificate", _LocalArgument(optional=True)),
+                (b"tls_verifyAuthorities", _LocalArgument(optional=True))]
 
     responseType = _TLSBox
 
@@ -2062,6 +2168,7 @@ class ProtocolSwitchCommand(Command):
 
 
 
+@implementer(IFileDescriptorReceiver)
 class _DescriptorExchanger(object):
     """
     L{_DescriptorExchanger} is a mixin for L{BinaryBoxProtocol} which adds
@@ -2084,13 +2191,12 @@ class _DescriptorExchanger(object):
         ordinals, starting from 0.  This is used to construct values for
         C{fileDescriptorReceived}.
     """
-    implements(IFileDescriptorReceiver)
 
     def __init__(self):
         self._descriptors = {}
         self._getDescriptor = self._descriptors.pop
-        self._sendingDescriptorCounter = count().next
-        self._receivingDescriptorCounter = count().next
+        self._sendingDescriptorCounter = partial(next, count())
+        self._receivingDescriptorCounter = partial(next, count())
 
 
     def _sendFileDescriptor(self, descriptor):
@@ -2113,6 +2219,7 @@ class _DescriptorExchanger(object):
 
 
 
+@implementer(IBoxSender)
 class BinaryBoxProtocol(StatefulStringProtocol, Int16StringReceiver,
                         _DescriptorExchanger):
     """
@@ -2146,8 +2253,6 @@ class BinaryBoxProtocol(StatefulStringProtocol, Int16StringReceiver,
     method will be invoked for each L{AmpBox} that is received.
     """
 
-    implements(IBoxSender)
-
     _justStartedTLS = False
     _startingTLSBuffer = None
     _locked = False
@@ -2547,7 +2652,7 @@ class _ParserHelper:
 
         @return: a list of AmpBoxes encoded in the given string.
         """
-        return cls.parse(StringIO(data))
+        return cls.parse(BytesIO(data))
     parseString = classmethod(parseString)
 
 
@@ -2630,7 +2735,10 @@ class Decimal(Argument):
     U{http://speleotrove.com/decimal/} should be considered the authoritative
     specification for the format.
     """
-    fromString = decimal.Decimal
+
+    def fromString(self, inString):
+        inString = nativeString(inString)
+        return decimal.Decimal(inString)
 
     def toString(self, inObject):
         """
@@ -2638,7 +2746,7 @@ class Decimal(Argument):
         """
         if isinstance(inObject, decimal.Decimal):
             # Hopefully decimal.Decimal.__str__ actually does what we want.
-            return str(inObject)
+            return str(inObject).encode("ascii")
         raise ValueError(
             "amp.Decimal can only encode instances of decimal.Decimal")
 
@@ -2676,6 +2784,8 @@ class DateTime(Argument):
         Parse a string containing a date and time in the wire format into a
         C{datetime.datetime} instance.
         """
+        s = nativeString(s)
+
         if len(s) != 32:
             raise ValueError('invalid date format %r' % (s,))
 
@@ -2707,7 +2817,9 @@ class DateTime(Argument):
         # strftime has no way to format the microseconds, or put a ':' in the
         # timezone. Surprise!
 
-        return '%04i-%02i-%02iT%02i:%02i:%02i.%06i%s%02i:%02i' % (
+        # Python 3.4 cannot do % interpolation on byte strings so we pack into
+        # an explicitly Unicode string then encode as ASCII.
+        packed = u'%04i-%02i-%02iT%02i:%02i:%02i.%06i%s%02i:%02i' % (
             i.year,
             i.month,
             i.day,
@@ -2718,3 +2830,5 @@ class DateTime(Argument):
             sign,
             abs(minutesOffset) // 60,
             abs(minutesOffset) % 60)
+
+        return packed.encode("ascii")
diff --git a/twisted/python/dist3.py b/twisted/python/dist3.py
index c7a8e61..c65092b 100644
--- a/twisted/python/dist3.py
+++ b/twisted/python/dist3.py
@@ -138,6 +138,7 @@ modules = [
     "twisted.positioning.ipositioning",
     "twisted.positioning.nmea",
     "twisted.protocols",
+    "twisted.protocols.amp",
     "twisted.protocols.basic",
     "twisted.protocols.policies",
     "twisted.protocols.test",
@@ -311,6 +312,7 @@ testModules = [
     "twisted.python.test.test_versions",
     "twisted.python.test.test_zippath",
     "twisted.test.test_abstract",
+    "twisted.test.test_amp",
     "twisted.test.test_application",
     "twisted.test.test_compat",
     "twisted.test.test_context",
diff --git a/twisted/test/test_amp.py b/twisted/test/test_amp.py
index be389ee..3c58dc8 100644
--- a/twisted/test/test_amp.py
+++ b/twisted/test/test_amp.py
@@ -9,10 +9,11 @@ Tests for L{twisted.protocols.amp}.
 import datetime
 import decimal
 
-from zope.interface import implements
+from zope.interface import implementer
 from zope.interface.verify import verifyClass, verifyObject
 
 from twisted.python import filepath
+from twisted.python.compat import intToBytes
 from twisted.python.failure import Failure
 from twisted.protocols import amp
 from twisted.trial import unittest
@@ -53,6 +54,7 @@ class TestProto(protocol.Protocol):
     instanceCount = 0
 
     def __init__(self, onConnLost, dataToSend):
+        assert isinstance(dataToSend, bytes), repr(dataToSend)
         self.onConnLost = onConnLost
         self.dataToSend = dataToSend
         self.instanceId = TestProto.instanceCount
@@ -90,14 +92,14 @@ class SimpleSymmetricProtocol(amp.AMP):
 
     def sendHello(self, text):
         return self.callRemoteString(
-            "hello",
+            b"hello",
             hello=text)
 
     def amp_HELLO(self, box):
-        return amp.Box(hello=box['hello'])
+        return amp.Box(hello=box[b'hello'])
 
     def amp_HOWDOYOUDO(self, box):
-        return amp.QuitBox(howdoyoudo='world')
+        return amp.QuitBox(howdoyoudo=b'world')
 
 
 
@@ -118,7 +120,7 @@ class TransportPeer(amp.Argument):
     # this serves as some informal documentation for how to get variables from
     # the protocol or your environment and pass them to methods as arguments.
     def retrieve(self, d, name, proto):
-        return ''
+        return b''
 
     def fromStringProto(self, notAString, proto):
         return proto.transport.getPeer()
@@ -130,44 +132,44 @@ class TransportPeer(amp.Argument):
 
 class Hello(amp.Command):
 
-    commandName = 'hello'
+    commandName = b'hello'
 
-    arguments = [('hello', amp.String()),
-                 ('optional', amp.Boolean(optional=True)),
-                 ('print', amp.Unicode(optional=True)),
-                 ('from', TransportPeer(optional=True)),
-                 ('mixedCase', amp.String(optional=True)),
-                 ('dash-arg', amp.String(optional=True)),
-                 ('underscore_arg', amp.String(optional=True))]
+    arguments = [(b'hello', amp.String()),
+                 (b'optional', amp.Boolean(optional=True)),
+                 (b'print', amp.Unicode(optional=True)),
+                 (b'from', TransportPeer(optional=True)),
+                 (b'mixedCase', amp.String(optional=True)),
+                 (b'dash-arg', amp.String(optional=True)),
+                 (b'underscore_arg', amp.String(optional=True))]
 
-    response = [('hello', amp.String()),
-                ('print', amp.Unicode(optional=True))]
+    response = [(b'hello', amp.String()),
+                (b'print', amp.Unicode(optional=True))]
 
-    errors = {UnfriendlyGreeting: 'UNFRIENDLY'}
+    errors = {UnfriendlyGreeting: b'UNFRIENDLY'}
 
-    fatalErrors = {DeathThreat: 'DEAD'}
+    fatalErrors = {DeathThreat: b'DEAD'}
 
 class NoAnswerHello(Hello):
     commandName = Hello.commandName
     requiresAnswer = False
 
 class FutureHello(amp.Command):
-    commandName = 'hello'
-
-    arguments = [('hello', amp.String()),
-                 ('optional', amp.Boolean(optional=True)),
-                 ('print', amp.Unicode(optional=True)),
-                 ('from', TransportPeer(optional=True)),
-                 ('bonus', amp.String(optional=True)), # addt'l arguments
-                                                       # should generally be
-                                                       # added at the end, and
-                                                       # be optional...
+    commandName = b'hello'
+
+    arguments = [(b'hello', amp.String()),
+                 (b'optional', amp.Boolean(optional=True)),
+                 (b'print', amp.Unicode(optional=True)),
+                 (b'from', TransportPeer(optional=True)),
+                 (b'bonus', amp.String(optional=True)), # addt'l arguments
+                                                        # should generally be
+                                                        # added at the end, and
+                                                        # be optional...
                  ]
 
-    response = [('hello', amp.String()),
-                ('print', amp.Unicode(optional=True))]
+    response = [(b'hello', amp.String()),
+                (b'print', amp.Unicode(optional=True))]
 
-    errors = {UnfriendlyGreeting: 'UNFRIENDLY'}
+    errors = {UnfriendlyGreeting: b'UNFRIENDLY'}
 
 class WTF(amp.Command):
     """
@@ -180,44 +182,44 @@ class BrokenReturn(amp.Command):
     None...
     """
 
-    commandName = 'broken_return'
+    commandName = b'broken_return'
 
 class Goodbye(amp.Command):
     # commandName left blank on purpose: this tests implicit command names.
-    response = [('goodbye', amp.String())]
+    response = [(b'goodbye', amp.String())]
     responseType = amp.QuitBox
 
 class Howdoyoudo(amp.Command):
-    commandName = 'howdoyoudo'
+    commandName = b'howdoyoudo'
     # responseType = amp.QuitBox
 
 class WaitForever(amp.Command):
-    commandName = 'wait_forever'
+    commandName = b'wait_forever'
 
 class GetList(amp.Command):
-    commandName = 'getlist'
-    arguments = [('length', amp.Integer())]
-    response = [('body', amp.AmpList([('x', amp.Integer())]))]
+    commandName = b'getlist'
+    arguments = [(b'length', amp.Integer())]
+    response = [(b'body', amp.AmpList([(b'x', amp.Integer())]))]
 
 class DontRejectMe(amp.Command):
-    commandName = 'dontrejectme'
+    commandName = b'dontrejectme'
     arguments = [
-            ('magicWord', amp.Unicode()),
-            ('list', amp.AmpList([('name', amp.Unicode())], optional=True)),
+            (b'magicWord', amp.Unicode()),
+            (b'list', amp.AmpList([(b'name', amp.Unicode())], optional=True)),
             ]
-    response = [('response', amp.Unicode())]
+    response = [(b'response', amp.Unicode())]
 
 class SecuredPing(amp.Command):
     # XXX TODO: actually make this refuse to send over an insecure connection
-    response = [('pinged', amp.Boolean())]
+    response = [(b'pinged', amp.Boolean())]
 
 class TestSwitchProto(amp.ProtocolSwitchCommand):
-    commandName = 'Switch-Proto'
+    commandName = b'Switch-Proto'
 
     arguments = [
-        ('name', amp.String()),
+        (b'name', amp.String()),
         ]
-    errors = {UnknownProtocol: 'UNKNOWN'}
+    errors = {UnknownProtocol: b'UNKNOWN'}
 
 class SingleUseFactory(protocol.ClientFactory):
     def __init__(self, proto):
@@ -234,7 +236,7 @@ class SingleUseFactory(protocol.ClientFactory):
         self.reasonFailed = reason
         return
 
-THING_I_DONT_UNDERSTAND = 'gwebol nargo'
+THING_I_DONT_UNDERSTAND = b'gwebol nargo'
 class ThingIDontUnderstandError(Exception):
     pass
 
@@ -273,9 +275,9 @@ class SimpleSymmetricCommandProtocol(FactoryNotifier):
         assert From == self.transport.getPeer()
         if hello == THING_I_DONT_UNDERSTAND:
             raise ThingIDontUnderstandError()
-        if hello.startswith('fuck'):
+        if hello.startswith(b'fuck'):
             raise UnfriendlyGreeting("Don't be a dick.")
-        if hello == 'die':
+        if hello == b'die':
             raise DeathThreat("aieeeeeeeee")
         result = dict(hello=hello)
         if Print is not None:
@@ -302,25 +304,25 @@ class SimpleSymmetricCommandProtocol(FactoryNotifier):
     WaitForever.responder(waitforit)
 
     def howdo(self):
-        return dict(howdoyoudo='world')
+        return dict(howdoyoudo=b'world')
     Howdoyoudo.responder(howdo)
 
     def saybye(self):
-        return dict(goodbye="everyone")
+        return dict(goodbye=b"everyone")
     Goodbye.responder(saybye)
 
     def switchToTestProtocol(self, fail=False):
         if fail:
-            name = 'no-proto'
+            name = b'no-proto'
         else:
-            name = 'test-proto'
+            name = b'test-proto'
         p = TestProto(self.onConnLost, SWITCH_CLIENT_DATA)
         return self.callRemote(
             TestSwitchProto,
             SingleUseFactory(p), name=name).addCallback(lambda ign: p)
 
     def switchit(self, name):
-        if name == 'test-proto':
+        if name == b'test-proto':
             return TestProto(self.onConnLost, SWITCH_SERVER_DATA)
         raise UnknownProtocol(name)
     TestSwitchProto.responder(switchit)
@@ -332,7 +334,7 @@ class SimpleSymmetricCommandProtocol(FactoryNotifier):
 
 class DeferredSymmetricCommandProtocol(SimpleSymmetricCommandProtocol):
     def switchit(self, name):
-        if name == 'test-proto':
+        if name == b'test-proto':
             self.maybeLaterProto = TestProto(self.onConnLost, SWITCH_SERVER_DATA)
             self.maybeLater = defer.Deferred()
             return self.maybeLater
@@ -350,7 +352,7 @@ class BadNoAnswerCommandProtocol(SimpleSymmetricCommandProtocol):
 class NoAnswerCommandProtocol(SimpleSymmetricCommandProtocol):
     def goodNoAnswerResponder(self, hello, From, optional=None, Print=None,
                               mixedCase=None, dash_arg=None, underscore_arg=None):
-        return dict(hello=hello+"-noanswer")
+        return dict(hello=hello+b"-noanswer")
     NoAnswerHello.responder(goodNoAnswerResponder)
 
 def connectedServerAndClient(ServerClass=SimpleSymmetricProtocol,
@@ -363,7 +365,7 @@ def connectedServerAndClient(ServerClass=SimpleSymmetricProtocol,
         *a, **kw)
 
 class TotallyDumbProtocol(protocol.Protocol):
-    buf = ''
+    buf = b''
     def dataReceived(self, data):
         self.buf += data
 
@@ -387,8 +389,8 @@ class AmpBoxTests(unittest.TestCase):
         """
         Make sure that strs serialize to strs.
         """
-        a = amp.AmpBox(key='value')
-        self.assertEqual(type(a.serialize()), str)
+        a = amp.AmpBox(key=b'value')
+        self.assertEqual(type(a.serialize()), bytes)
 
     def test_serializeUnicodeKeyRaises(self):
         """
@@ -415,13 +417,13 @@ class ParsingTests(unittest.TestCase):
         else.
         """
         b = amp.Boolean()
-        self.assertEqual(b.fromString("True"), True)
-        self.assertEqual(b.fromString("False"), False)
-        self.assertRaises(TypeError, b.fromString, "ninja")
-        self.assertRaises(TypeError, b.fromString, "true")
-        self.assertRaises(TypeError, b.fromString, "TRUE")
-        self.assertEqual(b.toString(True), 'True')
-        self.assertEqual(b.toString(False), 'False')
+        self.assertEqual(b.fromString(b"True"), True)
+        self.assertEqual(b.fromString(b"False"), False)
+        self.assertRaises(TypeError, b.fromString, b"ninja")
+        self.assertRaises(TypeError, b.fromString, b"true")
+        self.assertRaises(TypeError, b.fromString, b"TRUE")
+        self.assertEqual(b.toString(True), b'True')
+        self.assertEqual(b.toString(False), b'False')
 
     def test_pathValueRoundTrip(self):
         """
@@ -452,13 +454,13 @@ class ParsingTests(unittest.TestCase):
         c, s, p = connectedServerAndClient(ClientClass=LiteralAmp,
                                            ServerClass=LiteralAmp)
 
-        SIMPLE = ('simple', 'test')
-        CE = ('ceq', ': ')
-        CR = ('crtest', 'test\r')
-        LF = ('lftest', 'hello\n')
-        NEWLINE = ('newline', 'test\r\none\r\ntwo')
-        NEWLINE2 = ('newline2', 'test\r\none\r\n two')
-        BODYTEST = ('body', 'blah\r\n\r\ntesttest')
+        SIMPLE = (b'simple', b'test')
+        CE = (b'ceq', b': ')
+        CR = (b'crtest', b'test\r')
+        LF = (b'lftest', b'hello\n')
+        NEWLINE = (b'newline', b'test\r\none\r\ntwo')
+        NEWLINE2 = (b'newline2', b'test\r\none\r\n two')
+        BODYTEST = (b'body', b'blah\r\n\r\ntesttest')
 
         testData = [
             [SIMPLE],
@@ -621,19 +623,19 @@ class CommandDispatchTests(unittest.TestCase):
         fired, and the results translated via the given L{Command}'s response
         de-serialization.
         """
-        D = self.dispatcher.callRemote(Hello, hello='world')
+        D = self.dispatcher.callRemote(Hello, hello=b'world')
         self.assertEqual(self.sender.sentBoxes,
-                          [amp.AmpBox(_command="hello",
-                                      _ask="1",
-                                      hello="world")])
+                          [amp.AmpBox(_command=b"hello",
+                                      _ask=b"1",
+                                      hello=b"world")])
         answers = []
         D.addCallback(answers.append)
         self.assertEqual(answers, [])
-        self.dispatcher.ampBoxReceived(amp.AmpBox({'hello': "yay",
-                                                   'print': "ignored",
-                                                   '_answer': "1"}))
-        self.assertEqual(answers, [dict(hello="yay",
-                                         Print=u"ignored")])
+        self.dispatcher.ampBoxReceived(amp.AmpBox({b'hello': b"yay",
+                                                   b'print': b"ignored",
+                                                   b'_answer': b"1"}))
+        self.assertEqual(answers, [dict(hello=b"yay",
+                                         Print="ignored")])
 
 
     def _localCallbackErrorLoggingTest(self, callResult):
@@ -659,11 +661,11 @@ class CommandDispatchTests(unittest.TestCase):
         """
         self.sender.expectError()
 
-        callResult = self.dispatcher.callRemote(Hello, hello='world')
+        callResult = self.dispatcher.callRemote(Hello, hello=b'world')
         callResult.addCallback(lambda result: 1 // 0)
 
         self.dispatcher.ampBoxReceived(amp.AmpBox({
-                    'hello': "yay", 'print': "ignored", '_answer': "1"}))
+                    b'hello': b"yay", b'print': b"ignored", b'_answer': b"1"}))
 
         self._localCallbackErrorLoggingTest(callResult)
 
@@ -675,12 +677,12 @@ class CommandDispatchTests(unittest.TestCase):
         """
         self.sender.expectError()
 
-        callResult = self.dispatcher.callRemote(Hello, hello='world')
+        callResult = self.dispatcher.callRemote(Hello, hello=b'world')
         callResult.addErrback(lambda result: 1 // 0)
 
         self.dispatcher.ampBoxReceived(amp.AmpBox({
-                    '_error': '1', '_error_code': 'bugs',
-                    '_error_description': 'stuff'}))
+                    b'_error': b'1', b'_error_code': b'bugs',
+                    b'_error_description': b'stuff'}))
 
         self._localCallbackErrorLoggingTest(callResult)
 
@@ -690,10 +692,10 @@ class SimpleGreeting(amp.Command):
     """
     A very simple greeting command that uses a few basic argument types.
     """
-    commandName = 'simple'
-    arguments = [('greeting', amp.Unicode()),
-                 ('cookie', amp.Integer())]
-    response = [('cookieplus', amp.Integer())]
+    commandName = b'simple'
+    arguments = [(b'greeting', amp.Unicode()),
+                 (b'cookie', amp.Integer())]
+    response = [(b'cookieplus', amp.Integer())]
 
 
 
@@ -738,7 +740,7 @@ class OverrideLocatorAMP(amp.AMP):
     def __init__(self):
         amp.AMP.__init__(self)
         self.customResponder = object()
-        self.expectations = {"custom": self.customResponder}
+        self.expectations = {b"custom": self.customResponder}
         self.greetings = []
 
 
@@ -775,10 +777,10 @@ class CommandLocatorTests(unittest.TestCase):
         command.
         """
         locator = locatorClass()
-        responderCallable = locator.locateResponder("simple")
-        result = responderCallable(amp.Box(greeting="ni hao", cookie="5"))
+        responderCallable = locator.locateResponder(b"simple")
+        result = responderCallable(amp.Box(greeting=b"ni hao", cookie=b"5"))
         def done(values):
-            self.assertEqual(values, amp.AmpBox(cookieplus=str(expected)))
+            self.assertEqual(values, amp.AmpBox(cookieplus=intToBytes(expected)))
         return result.addCallback(done)
 
 
@@ -820,16 +822,16 @@ class CommandLocatorTests(unittest.TestCase):
         customResponderObject = self.assertWarns(
             PendingDeprecationWarning,
             "Override locateResponder, not lookupFunction.",
-            __file__, lambda : locator.locateResponder("custom"))
+            __file__, lambda : locator.locateResponder(b"custom"))
         self.assertEqual(locator.customResponder, customResponderObject)
         # Make sure upcalling works too
         normalResponderObject = self.assertWarns(
             PendingDeprecationWarning,
             "Override locateResponder, not lookupFunction.",
-            __file__, lambda : locator.locateResponder("simple"))
-        result = normalResponderObject(amp.Box(greeting="ni hao", cookie="5"))
+            __file__, lambda : locator.locateResponder(b"simple"))
+        result = normalResponderObject(amp.Box(greeting=b"ni hao", cookie=b"5"))
         def done(values):
-            self.assertEqual(values, amp.AmpBox(cookieplus='8'))
+            self.assertEqual(values, amp.AmpBox(cookieplus=b'8'))
         return result.addCallback(done)
 
 
@@ -842,16 +844,16 @@ class CommandLocatorTests(unittest.TestCase):
         responderCallable = self.assertWarns(
             PendingDeprecationWarning,
             "Call locateResponder, not lookupFunction.", __file__,
-            lambda : locator.lookupFunction("simple"))
-        result = responderCallable(amp.Box(greeting="ni hao", cookie="5"))
+            lambda : locator.lookupFunction(b"simple"))
+        result = responderCallable(amp.Box(greeting=b"ni hao", cookie=b"5"))
         def done(values):
-            self.assertEqual(values, amp.AmpBox(cookieplus='8'))
+            self.assertEqual(values, amp.AmpBox(cookieplus=b'8'))
         return result.addCallback(done)
 
 
 
-SWITCH_CLIENT_DATA = 'Success!'
-SWITCH_SERVER_DATA = 'No, really.  Success.'
+SWITCH_CLIENT_DATA = b'Success!'
+SWITCH_SERVER_DATA = b'No, really.  Success.'
 
 
 class BinaryProtocolTests(unittest.TestCase):
@@ -903,6 +905,7 @@ class BinaryProtocolTests(unittest.TestCase):
 
 
     def write(self, data):
+        self.assertIsInstance(data, bytes)
         self.data.append(data)
 
 
@@ -926,14 +929,14 @@ class BinaryProtocolTests(unittest.TestCase):
         """
         class SynchronouslySendingReceiver:
             def startReceivingBoxes(self, sender):
-                sender.sendBox(amp.Box({'foo': 'bar'}))
+                sender.sendBox(amp.Box({b'foo': b'bar'}))
 
         transport = StringTransport()
         protocol = amp.BinaryBoxProtocol(SynchronouslySendingReceiver())
         protocol.makeConnection(transport)
         self.assertEqual(
             transport.value(),
-            '\x00\x03foo\x00\x03bar\x00\x00')
+            b'\x00\x03foo\x00\x03bar\x00\x00')
 
 
     def test_receiveBoxStateMachine(self):
@@ -945,10 +948,10 @@ class BinaryProtocolTests(unittest.TestCase):
         it should emit a box and send it to its boxReceiver.
         """
         a = amp.BinaryBoxProtocol(self)
-        a.stringReceived("hello")
-        a.stringReceived("world")
-        a.stringReceived("")
-        self.assertEqual(self.boxes, [amp.AmpBox(hello="world")])
+        a.stringReceived(b"hello")
+        a.stringReceived(b"world")
+        a.stringReceived(b"")
+        self.assertEqual(self.boxes, [amp.AmpBox(hello=b"world")])
 
 
     def test_firstBoxFirstKeyExcessiveLength(self):
@@ -959,7 +962,7 @@ class BinaryProtocolTests(unittest.TestCase):
         transport = StringTransport()
         protocol = amp.BinaryBoxProtocol(self)
         protocol.makeConnection(transport)
-        protocol.dataReceived('\x01\x00')
+        protocol.dataReceived(b'\x01\x00')
         self.assertTrue(transport.disconnecting)
 
 
@@ -971,9 +974,9 @@ class BinaryProtocolTests(unittest.TestCase):
         transport = StringTransport()
         protocol = amp.BinaryBoxProtocol(self)
         protocol.makeConnection(transport)
-        protocol.dataReceived('\x00\x01k\x00\x01v')
+        protocol.dataReceived(b'\x00\x01k\x00\x01v')
         self.assertFalse(transport.disconnecting)
-        protocol.dataReceived('\x01\x00')
+        protocol.dataReceived(b'\x01\x00')
         self.assertTrue(transport.disconnecting)
 
 
@@ -985,9 +988,9 @@ class BinaryProtocolTests(unittest.TestCase):
         transport = StringTransport()
         protocol = amp.BinaryBoxProtocol(self)
         protocol.makeConnection(transport)
-        protocol.dataReceived('\x00\x01k\x00\x01v\x00\x00')
+        protocol.dataReceived(b'\x00\x01k\x00\x01v\x00\x00')
         self.assertFalse(transport.disconnecting)
-        protocol.dataReceived('\x01\x00')
+        protocol.dataReceived(b'\x01\x00')
         self.assertTrue(transport.disconnecting)
 
 
@@ -999,7 +1002,7 @@ class BinaryProtocolTests(unittest.TestCase):
         """
         protocol = amp.BinaryBoxProtocol(self)
         protocol.makeConnection(StringTransport())
-        protocol.dataReceived('\x01\x00')
+        protocol.dataReceived(b'\x01\x00')
         protocol.connectionLost(
             Failure(error.ConnectionDone("simulated connection done")))
         self.stopReason.trap(amp.TooLong)
@@ -1040,11 +1043,11 @@ class BinaryProtocolTests(unittest.TestCase):
         it should emit a similar box to its boxReceiver.
         """
         a = amp.BinaryBoxProtocol(self)
-        a.dataReceived(amp.Box({"testKey": "valueTest",
-                                "anotherKey": "anotherValue"}).serialize())
+        a.dataReceived(amp.Box({b"testKey": b"valueTest",
+                                b"anotherKey": b"anotherValue"}).serialize())
         self.assertEqual(self.boxes,
-                          [amp.Box({"testKey": "valueTest",
-                                    "anotherKey": "anotherValue"})])
+                          [amp.Box({b"testKey": b"valueTest",
+                                    b"anotherKey": b"anotherValue"})])
 
 
     def test_receiveLongerBoxData(self):
@@ -1053,7 +1056,7 @@ class BinaryProtocolTests(unittest.TestCase):
         values of up to (2 ** 16 - 1) bytes.
         """
         length = (2 ** 16 - 1)
-        value = 'x' * length
+        value = b'x' * length
         transport = StringTransport()
         protocol = amp.BinaryBoxProtocol(self)
         protocol.makeConnection(transport)
@@ -1069,11 +1072,11 @@ class BinaryProtocolTests(unittest.TestCase):
         """
         a = amp.BinaryBoxProtocol(self)
         a.makeConnection(self)
-        aBox = amp.Box({"testKey": "valueTest",
-                        "someData": "hello"})
+        aBox = amp.Box({b"testKey": b"valueTest",
+                        b"someData": b"hello"})
         a.makeConnection(self)
         a.sendBox(aBox)
-        self.assertEqual(''.join(self.data), aBox.serialize())
+        self.assertEqual(b''.join(self.data), aBox.serialize())
 
 
     def test_connectionLostStopSendingBoxes(self):
@@ -1094,7 +1097,7 @@ class BinaryProtocolTests(unittest.TestCase):
         on a box boundary.  When a protocol is in the process of switching, it
         cannot receive traffic.
         """
-        otherProto = TestProto(None, "outgoing data")
+        otherProto = TestProto(None, b"outgoing data")
         test = self
         class SwitchyReceiver:
             switched = False
@@ -1107,20 +1110,20 @@ class BinaryProtocolTests(unittest.TestCase):
                 a._lockForSwitch()
                 a._switchTo(otherProto)
         a = amp.BinaryBoxProtocol(SwitchyReceiver())
-        anyOldBox = amp.Box({"include": "lots",
-                             "of": "data"})
+        anyOldBox = amp.Box({b"include": b"lots",
+                             b"of": b"data"})
         a.makeConnection(self)
         # Include a 0-length box at the beginning of the next protocol's data,
         # to make sure that AMP doesn't eat the data or try to deliver extra
         # boxes either...
-        moreThanOneBox = anyOldBox.serialize() + "\x00\x00Hello, world!"
+        moreThanOneBox = anyOldBox.serialize() + b"\x00\x00Hello, world!"
         a.dataReceived(moreThanOneBox)
         self.assertIdentical(otherProto.transport, self)
-        self.assertEqual("".join(otherProto.data), "\x00\x00Hello, world!")
-        self.assertEqual(self.data, ["outgoing data"])
-        a.dataReceived("more data")
-        self.assertEqual("".join(otherProto.data),
-                          "\x00\x00Hello, world!more data")
+        self.assertEqual(b"".join(otherProto.data), b"\x00\x00Hello, world!")
+        self.assertEqual(self.data, [b"outgoing data"])
+        a.dataReceived(b"more data")
+        self.assertEqual(b"".join(otherProto.data),
+                          b"\x00\x00Hello, world!more data")
         self.assertRaises(amp.ProtocolSwitched, a.sendBox, anyOldBox)
 
 
@@ -1132,7 +1135,7 @@ class BinaryProtocolTests(unittest.TestCase):
         """
         a = amp.BinaryBoxProtocol(self)
         a.makeConnection(self)
-        otherProto = TestProto(None, "")
+        otherProto = TestProto(None, b"")
         a._switchTo(otherProto)
         self.assertEqual(otherProto.data, [])
 
@@ -1146,14 +1149,14 @@ class BinaryProtocolTests(unittest.TestCase):
         """
         a = amp.BinaryBoxProtocol(self)
         a.makeConnection(self)
-        sampleBox = amp.Box({"some": "data"})
+        sampleBox = amp.Box({b"some": b"data"})
         a._lockForSwitch()
         self.assertRaises(amp.ProtocolSwitched, a.sendBox, sampleBox)
         a._unlockFromSwitch()
         a.sendBox(sampleBox)
-        self.assertEqual(''.join(self.data), sampleBox.serialize())
+        self.assertEqual(b''.join(self.data), sampleBox.serialize())
         a._lockForSwitch()
-        otherProto = TestProto(None, "outgoing data")
+        otherProto = TestProto(None, b"outgoing data")
         a._switchTo(otherProto)
         self.assertRaises(amp.ProtocolSwitched, a._unlockFromSwitch)
 
@@ -1223,10 +1226,10 @@ class AMPTests(unittest.TestCase):
         """
         c, s, p = connectedServerAndClient()
         L = []
-        HELLO = 'world'
+        HELLO = b'world'
         c.sendHello(HELLO).addCallback(L.append)
         p.flush()
-        self.assertEqual(L[0]['hello'], HELLO)
+        self.assertEqual(L[0][b'hello'], HELLO)
 
 
     def test_wireFormatRoundTrip(self):
@@ -1236,10 +1239,10 @@ class AMPTests(unittest.TestCase):
         """
         c, s, p = connectedServerAndClient()
         L = []
-        HELLO = 'world'
+        HELLO = b'world'
         c.sendHello(HELLO).addCallback(L.append)
         p.flush()
-        self.assertEqual(L[0]['hello'], HELLO)
+        self.assertEqual(L[0][b'hello'], HELLO)
 
 
     def test_helloWorldUnicode(self):
@@ -1250,8 +1253,8 @@ class AMPTests(unittest.TestCase):
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
         L = []
-        HELLO = 'world'
-        HELLO_UNICODE = 'wor\u1234ld'
+        HELLO = b'world'
+        HELLO_UNICODE = u'wor\u1234ld'
         c.sendUnicodeHello(HELLO, HELLO_UNICODE).addCallback(L.append)
         p.flush()
         self.assertEqual(L[0]['hello'], HELLO)
@@ -1264,7 +1267,7 @@ class AMPTests(unittest.TestCase):
         is C{False}.
         """
         c, s, p = connectedServerAndClient()
-        ret = c.callRemoteString("WTF", requiresAnswer=False)
+        ret = c.callRemoteString(b"WTF", requiresAnswer=False)
         self.assertIdentical(ret, None)
 
 
@@ -1281,13 +1284,13 @@ class AMPTests(unittest.TestCase):
             """
             e.trap(amp.UnhandledCommand)
             return "OK"
-        c.callRemoteString("WTF").addErrback(clearAndAdd).addCallback(L.append)
+        c.callRemoteString(b"WTF").addErrback(clearAndAdd).addCallback(L.append)
         p.flush()
         self.assertEqual(L.pop(), "OK")
-        HELLO = 'world'
+        HELLO = b'world'
         c.sendHello(HELLO).addCallback(L.append)
         p.flush()
-        self.assertEqual(L[0]['hello'], HELLO)
+        self.assertEqual(L[0][b'hello'], HELLO)
 
 
     def test_unknownCommandHigh(self):
@@ -1306,10 +1309,10 @@ class AMPTests(unittest.TestCase):
         c.callRemote(WTF).addErrback(clearAndAdd).addCallback(L.append)
         p.flush()
         self.assertEqual(L.pop(), "OK")
-        HELLO = 'world'
+        HELLO = b'world'
         c.sendHello(HELLO).addCallback(L.append)
         p.flush()
-        self.assertEqual(L[0]['hello'], HELLO)
+        self.assertEqual(L[0][b'hello'], HELLO)
 
 
     def test_brokenReturnValue(self):
@@ -1336,11 +1339,11 @@ class AMPTests(unittest.TestCase):
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
         L = []
-        HELLO = 'world'
+        HELLO = b'world'
         # c.sendHello(HELLO).addCallback(L.append)
         c.callRemote(FutureHello,
                      hello=HELLO,
-                     bonus="I'm not in the book!").addCallback(
+                     bonus=b"I'm not in the book!").addCallback(
             L.append)
         p.flush()
         self.assertEqual(L[0]['hello'], HELLO)
@@ -1360,7 +1363,7 @@ class AMPTests(unittest.TestCase):
         """
         Verify that L{AMP} objects output their innerProtocol when set.
         """
-        otherProto = TestProto(None, "outgoing data")
+        otherProto = TestProto(None, b"outgoing data")
         a = amp.AMP()
         a.innerProtocol = otherProto
 
@@ -1395,12 +1398,12 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient()
         x = "H" * (0xff+1)
         tl = self.assertRaises(amp.TooLong,
-                               c.callRemoteString, "Hello",
-                               **{x: "hi"})
+                               c.callRemoteString, b"Hello",
+                               **{x: b"hi"})
         self.assertTrue(tl.isKey)
         self.assertTrue(tl.isLocal)
         self.assertIdentical(tl.keyName, None)
-        self.assertEqual(tl.value, x)
+        self.assertEqual(tl.value, x.encode("ascii"))
         self.assertIn(str(len(x)), repr(tl))
         self.assertIn("key", repr(tl))
 
@@ -1411,12 +1414,12 @@ class AMPTests(unittest.TestCase):
         raise an exception.
         """
         c, s, p = connectedServerAndClient()
-        x = "H" * (0xffff+1)
+        x = b"H" * (0xffff+1)
         tl = self.assertRaises(amp.TooLong, c.sendHello, x)
         p.flush()
         self.assertFalse(tl.isKey)
         self.assertTrue(tl.isLocal)
-        self.assertEqual(tl.keyName, 'hello')
+        self.assertEqual(tl.keyName, b'hello')
         self.failUnlessIdentical(tl.value, x)
         self.assertTrue(str(len(x)) in repr(tl))
         self.assertTrue("value" in repr(tl))
@@ -1432,7 +1435,7 @@ class AMPTests(unittest.TestCase):
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
         L = []
-        HELLO = 'world'
+        HELLO = b'world'
         c.sendHello(HELLO).addCallback(L.append)
         p.flush()
         self.assertEqual(L[0]['hello'], HELLO)
@@ -1448,7 +1451,7 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient(
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
-        HELLO = 'fuck you'
+        HELLO = b'fuck you'
         c.sendHello(HELLO).addErrback(L.append)
         p.flush()
         L[0].trap(UnfriendlyGreeting)
@@ -1466,7 +1469,7 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient(
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
-        HELLO = 'die'
+        HELLO = b'die'
         c.sendHello(HELLO).addErrback(L.append)
         p.flush()
         L.pop().trap(DeathThreat)
@@ -1526,7 +1529,7 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient(
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
-        HELLO = 'world'
+        HELLO = b'world'
         c.callRemote(NoAnswerHello, hello=HELLO)
         p.flush()
         self.assertTrue(s.greeted)
@@ -1540,12 +1543,12 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient(
             ServerClass=SimpleSymmetricCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
-        HELLO = 'fuck you'
+        HELLO = b'fuck you'
         c.callRemote(NoAnswerHello, hello=HELLO)
         p.flush()
         # This should be logged locally.
         self.assertTrue(self.flushLoggedErrors(amp.RemoteAmpError))
-        HELLO = 'world'
+        HELLO = b'world'
         c.callRemote(Hello, hello=HELLO).addErrback(L.append)
         p.flush()
         L.pop().trap(error.ConnectionDone)
@@ -1564,7 +1567,7 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient(
             ServerClass=BadNoAnswerCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
-        c.callRemote(NoAnswerHello, hello="hello")
+        c.callRemote(NoAnswerHello, hello=b"hello")
         p.flush()
         le = self.flushLoggedErrors(amp.BadLocalReturn)
         self.assertEqual(len(le), 1)
@@ -1580,10 +1583,10 @@ class AMPTests(unittest.TestCase):
             ServerClass=NoAnswerCommandProtocol,
             ClientClass=SimpleSymmetricCommandProtocol)
         L = []
-        c.callRemote(Hello, hello="Hello!").addCallback(L.append)
+        c.callRemote(Hello, hello=b"Hello!").addCallback(L.append)
         p.flush()
         self.assertEqual(len(L), 1)
-        self.assertEqual(L, [dict(hello="Hello!-noanswer",
+        self.assertEqual(L, [dict(hello=b"Hello!-noanswer",
                                    Print=None)])  # Optional response argument
 
 
@@ -1625,7 +1628,7 @@ class AMPTests(unittest.TestCase):
             ClientClass=SimpleSymmetricCommandProtocol)
         L = []
         c.callRemote(DontRejectMe, magicWord=u'please',
-                list=[{'name': 'foo'}]).addCallback(L.append)
+                list=[{'name': u'foo'}]).addCallback(L.append)
         p.flush()
         response = L.pop().get('response')
         self.assertEqual(response, 'foo accepted')
@@ -1680,14 +1683,14 @@ class AMPTests(unittest.TestCase):
             c.callRemote(WaitForever).addErrback(wfdr.append)
         switchDeferred = c.switchToTestProtocol()
         if spuriousTraffic:
-            self.assertRaises(amp.ProtocolSwitched, c.sendHello, 'world')
+            self.assertRaises(amp.ProtocolSwitched, c.sendHello, b'world')
 
-        def cbConnsLost(((serverSuccess, serverData),
-                         (clientSuccess, clientData))):
+        def cbConnsLost(info):
+            ((serverSuccess, serverData), (clientSuccess, clientData)) = info
             self.assertTrue(serverSuccess)
             self.assertTrue(clientSuccess)
-            self.assertEqual(''.join(serverData), SWITCH_CLIENT_DATA)
-            self.assertEqual(''.join(clientData), SWITCH_SERVER_DATA)
+            self.assertEqual(b''.join(serverData), SWITCH_CLIENT_DATA)
+            self.assertEqual(b''.join(clientData), SWITCH_SERVER_DATA)
             self.testSucceeded = True
 
         def cbSwitch(proto):
@@ -1742,9 +1745,9 @@ class AMPTests(unittest.TestCase):
         self.assertFalse(self.testSucceeded)
         # It's a known error, so let's send a "hello" on the same connection;
         # it should work.
-        c.sendHello('world').addCallback(L.append)
+        c.sendHello(b'world').addCallback(L.append)
         p.flush()
-        self.assertEqual(L.pop()['hello'], 'world')
+        self.assertEqual(L.pop()['hello'], b'world')
 
 
     def test_trafficAfterSwitch(self):
@@ -1774,8 +1777,8 @@ class AMPTests(unittest.TestCase):
             ClientClass=SimpleSymmetricCommandProtocol)
 
         L = []
-        HELLO = 'world'
-        GOODBYE = 'everyone'
+        HELLO = b'world'
+        GOODBYE = b'everyone'
         c.sendHello(HELLO).addCallback(L.append)
         p.flush()
         self.assertEqual(L.pop()['hello'], HELLO)
@@ -1794,17 +1797,17 @@ class AMPTests(unittest.TestCase):
         c, s, p = connectedServerAndClient()
         L = []
         s.ampBoxReceived = L.append
-        c.callRemote(Hello, hello='hello test', mixedCase='mixed case arg test',
-                     dash_arg='x', underscore_arg='y')
+        c.callRemote(Hello, hello=b'hello test', mixedCase=b'mixed case arg test',
+                     dash_arg=b'x', underscore_arg=b'y')
         p.flush()
         self.assertEqual(len(L), 1)
-        for k, v in [('_command', Hello.commandName),
-                     ('hello', 'hello test'),
-                     ('mixedCase', 'mixed case arg test'),
-                     ('dash-arg', 'x'),
-                     ('underscore_arg', 'y')]:
+        for k, v in [(b'_command', Hello.commandName),
+                     (b'hello', b'hello test'),
+                     (b'mixedCase', b'mixed case arg test'),
+                     (b'dash-arg', b'x'),
+                     (b'underscore_arg', b'y')]:
             self.assertEqual(L[-1].pop(k), v)
-        L[-1].pop('_ask')
+        L[-1].pop(b'_ask')
         self.assertEqual(L[-1], {})
 
 
@@ -1818,19 +1821,19 @@ class AMPTests(unittest.TestCase):
         class StructuredHello(amp.AMP):
             def h(self, *a, **k):
                 L.append((a, k))
-                return dict(hello='aaa')
+                return dict(hello=b'aaa')
             Hello.responder(h)
         c, s, p = connectedServerAndClient(ServerClass=StructuredHello)
-        c.callRemote(Hello, hello='hello test', mixedCase='mixed case arg test',
-                     dash_arg='x', underscore_arg='y').addCallback(L.append)
+        c.callRemote(Hello, hello=b'hello test', mixedCase=b'mixed case arg test',
+                     dash_arg=b'x', underscore_arg=b'y').addCallback(L.append)
         p.flush()
         self.assertEqual(len(L), 2)
         self.assertEqual(L[0],
                           ((), dict(
-                    hello='hello test',
-                    mixedCase='mixed case arg test',
-                    dash_arg='x',
-                    underscore_arg='y',
+                    hello=b'hello test',
+                    mixedCase=b'mixed case arg test',
+                    dash_arg=b'x',
+                    underscore_arg=b'y',
                     From=s.transport.getPeer(),
 
                     # XXX - should optional arguments just not be passed?
@@ -1839,7 +1842,7 @@ class AMPTests(unittest.TestCase):
                     Print=None,
                     optional=None,
                     )))
-        self.assertEqual(L[1], dict(Print=None, hello='aaa'))
+        self.assertEqual(L[1], dict(Print=None, hello=b'aaa'))
 
 class PretendRemoteCertificateAuthority:
     def checkIsPretendRemote(self):
@@ -2052,16 +2055,16 @@ class TLSNotAvailableTests(unittest.TestCase):
         okc = OKCert()
         svr.certFactory = lambda : okc
         box = amp.Box()
-        box['_command'] = 'StartTLS'
-        box['_ask'] = '1'
+        box[b'_command'] = b'StartTLS'
+        box[b'_ask'] = b'1'
         boxes = []
         svr.sendBox = boxes.append
         svr.makeConnection(StringTransport())
         svr.ampBoxReceived(box)
         self.assertEqual(boxes,
-            [{'_error_code': 'TLS_ERROR',
-              '_error': '1',
-              '_error_description': 'TLS not available'}])
+            [{b'_error_code': b'TLS_ERROR',
+              b'_error': b'1',
+              b'_error_description': b'TLS not available'}])
 
 
 
@@ -2083,7 +2086,7 @@ class BaseCommand(amp.Command):
     """
     This provides a command that will be subclassed.
     """
-    errors = {InheritedError: 'INHERITED_ERROR'}
+    errors = {InheritedError: b'INHERITED_ERROR'}
 
 
 
@@ -2100,8 +2103,8 @@ class AddErrorsCommand(BaseCommand):
     This is a command which subclasses another command but adds errors to the
     list.
     """
-    arguments = [('other', amp.Boolean())]
-    errors = {OtherInheritedError: 'OTHER_INHERITED_ERROR'}
+    arguments = [(b'other', amp.Boolean())]
+    errors = {OtherInheritedError: b'OTHER_INHERITED_ERROR'}
 
 
 
@@ -2382,7 +2385,8 @@ class ProtocolIncludingArgument(amp.Argument):
         @type obj: L{object}
         @type protocol: L{amp.AMP}
         """
-        return "%s:%s" % (id(obj), id(protocol))
+        ident = u"%d:%d" % (id(obj), id(protocol))
+        return ident.encode("ascii")
 
 
 
@@ -2391,8 +2395,8 @@ class ProtocolIncludingCommand(amp.Command):
     A command that has argument and response schemas which use
     L{ProtocolIncludingArgument}.
     """
-    arguments = [('weird', ProtocolIncludingArgument())]
-    response = [('weird', ProtocolIncludingArgument())]
+    arguments = [(b'weird', ProtocolIncludingArgument())]
+    response = [(b'weird', ProtocolIncludingArgument())]
 
 
 
@@ -2499,8 +2503,8 @@ class CommandTests(unittest.TestCase):
         Command's response schema.
         """
         protocol = object()
-        result = 'whatever'
-        strings = {'weird': result}
+        result = b'whatever'
+        strings = {b'weird': result}
         self.assertEqual(
             ProtocolIncludingCommand.parseResponse(strings, protocol),
             {'weird': (result, protocol)})
@@ -2513,7 +2517,7 @@ class CommandTests(unittest.TestCase):
         C{parseResponse} method to get the response.
         """
         client = NoNetworkProtocol()
-        thingy = "weeoo"
+        thingy = b"weeoo"
         response = client.callRemote(MagicSchemaCommand, weird=thingy)
         def gotResponse(ign):
             self.assertEqual(client.parseResponseArguments,
@@ -2530,8 +2534,8 @@ class CommandTests(unittest.TestCase):
         command's argument schema.
         """
         protocol = object()
-        result = 'whatever'
-        strings = {'weird': result}
+        result = b'whatever'
+        strings = {b'weird': result}
         self.assertEqual(
             ProtocolIncludingCommand.parseArguments(strings, protocol),
             {'weird': (result, protocol)})
@@ -2563,9 +2567,10 @@ class CommandTests(unittest.TestCase):
         protocol = object()
         argument = object()
         objects = {'weird': argument}
+        ident = u"%d:%d" % (id(argument), id(protocol))
         self.assertEqual(
             ProtocolIncludingCommand.makeArguments(objects, protocol),
-            {'weird': "%d:%d" % (id(argument), id(protocol))})
+            {b'weird': ident.encode("ascii")})
 
 
     def test_makeArgumentsUsesCommandType(self):
@@ -2574,7 +2579,7 @@ class CommandTests(unittest.TestCase):
         of the result of L{amp.Command.commandType}.
         """
         protocol = object()
-        objects = {"weird": "whatever"}
+        objects = {"weird": b"whatever"}
 
         result = ProtocolIncludingCommandWithDifferentCommandType.makeArguments(
             objects, protocol)
@@ -2636,13 +2641,14 @@ class ListOfTestsMixin:
         instance.  The tests will make a L{ListOf} using this.
 
     @ivar strings: Subclasses should set this to a dictionary mapping some
-        number of keys to the correct serialized form for some example
-        values.  These should agree with what L{elementType}
+        number of keys -- as BYTE strings -- to the correct serialized form
+        for some example values. These should agree with what L{elementType}
         produces/accepts.
 
     @ivar objects: Subclasses should set this to a dictionary with the same
-        keys as C{strings} and with values which are the lists which should
-        serialize to the values in the C{strings} dictionary.
+        keys as C{strings} -- as NATIVE strings -- and with values which are
+        the lists which should serialize to the values in the C{strings}
+        dictionary.
     """
     def test_toBox(self):
         """
@@ -2656,7 +2662,8 @@ class ListOfTestsMixin:
         stringList = amp.ListOf(self.elementType)
         strings = amp.AmpBox()
         for key in self.objects:
-            stringList.toBox(key, strings, self.objects.copy(), None)
+            stringList.toBox(
+                key.encode("ascii"), strings, self.objects.copy(), None)
         self.assertEqual(strings, self.strings)
 
 
@@ -2679,14 +2686,14 @@ class ListOfStringsTests(unittest.TestCase, ListOfTestsMixin):
     elementType = amp.String()
 
     strings = {
-        "empty": "",
-        "single": "\x00\x03foo",
-        "multiple": "\x00\x03bar\x00\x03baz\x00\x04quux"}
+        b"empty": b"",
+        b"single": b"\x00\x03foo",
+        b"multiple": b"\x00\x03bar\x00\x03baz\x00\x04quux"}
 
     objects = {
         "empty": [],
-        "single": ["foo"],
-        "multiple": ["bar", "baz", "quux"]}
+        "single": [b"foo"],
+        "multiple": [b"bar", b"baz", b"quux"]}
 
 
 class ListOfIntegersTests(unittest.TestCase, ListOfTestsMixin):
@@ -2700,11 +2707,11 @@ class ListOfIntegersTests(unittest.TestCase, ListOfTestsMixin):
         9999999999999999999999999999999999999999999999999999999999)
 
     strings = {
-        "empty": "",
-        "single": "\x00\x0210",
-        "multiple": "\x00\x011\x00\x0220\x00\x03500",
-        "huge": "\x00\x74%d" % (huge,),
-        "negative": "\x00\x02-1"}
+        b"empty": b"",
+        b"single": b"\x00\x0210",
+        b"multiple": b"\x00\x011\x00\x0220\x00\x03500",
+        b"huge": b"\x00\x74" + intToBytes(huge),
+        b"negative": b"\x00\x02-1"}
 
     objects = {
         "empty": [],
@@ -2722,9 +2729,9 @@ class ListOfUnicodeTests(unittest.TestCase, ListOfTestsMixin):
     elementType = amp.Unicode()
 
     strings = {
-        "empty": "",
-        "single": "\x00\x03foo",
-        "multiple": "\x00\x03\xe2\x98\x83\x00\x05Hello\x00\x05world"}
+        b"empty": b"",
+        b"single": b"\x00\x03foo",
+        b"multiple": b"\x00\x03\xe2\x98\x83\x00\x05Hello\x00\x05world"}
 
     objects = {
         "empty": [],
@@ -2740,14 +2747,16 @@ class ListOfDecimalTests(unittest.TestCase, ListOfTestsMixin):
     elementType = amp.Decimal()
 
     strings = {
-        "empty": "",
-        "single": "\x00\x031.1",
-        "extreme": "\x00\x08Infinity\x00\x09-Infinity",
-        "scientist": "\x00\x083.141E+5\x00\x0a0.00003141\x00\x083.141E-7"
-                     "\x00\x09-3.141E+5\x00\x0b-0.00003141\x00\x09-3.141E-7",
-        "engineer": "\x00\x04%s\x00\x06%s" % (
-            decimal.Decimal("0e6").to_eng_string(),
-            decimal.Decimal("1.5E-9").to_eng_string()),
+        b"empty": b"",
+        b"single": b"\x00\x031.1",
+        b"extreme": b"\x00\x08Infinity\x00\x09-Infinity",
+        b"scientist": b"\x00\x083.141E+5\x00\x0a0.00003141\x00\x083.141E-7"
+                      b"\x00\x09-3.141E+5\x00\x0b-0.00003141\x00\x09-3.141E-7",
+        b"engineer": (
+            b"\x00\x04" +
+            decimal.Decimal("0e6").to_eng_string().encode("ascii") +
+            b"\x00\x06" +
+            decimal.Decimal("1.5E-9").to_eng_string().encode("ascii")),
     }
 
     objects = {
@@ -2784,7 +2793,7 @@ class ListOfDecimalNanTests(unittest.TestCase, ListOfTestsMixin):
     elementType = amp.Decimal()
 
     strings = {
-        "nan": "\x00\x03NaN\x00\x04-NaN\x00\x04sNaN\x00\x05-sNaN",
+        b"nan": b"\x00\x03NaN\x00\x04-NaN\x00\x04sNaN\x00\x05-sNaN",
     }
 
     objects = {
@@ -2849,13 +2858,13 @@ class ListOfDateTimeTests(unittest.TestCase, ListOfTestsMixin):
     elementType = amp.DateTime()
 
     strings = {
-        "christmas": "\x00\x202010-12-25T00:00:00.000000-00:00"
-                     "\x00\x202010-12-25T00:00:00.000000-00:00",
-        "christmas in eu": "\x00\x202010-12-25T00:00:00.000000+01:00",
-        "christmas in iran": "\x00\x202010-12-25T00:00:00.000000+03:30",
-        "christmas in nyc": "\x00\x202010-12-25T00:00:00.000000-05:00",
-        "previous tests": "\x00\x202010-12-25T00:00:00.000000+03:19"
-                          "\x00\x202010-12-25T00:00:00.000000-06:59",
+        b"christmas": b"\x00\x202010-12-25T00:00:00.000000-00:00"
+                      b"\x00\x202010-12-25T00:00:00.000000-00:00",
+        b"christmas in eu": b"\x00\x202010-12-25T00:00:00.000000+01:00",
+        b"christmas in iran": b"\x00\x202010-12-25T00:00:00.000000+03:30",
+        b"christmas in nyc": b"\x00\x202010-12-25T00:00:00.000000-05:00",
+        b"previous tests": b"\x00\x202010-12-25T00:00:00.000000+03:19"
+                           b"\x00\x202010-12-25T00:00:00.000000-06:59",
     }
 
     objects = {
@@ -2892,7 +2901,7 @@ class ListOfOptionalTests(unittest.TestCase):
         """
         stringList = amp.ListOf(amp.Integer())
         self.assertRaises(
-            TypeError, stringList.toBox, 'omitted', amp.AmpBox(),
+            TypeError, stringList.toBox, b'omitted', amp.AmpBox(),
             {'omitted': None}, None)
 
 
@@ -2903,7 +2912,7 @@ class ListOfOptionalTests(unittest.TestCase):
         """
         stringList = amp.ListOf(amp.Integer(), optional=True)
         strings = amp.AmpBox()
-        stringList.toBox('omitted', strings, {'omitted': None}, None)
+        stringList.toBox(b'omitted', strings, {b'omitted': None}, None)
         self.assertEqual(strings, {})
 
 
@@ -2914,7 +2923,7 @@ class ListOfOptionalTests(unittest.TestCase):
         """
         stringList = amp.ListOf(amp.Integer())
         self.assertRaises(
-            KeyError, stringList.toBox, 'ommited', amp.AmpBox(),
+            KeyError, stringList.toBox, b'ommited', amp.AmpBox(),
             {'someOtherKey': 0}, None)
 
 
@@ -2924,7 +2933,7 @@ class ListOfOptionalTests(unittest.TestCase):
         as optional whose key is not present in the objects dictionary.
         """
         stringList = amp.ListOf(amp.Integer(), optional=True)
-        stringList.toBox('ommited', amp.AmpBox(), {'someOtherKey': 0}, None)
+        stringList.toBox(b'ommited', amp.AmpBox(), {b'someOtherKey': 0}, None)
 
 
     def test_omittedOptionalArgumentDeserializesAsNone(self):
@@ -2934,11 +2943,12 @@ class ListOfOptionalTests(unittest.TestCase):
         """
         stringList = amp.ListOf(amp.Integer(), optional=True)
         objects = {}
-        stringList.fromBox('omitted', {}, objects, None)
+        stringList.fromBox(b'omitted', {}, objects, None)
         self.assertEqual(objects, {'omitted': None})
 
 
 
+@implementer(interfaces.IUNIXTransport)
 class UNIXStringTransport(object):
     """
     An in-memory implementation of L{interfaces.IUNIXTransport} which collects
@@ -2948,7 +2958,6 @@ class UNIXStringTransport(object):
         eg via C{write} or C{sendFileDescriptor}.  Elements are two-tuples of a
         string (identifying the destination of the data) and the data itself.
     """
-    implements(interfaces.IUNIXTransport)
 
     def __init__(self, descriptorFuzz):
         """
@@ -3038,13 +3047,13 @@ class DescriptorTests(unittest.TestCase):
         state inspection and mutation.
         """
         argument = amp.Descriptor()
-        self.assertEqual("0", argument.toStringProto(2, self.protocol))
+        self.assertEqual(b"0", argument.toStringProto(2, self.protocol))
         self.assertEqual(
             ("fileDescriptorReceived", 2 + self.fuzz), self.transport._queue.pop(0))
-        self.assertEqual("1", argument.toStringProto(4, self.protocol))
+        self.assertEqual(b"1", argument.toStringProto(4, self.protocol))
         self.assertEqual(
             ("fileDescriptorReceived", 4 + self.fuzz), self.transport._queue.pop(0))
-        self.assertEqual("2", argument.toStringProto(6, self.protocol))
+        self.assertEqual(b"2", argument.toStringProto(6, self.protocol))
         self.assertEqual(
             ("fileDescriptorReceived", 6 + self.fuzz), self.transport._queue.pop(0))
         self.assertEqual({}, self.protocol._descriptors)
@@ -3056,12 +3065,13 @@ class DescriptorTests(unittest.TestCase):
         L{amp.Descriptor.toBox} to reconstruct a file descriptor value.
         """
         name = "alpha"
+        name_as_bytes = name.encode("ascii")
         strings = {}
         descriptor = 17
         sendObjects = {name: descriptor}
 
         argument = amp.Descriptor()
-        argument.toBox(name, strings, sendObjects.copy(), self.protocol)
+        argument.toBox(name_as_bytes, strings, sendObjects.copy(), self.protocol)
 
         receiver = amp.BinaryBoxProtocol(
             amp.BoxDispatcher(amp.CommandLocator()))
@@ -3069,7 +3079,8 @@ class DescriptorTests(unittest.TestCase):
             getattr(receiver, event[0])(*event[1:])
 
         receiveObjects = {}
-        argument.fromBox(name, strings.copy(), receiveObjects, receiver)
+        argument.fromBox(
+            name_as_bytes, strings.copy(), receiveObjects, receiver)
 
         # Make sure we got the descriptor.  Adjust by fuzz to be more convincing
         # of having gone through L{IUNIXTransport.sendFileDescriptor}, not just
@@ -3082,7 +3093,7 @@ class DateTimeTests(unittest.TestCase):
     """
     Tests for L{amp.DateTime}, L{amp._FixedOffsetTZInfo}, and L{amp.utc}.
     """
-    string = '9876-01-23T12:34:56.054321-01:23'
+    string = b'9876-01-23T12:34:56.054321-01:23'
     tzinfo = tz('-', 1, 23)
     object = datetime.datetime(9876, 1, 23, 12, 34, 56, 54321, tzinfo)
 
diff --git a/twisted/topfiles/6833.feature b/twisted/topfiles/6833.feature
new file mode 100644
index 0000000..dd2a030
--- /dev/null
+++ b/twisted/topfiles/6833.feature
@@ -0,0 +1 @@
+twisted.protocols.amp has been ported to Python 3.
