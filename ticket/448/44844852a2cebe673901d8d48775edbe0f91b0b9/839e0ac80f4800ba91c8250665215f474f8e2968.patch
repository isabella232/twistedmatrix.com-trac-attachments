From ca03ac0eec13aa65cc13e0f0ff302d7cce385125 Mon Sep 17 00:00:00 2001
From: Vadim Markovtsev <v.markovtsev@samsung.com>
Date: Fri, 23 May 2014 10:51:52 +0400
Subject: [PATCH] Port twisted.web.client.Agent functionality to Python 3

---
 twisted/python/dist3.py        |   3 +-
 twisted/web/_newclient.py      |  63 ++---
 twisted/web/client.py          |  59 +++--
 twisted/web/test/test_agent.py | 531 +++++++++++++++++++++--------------------
 4 files changed, 338 insertions(+), 318 deletions(-)

diff --git a/twisted/python/dist3.py b/twisted/python/dist3.py
index eee4f44..ed0e0fb 100644
--- a/twisted/python/dist3.py
+++ b/twisted/python/dist3.py
@@ -242,7 +242,8 @@
     "twisted.test.reflect_helper_ZDE",
     # Required by some of the ported trial tests:
     "twisted.trial.reporter",
-    # Agent code and downloadPage aren't ported, test coverage isn't complete:
+    # test coverage isn't complete:
+    "twisted.web._newclient",
     "twisted.web.client",
     # twisted.web.resource depends on twisted.web.error, so it is sorta
     # ported, but its tests are not yet ported, so it probably doesn't
diff --git a/twisted/web/_newclient.py b/twisted/web/_newclient.py
index 3e2ba06..b504ac2 100644
--- a/twisted/web/_newclient.py
+++ b/twisted/web/_newclient.py
@@ -28,7 +28,7 @@
 
 __metaclass__ = type
 
-from zope.interface import implements
+from zope.interface import implementer
 
 from twisted.python import log
 from twisted.python.components import proxyForInterface
@@ -233,11 +233,11 @@ class HTTPParser(LineReceiver):
 
     # Some servers (like http://news.ycombinator.com/) return status lines and
     # HTTP headers delimited by \n instead of \r\n.
-    delimiter = '\n'
+    delimiter = b'\n'
 
     CONNECTION_CONTROL_HEADERS = set([
-            'content-length', 'connection', 'keep-alive', 'te', 'trailers',
-            'transfer-encoding', 'upgrade', 'proxy-connection'])
+            b'content-length', b'connection', b'keep-alive', b'te', b'trailers',
+            b'transfer-encoding', b'upgrade', b'proxy-connection'])
 
     def connectionMade(self):
         self.headers = Headers()
@@ -264,17 +264,17 @@ def lineReceived(self, line):
         Handle one line from a response.
         """
         # Handle the normal CR LF case.
-        if line[-1:] == '\r':
+        if line[-1:] == b'\r':
             line = line[:-1]
 
         if self.state == STATUS:
             self.statusReceived(line)
             self.state = HEADER
         elif self.state == HEADER:
-            if not line or line[0] not in ' \t':
+            if not line or line[0] not in b' \t':
                 if self._partialHeader is not None:
-                    header = ''.join(self._partialHeader)
-                    name, value = header.split(':', 1)
+                    header = b''.join(self._partialHeader)
+                    name, value = header.split(b':', 1)
                     value = value.strip()
                     self.headerReceived(name, value)
                 if not line:
@@ -389,10 +389,10 @@ def parseVersion(self, strversion):
         on bad syntax.
         """
         try:
-            proto, strnumber = strversion.split('/')
-            major, minor = strnumber.split('.')
+            proto, strnumber = strversion.split(b'/')
+            major, minor = strnumber.split(b'.')
             major, minor = int(major), int(minor)
-        except ValueError, e:
+        except ValueError as e:
             raise BadResponseVersion(str(e), strversion)
         if major < 0 or minor < 0:
             raise BadResponseVersion("version may not be negative", strversion)
@@ -404,7 +404,7 @@ def statusReceived(self, status):
         Parse the status line into its components and create a response object
         to keep track of this response's state.
         """
-        parts = status.split(' ', 2)
+        parts = status.split(b' ', 2)
         if len(parts) != 3:
             raise ParseError("wrong number of parts", status)
 
@@ -441,7 +441,7 @@ def isConnectionControlHeader(self, name):
         Content-Length in the response to a HEAD request is an entity header,
         not a connection control header.
         """
-        if self.request.method == 'HEAD' and name == 'content-length':
+        if self.request.method == b'HEAD' and name == b'content-length':
             return False
         return HTTPParser.isConnectionControlHeader(self, name)
 
@@ -452,7 +452,7 @@ def allHeadersReceived(self):
         headers and stuff.
         """
         if (self.response.code in self.NO_BODY_CODES
-            or self.request.method == 'HEAD'):
+            or self.request.method == b'HEAD'):
             self.response.length = 0
             # The order of the next two lines might be of interest when adding
             # support for pipelining.
@@ -460,7 +460,7 @@ def allHeadersReceived(self):
             self.response._bodyDataFinished()
         else:
             transferEncodingHeaders = self.connHeaders.getRawHeaders(
-                'transfer-encoding')
+                b'transfer-encoding')
             if transferEncodingHeaders:
 
                 # This could be a KeyError.  However, that would mean we do not
@@ -476,7 +476,7 @@ def allHeadersReceived(self):
                 # allow the transfer decoder to set the response object's
                 # length attribute.
             else:
-                contentLengthHeaders = self.connHeaders.getRawHeaders('content-length')
+                contentLengthHeaders = self.connHeaders.getRawHeaders(b'content-length')
                 if contentLengthHeaders is None:
                     contentLength = None
                 elif len(contentLengthHeaders) == 1:
@@ -546,6 +546,7 @@ def connectionLost(self, reason):
 
 
 
+@implementer(IClientRequest)
 class Request:
     """
     A L{Request} instance describes an HTTP request to be sent to an HTTP
@@ -560,7 +561,6 @@ class Request:
     @ivar _parsedURI: Parsed I{URI} for the request, or C{None}.
     @type _parsedURI: L{twisted.web.client.URI} or L{None}
     """
-    implements(IClientRequest)
 
 
     def __init__(self, method, uri, headers, bodyProducer, persistent=False):
@@ -623,7 +623,7 @@ def absoluteURI(self):
 
 
     def _writeHeaders(self, transport, TEorCL):
-        hosts = self.headers.getRawHeaders('host', ())
+        hosts = self.headers.getRawHeaders(b'host', ())
         if len(hosts) != 1:
             raise BadHeaders("Exactly one Host header required")
 
@@ -631,15 +631,17 @@ def _writeHeaders(self, transport, TEorCL):
         # method would probably be good.  It would be nice if this method
         # weren't limited to issueing HTTP/1.1 requests.
         requestLines = []
-        requestLines.append(
-            '%s %s HTTP/1.1\r\n' % (self.method, self.uri))
+        requestLines.append(b' '.join([self.method, self.uri]) +
+                            b' HTTP/1.1\r\n')
+
         if not self.persistent:
-            requestLines.append('Connection: close\r\n')
+            requestLines.append(b'Connection: close\r\n')
         if TEorCL is not None:
             requestLines.append(TEorCL)
         for name, values in self.headers.getAllRawHeaders():
-            requestLines.extend(['%s: %s\r\n' % (name, v) for v in values])
-        requestLines.append('\r\n')
+            requestLines.extend([b': '.join([name, v]) + b'\r\n'
+                                for v in values])
+        requestLines.append(b'\r\n')
         transport.writeSequence(requestLines)
 
 
@@ -648,7 +650,7 @@ def _writeToChunked(self, transport):
         Write this request to the given transport using chunked
         transfer-encoding to frame the body.
         """
-        self._writeHeaders(transport, 'Transfer-Encoding: chunked\r\n')
+        self._writeHeaders(transport, b'Transfer-Encoding: chunked\r\n')
         encoder = ChunkedEncoder(transport)
         encoder.registerProducer(self.bodyProducer, True)
         d = self.bodyProducer.startProducing(encoder)
@@ -674,7 +676,8 @@ def _writeToContentLength(self, transport):
         """
         self._writeHeaders(
             transport,
-            'Content-Length: %d\r\n' % (self.bodyProducer.length,))
+            b'Content-Length: ' +
+            str(self.bodyProducer.length).encode('charmap') + b'\r\n')
 
         # This Deferred is used to signal an error in the data written to the
         # encoder below.  It can only errback and it will only do so before too
@@ -914,6 +917,7 @@ def dispatcher(self, *args, **kwargs):
 
 
 
+@implementer(IResponse)
 class Response:
     """
     A L{Response} instance describes an HTTP response received from an HTTP
@@ -957,7 +961,6 @@ class Response:
             more data, the L{Response} moves to this state.  Nothing else
             can happen once the L{Response} is in this state.
     """
-    implements(IResponse)
 
     length = UNKNOWN_LENGTH
 
@@ -1173,12 +1176,12 @@ def _bodyDataFinished_FINISHED(self):
 
 
 
+@implementer(IConsumer)
 class ChunkedEncoder:
     """
     Helper object which exposes L{IConsumer} on top of L{HTTP11ClientProtocol}
     for streaming request bodies to the server.
     """
-    implements(IConsumer)
 
     def __init__(self, transport):
         self.transport = transport
@@ -1221,6 +1224,7 @@ def unregisterProducer(self):
 
 
 
+@implementer(IPushProducer)
 class TransportProxyProducer:
     """
     An L{IPushProducer} implementation which wraps another such thing and
@@ -1229,7 +1233,6 @@ class TransportProxyProducer:
     @ivar _producer: The wrapped L{IPushProducer} provider or C{None} after
         this proxy has been stopped.
     """
-    implements(IPushProducer)
 
     # LineReceiver uses this undocumented attribute of transports to decide
     # when to stop calling lineReceived or rawDataReceived (if it finds it to
@@ -1402,7 +1405,7 @@ def cancelRequest(ign):
         self._parser.makeConnection(self._transportProxy)
         self._responseDeferred = self._parser._responseDeferred
 
-        def cbRequestWrotten(ignored):
+        def cbRequestWritten(ignored):
             if self._state == 'TRANSMITTING':
                 self._state = 'WAITING'
                 self._responseDeferred.chainDeferred(self._finishedRequest)
@@ -1417,7 +1420,7 @@ def ebRequestWriting(err):
                 log.err(err, 'Error writing request, but not in valid state '
                              'to finalize request: %s' % self._state)
 
-        _requestDeferred.addCallbacks(cbRequestWrotten, ebRequestWriting)
+        _requestDeferred.addCallbacks(cbRequestWritten, ebRequestWriting)
 
         return self._finishedRequest
 
diff --git a/twisted/web/client.py b/twisted/web/client.py
index 7197aae..3bee9e5 100644
--- a/twisted/web/client.py
+++ b/twisted/web/client.py
@@ -328,7 +328,7 @@ class HTTPClientFactory(protocol.ClientFactory):
     port = None
     path = None
 
-    def __init__(self, url, method=b'GET', postdata=None, headers=None,
+    def __init__(self, url, method='GET', postdata=None, headers=None,
                  agent=b"Twisted PageGetter", timeout=0, cookies=None,
                  followRedirect=True, redirectLimit=20,
                  afterFoundGet=False):
@@ -603,6 +603,8 @@ def fromBytes(cls, uri, defaultPort=None):
         @rtype: L{URI}
         @return: Parsed URI instance.
         """
+        if not isinstance(uri, bytes):
+            raise TypeError("uri must be bytes, not a string")
         uri = uri.strip()
         scheme, netloc, path, params, query, fragment = http.urlparse(uri)
 
@@ -751,15 +753,11 @@ def downloadPage(url, file, contextFactory=None, *args, **kwargs):
 # feature equivalent.
 
 from twisted.web.error import SchemeNotSupported
-if not _PY3:
-    from twisted.web._newclient import Request, Response, HTTP11ClientProtocol
-    from twisted.web._newclient import ResponseDone, ResponseFailed
-    from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed
-    from twisted.web._newclient import (
-        ResponseNeverReceived, PotentialDataLoss, _WrapperException)
-
-
-
+from twisted.web._newclient import Request, Response, HTTP11ClientProtocol
+from twisted.web._newclient import ResponseDone, ResponseFailed
+from twisted.web._newclient import RequestNotSent, RequestTransmissionFailed
+from twisted.web._newclient import (
+    ResponseNeverReceived, PotentialDataLoss, _WrapperException)
 try:
     from OpenSSL import SSL
 except ImportError:
@@ -873,7 +871,7 @@ def creatorForNetloc(self, hostname, port):
         @rtype: L{client connection creator
             <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}
         """
-        return optionsForClientTLS(hostname.decode("ascii"))
+        return optionsForClientTLS(hostname.decode("charmap"))
 
 
 
@@ -1113,7 +1111,7 @@ def _shouldRetry(self, method, exception, bodyProducer):
         requirement may be relaxed in the future, and PUT added to approved
         method list.
         """
-        if method not in ("GET", "HEAD", "OPTIONS", "DELETE", "TRACE"):
+        if method not in (b"GET", b"HEAD", b"OPTIONS", b"DELETE", b"TRACE"):
             return False
         if not isinstance(exception, (RequestNotSent, RequestTransmissionFailed,
                                       ResponseNeverReceived)):
@@ -1293,7 +1291,7 @@ def closeCachedConnections(self):
             closed.
         """
         results = []
-        for protocols in self._connections.itervalues():
+        for protocols in self._connections.values():
             for p in protocols:
                 results.append(p.abort())
         self._connections = {}
@@ -1326,9 +1324,9 @@ def _computeHostValue(self, scheme, host, port):
         Compute the string to use for the value of the I{Host} header, based on
         the given scheme, host name, and port number.
         """
-        if (scheme, port) in (('http', 80), ('https', 443)):
+        if (scheme, port) in ((b'http', 80), (b'https', 443)):
             return host
-        return '%s:%d' % (host, port)
+        return host + b':' + str(port).encode('charmap')
 
 
     def _requestWithEndpoint(self, key, endpoint, method, parsedURI,
@@ -1340,12 +1338,11 @@ def _requestWithEndpoint(self, key, endpoint, method, parsedURI,
         # Create minimal headers, if necessary:
         if headers is None:
             headers = Headers()
-        if not headers.hasHeader('host'):
+        if not headers.hasHeader(b'host'):
             headers = headers.copy()
-            headers.addRawHeader(
-                'host', self._computeHostValue(parsedURI.scheme, parsedURI.host,
-                                               parsedURI.port))
-
+            host_value = self._computeHostValue(
+                parsedURI.scheme, parsedURI.host, parsedURI.port)
+            headers.addRawHeader(b'host', host_value)
         d = self._pool.getConnection(key, endpoint)
         def cbConnected(proto):
             return proto.request(
@@ -1416,7 +1413,8 @@ def endpointForURI(self, uri):
             return TCP4ClientEndpoint(
                 self._reactor, uri.host, uri.port, **kwargs)
         elif uri.scheme == b'https':
-            tlsPolicy = self._policyForHTTPS.creatorForNetloc(uri.host, uri.port)
+            tlsPolicy = self._policyForHTTPS.creatorForNetloc(
+                uri.host, uri.port)
             return SSL4ClientEndpoint(self._reactor, uri.host, uri.port,
                                       tlsPolicy, **kwargs)
         else:
@@ -1623,7 +1621,7 @@ class _FakeUrllib2Request(object):
     def __init__(self, uri):
         self.uri = uri
         self.headers = Headers()
-        self.type, rest = splittype(self.uri)
+        self.type, rest = splittype(self.uri.decode('charmap'))
         self.host, rest = splithost(rest)
 
 
@@ -1841,7 +1839,7 @@ class ContentDecoderAgent(object):
     def __init__(self, agent, decoders):
         self._agent = agent
         self._decoders = dict(decoders)
-        self._supported = ','.join([decoder[0] for decoder in decoders])
+        self._supported = b','.join([decoder[0] for decoder in decoders])
 
 
     def request(self, method, uri, headers=None, bodyProducer=None):
@@ -1854,7 +1852,7 @@ def request(self, method, uri, headers=None, bodyProducer=None):
             headers = Headers()
         else:
             headers = headers.copy()
-        headers.addRawHeader('accept-encoding', self._supported)
+        headers.addRawHeader(b'accept-encoding', self._supported)
         deferred = self._agent.request(method, uri, headers, bodyProducer)
         return deferred.addCallback(self._handleResponse)
 
@@ -1864,8 +1862,9 @@ def _handleResponse(self, response):
         Check if the response is encoded, and wrap it to handle decompression.
         """
         contentEncodingHeaders = response.headers.getRawHeaders(
-            'content-encoding', [])
-        contentEncodingHeaders = ','.join(contentEncodingHeaders).split(',')
+            b'content-encoding', [])
+        contentEncodingHeaders = b','.join(contentEncodingHeaders).split(b',')
+        contentEncodingHeaders = b','.join(contentEncodingHeaders).split(b',')
         while contentEncodingHeaders:
             name = contentEncodingHeaders.pop().strip()
             decoder = self._decoders.get(name)
@@ -1877,9 +1876,9 @@ def _handleResponse(self, response):
                 break
         if contentEncodingHeaders:
             response.headers.setRawHeaders(
-                'content-encoding', [','.join(contentEncodingHeaders)])
+                b'content-encoding', [b','.join(contentEncodingHeaders)])
         else:
-            response.headers.removeHeader('content-encoding')
+            response.headers.removeHeader(b'content-encoding')
         return response
 
 
@@ -1975,13 +1974,13 @@ def _handleResponse(self, response, method, uri, headers, redirectCount):
         Handle the response, making another request if it indicates a redirect.
         """
         if response.code in self._redirectResponses:
-            if method not in ('GET', 'HEAD'):
+            if method not in (b'GET', b'HEAD'):
                 err = error.PageRedirect(response.code, location=uri)
                 raise ResponseFailed([failure.Failure(err)], response)
             return self._handleRedirect(response, method, uri, headers,
                                         redirectCount)
         elif response.code in self._seeOtherResponses:
-            return self._handleRedirect(response, 'GET', uri, headers,
+            return self._handleRedirect(response, b'GET', uri, headers,
                                         redirectCount)
         return response
 
diff --git a/twisted/web/test/test_agent.py b/twisted/web/test/test_agent.py
index fcab5fa..f598de6 100644
--- a/twisted/web/test/test_agent.py
+++ b/twisted/web/test/test_agent.py
@@ -5,9 +5,15 @@
 Tests for L{twisted.web.client.Agent} and related new client APIs.
 """
 
-import cookielib
+try:
+    import cookielib
+except ImportError:
+    import http.cookiejar as cookielib
 import zlib
-from StringIO import StringIO
+try:
+    from StringIO import StringIO
+except ImportError:
+    from io import BytesIO as StringIO
 
 from zope.interface.verify import verifyObject
 
@@ -121,7 +127,7 @@ def test_interface(self):
         L{FileBodyProducer} instances provide L{IBodyProducer}.
         """
         self.assertTrue(verifyObject(
-                IBodyProducer, FileBodyProducer(StringIO(""))))
+                IBodyProducer, FileBodyProducer(StringIO(b""))))
 
 
     def test_unknownLength(self):
@@ -150,7 +156,7 @@ def test_knownLength(self):
         both C{seek} and C{tell} methods, its C{length} attribute is set to the
         size of the file as determined by those methods.
         """
-        inputBytes = "here are some bytes"
+        inputBytes = b"here are some bytes"
         inputFile = StringIO(inputBytes)
         inputFile.seek(5)
         producer = FileBodyProducer(inputFile)
@@ -163,7 +169,7 @@ def test_defaultCooperator(self):
         If no L{Cooperator} instance is passed to L{FileBodyProducer}, the
         global cooperator is used.
         """
-        producer = FileBodyProducer(StringIO(""))
+        producer = FileBodyProducer(StringIO(b""))
         self.assertEqual(task.cooperate, producer._cooperate)
 
 
@@ -173,7 +179,7 @@ def test_startProducing(self):
         file to the given L{IConsumer} and returns a L{Deferred} which fires
         when they have all been written.
         """
-        expectedResult = "hello, world"
+        expectedResult = b"hello, world"
         readSize = 3
         output = StringIO()
         consumer = FileConsumer(output)
@@ -193,7 +199,7 @@ def test_inputClosedAtEOF(self):
         it, the input file is closed.
         """
         readSize = 4
-        inputBytes = "some friendly bytes"
+        inputBytes = b"some friendly bytes"
         inputFile = StringIO(inputBytes)
         producer = FileBodyProducer(inputFile, self.cooperator, readSize)
         consumer = FileConsumer(StringIO())
@@ -226,7 +232,7 @@ def test_stopProducing(self):
         closes the input file but does not cause the L{Deferred} returned by
         C{startProducing} to fire.
         """
-        expectedResult = "hello, world"
+        expectedResult = b"hello, world"
         readSize = 3
         output = StringIO()
         consumer = FileConsumer(output)
@@ -237,7 +243,7 @@ def test_stopProducing(self):
         producer.stopProducing()
         self.assertTrue(inputFile.closed)
         self._scheduled.pop(0)()
-        self.assertEqual("", output.getvalue())
+        self.assertEqual(b"", output.getvalue())
         self.assertNoResult(complete)
 
 
@@ -246,7 +252,7 @@ def test_pauseProducing(self):
         L{FileBodyProducer.pauseProducing} temporarily suspends writing bytes
         from the input file to the given L{IConsumer}.
         """
-        expectedResult = "hello, world"
+        expectedResult = b"hello, world"
         readSize = 5
         output = StringIO()
         consumer = FileConsumer(output)
@@ -275,7 +281,7 @@ def test_resumeProducing(self):
         input file to the given L{IConsumer} after it was previously paused
         with L{FileBodyProducer.pauseProducing}.
         """
-        expectedResult = "hello, world"
+        expectedResult = b"hello, world"
         readSize = 5
         output = StringIO()
         consumer = FileConsumer(output)
@@ -428,25 +434,25 @@ def test_putStartsTimeout(self):
         # We start out with one cached connection:
         protocol = StubHTTPProtocol()
         protocol.makeConnection(StringTransport())
-        self.pool._putConnection(("http", "example.com", 80), protocol)
+        self.pool._putConnection((b"http", b"example.com", 80), protocol)
 
         # Connection is in pool, still not closed:
         self.assertEqual(protocol.transport.disconnecting, False)
         self.assertIn(protocol,
-                      self.pool._connections[("http", "example.com", 80)])
+                      self.pool._connections[(b"http", b"example.com", 80)])
 
         # Advance 239 seconds, still not closed:
         self.fakeReactor.advance(239)
         self.assertEqual(protocol.transport.disconnecting, False)
         self.assertIn(protocol,
-                      self.pool._connections[("http", "example.com", 80)])
+                      self.pool._connections[(b"http", b"example.com", 80)])
         self.assertIn(protocol, self.pool._timeouts)
 
         # Advance past 240 seconds, connection will be closed:
         self.fakeReactor.advance(1.1)
         self.assertEqual(protocol.transport.disconnecting, True)
         self.assertNotIn(protocol,
-                         self.pool._connections[("http", "example.com", 80)])
+                         self.pool._connections[(b"http", b"example.com", 80)])
         self.assertNotIn(protocol, self.pool._timeouts)
 
 
@@ -462,18 +468,18 @@ def test_putExceedsMaxPersistent(self):
         origCached = [StubHTTPProtocol(), StubHTTPProtocol()]
         for p in origCached:
             p.makeConnection(StringTransport())
-            pool._putConnection(("http", "example.com", 80), p)
-        self.assertEqual(pool._connections[("http", "example.com", 80)],
+            pool._putConnection((b"http", b"example.com", 80), p)
+        self.assertEqual(pool._connections[(b"http", b"example.com", 80)],
                          origCached)
         timeouts = pool._timeouts.copy()
 
         # Now we add another one:
         newProtocol = StubHTTPProtocol()
         newProtocol.makeConnection(StringTransport())
-        pool._putConnection(("http", "example.com", 80), newProtocol)
+        pool._putConnection((b"http", b"example.com", 80), newProtocol)
 
         # The oldest cached connections will be removed and disconnected:
-        newCached = pool._connections[("http", "example.com", 80)]
+        newCached = pool._connections[(b"http", b"example.com", 80)]
         self.assertEqual(len(newCached), 2)
         self.assertEqual(newCached, [origCached[1], newProtocol])
         self.assertEqual([p.transport.disconnecting for p in newCached],
@@ -494,17 +500,17 @@ def addProtocol(scheme, host, port):
             self.pool._putConnection((scheme, host, port), p)
             return p
         persistent = []
-        persistent.append(addProtocol("http", "example.com", 80))
-        persistent.append(addProtocol("http", "example.com", 80))
-        addProtocol("https", "example.com", 443)
-        addProtocol("http", "www2.example.com", 80)
+        persistent.append(addProtocol(b"http", b"example.com", 80))
+        persistent.append(addProtocol(b"http", b"example.com", 80))
+        addProtocol("https", b"example.com", 443)
+        addProtocol(b"http", "www2.example.com", 80)
 
         self.assertEqual(
-            self.pool._connections[("http", "example.com", 80)], persistent)
+            self.pool._connections[(b"http", b"example.com", 80)], persistent)
         self.assertEqual(
-            len(self.pool._connections[("https", "example.com", 443)]), 1)
+            len(self.pool._connections[("https", b"example.com", 443)]), 1)
         self.assertEqual(
-            len(self.pool._connections[("http", "www2.example.com", 80)]), 1)
+            len(self.pool._connections[(b"http", "www2.example.com", 80)]), 1)
 
 
     def test_getCachedConnection(self):
@@ -515,19 +521,19 @@ def test_getCachedConnection(self):
         # We start out with one cached connection:
         protocol = StubHTTPProtocol()
         protocol.makeConnection(StringTransport())
-        self.pool._putConnection(("http", "example.com", 80), protocol)
+        self.pool._putConnection((b"http", b"example.com", 80), protocol)
 
         def gotConnection(conn):
             # We got the cached connection:
             self.assertIdentical(protocol, conn)
             self.assertNotIn(
-                conn, self.pool._connections[("http", "example.com", 80)])
+                conn, self.pool._connections[(b"http", b"example.com", 80)])
             # And the timeout was cancelled:
             self.fakeReactor.advance(241)
             self.assertEqual(conn.transport.disconnecting, False)
             self.assertNotIn(conn, self.pool._timeouts)
 
-        return self.pool.getConnection(("http", "example.com", 80),
+        return self.pool.getConnection((b"http", b"example.com", 80),
                                        BadEndpoint(),
                                        ).addCallback(gotConnection)
 
@@ -560,7 +566,7 @@ def test_getSkipsDisconnected(self):
         are removed and not returned.
         """
         pool = self.pool
-        key = ("http", "example.com", 80)
+        key = (b"http", b"example.com", 80)
 
         # We start out with two cached connection, the max:
         origCached = [StubHTTPProtocol(), StubHTTPProtocol()]
@@ -594,13 +600,13 @@ def test_putNotQuiescent(self):
         self.assertEqual(protocol.state, "QUIESCENT")
 
         protocol.state = "NOTQUIESCENT"
-        self.pool._putConnection(("http", "example.com", 80), protocol)
+        self.pool._putConnection((b"http", b"example.com", 80), protocol)
         exc, = self.flushLoggedErrors(RuntimeError)
         self.assertEqual(
             exc.value.args[0],
             "BUG: Non-quiescent protocol added to connection pool.")
         self.assertIdentical(None, self.pool._connections.get(
-                ("http", "example.com", 80)))
+                (b"http", b"example.com", 80)))
 
 
     def test_getUsesQuiescentCallback(self):
@@ -654,8 +660,8 @@ def addProtocol(scheme, host, port):
             p.makeConnection(StringTransport())
             self.pool._putConnection((scheme, host, port), p)
             persistent.append(p)
-        addProtocol("http", "example.com", 80)
-        addProtocol("http", "www2.example.com", 80)
+        addProtocol(b"http", b"example.com", 80)
+        addProtocol(b"http", b"www2.example.com", 80)
         doneDeferred = self.pool.closeCachedConnections()
 
         # Connections have begun disconnecting:
@@ -766,7 +772,7 @@ def test_persistent(self):
         pool = HTTPConnectionPool(self.reactor)
         agent = client.Agent(self.reactor, pool=pool)
         agent._getEndpoint = lambda *args: self
-        agent.request("GET", "http://127.0.0.1")
+        agent.request(b"GET", b"http://127.0.0.1")
         self.assertEqual(self.protocol.requests[0][0].persistent, True)
 
 
@@ -784,7 +790,7 @@ def test_nonPersistent(self):
         pool = HTTPConnectionPool(self.reactor, persistent=False)
         agent = client.Agent(self.reactor, pool=pool)
         agent._getEndpoint = lambda *args: self
-        agent.request("GET", "http://127.0.0.1")
+        agent.request(b"GET", b"http://127.0.0.1")
         self.assertEqual(self.protocol.requests[0][0].persistent, False)
 
 
@@ -798,7 +804,7 @@ def test_connectUsesConnectionPool(self):
         class MyAgent(client.Agent):
             def _getEndpoint(this, uri):
                 self.assertEqual((uri.scheme, uri.host, uri.port),
-                                 ("http", "foo", 80))
+                                 (b"http", b"foo", 80))
                 return endpoint
 
         class DummyPool(object):
@@ -809,7 +815,7 @@ def getConnection(this, key, ep):
                 self.assertEqual(ep, endpoint)
                 # This is the key the default Agent uses, others will have
                 # different keys:
-                self.assertEqual(key, ("http", "foo", 80))
+                self.assertEqual(key, (b"http", b"foo", 80))
                 return defer.succeed(StubHTTPProtocol())
 
         pool = DummyPool()
@@ -817,9 +823,9 @@ def getConnection(this, key, ep):
         self.assertIdentical(pool, agent._pool)
 
         headers = http_headers.Headers()
-        headers.addRawHeader("host", "foo")
+        headers.addRawHeader(b"host", b"foo")
         bodyProducer = object()
-        agent.request('GET', 'http://foo/',
+        agent.request(b'GET', b'http://foo/',
                       bodyProducer=bodyProducer, headers=headers)
         self.assertEqual(agent._pool.connected, True)
 
@@ -831,7 +837,7 @@ def test_unsupportedScheme(self):
         C{'http'}.
         """
         return self.assertFailure(
-            self.agent.request('GET', 'mailto:alice@example.com'),
+            self.agent.request(b'GET', b'mailto:alice@example.com'),
             SchemeNotSupported)
 
 
@@ -840,7 +846,7 @@ def test_connectionFailed(self):
         The L{Deferred} returned by L{Agent.request} fires with a L{Failure} if
         the TCP connection attempt fails.
         """
-        result = self.agent.request('GET', 'http://foo/')
+        result = self.agent.request(b'GET', b'http://foo/')
         # Cause the connection to be refused
         host, port, factory = self.reactor.tcpClients.pop()[:3]
         factory.clientConnectionFailed(None, Failure(ConnectionRefusedError()))
@@ -852,10 +858,13 @@ def test_connectHTTP(self):
         L{Agent._getEndpoint} return a C{TCP4ClientEndpoint} when passed a
         scheme of C{'http'}.
         """
-        expectedHost = 'example.com'
+        expectedHost = b'example.com'
         expectedPort = 1234
         endpoint = self.agent._getEndpoint(
-            URI.fromBytes(b'http://%s:%s/' % (expectedHost, expectedPort)))
+            URI.fromBytes(b'http://' +
+                          b':'.join([expectedHost,
+                                     str(expectedPort).encode('charmap')]) +
+                          b'/'))
         self.assertEqual(endpoint._host, expectedHost)
         self.assertEqual(endpoint._port, expectedPort)
         self.assertIsInstance(endpoint, TCP4ClientEndpoint)
@@ -869,7 +878,7 @@ def test_connectHTTPSCustomContextFactory(self):
         to the context factory's C{getContext} method.  The resulting context
         object will be used to establish the SSL connection.
         """
-        expectedHost = 'example.org'
+        expectedHost = b'example.org'
         expectedPort = 20443
         expectedContext = object()
 
@@ -881,7 +890,10 @@ def getContext(self, hostname, port):
 
         agent = client.Agent(self.reactor, StubWebContextFactory())
         endpoint = agent._getEndpoint(
-            URI.fromBytes(b'https://%s:%s/' % (expectedHost, expectedPort)))
+            URI.fromBytes(b'https://' +
+                          b':'.join([expectedHost,
+                                     str(expectedPort).encode('charmap')]) +
+                          b'/'))
         contextFactory = endpoint._sslContextFactory
         context = contextFactory.getContext()
         self.assertEqual(context, expectedContext)
@@ -896,10 +908,10 @@ def test_hostProvided(self):
         """
         self.agent._getEndpoint = lambda *args: self
         self.agent.request(
-            'GET', 'http://example.com/foo?bar')
+            b'GET', b'http://example.com/foo?bar')
 
         req, res = self.protocol.requests.pop()
-        self.assertEqual(req.headers.getRawHeaders('host'), ['example.com'])
+        self.assertEqual(req.headers.getRawHeaders(b'host'), [b'example.com'])
 
 
     def test_hostOverride(self):
@@ -908,13 +920,13 @@ def test_hostOverride(self):
         I{Host} header, that value takes precedence over the one which would
         otherwise be automatically provided.
         """
-        headers = http_headers.Headers({'foo': ['bar'], 'host': ['quux']})
+        headers = http_headers.Headers({b'foo': [b'bar'], b'host': [b'quux']})
         self.agent._getEndpoint = lambda *args: self
         self.agent.request(
-            'GET', 'http://example.com/foo?bar', headers)
+            b'GET', b'http://example.com/foo?bar', headers)
 
         req, res = self.protocol.requests.pop()
-        self.assertEqual(req.headers.getRawHeaders('host'), ['quux'])
+        self.assertEqual(req.headers.getRawHeaders(b'host'), [b'quux'])
 
 
     def test_headersUnmodified(self):
@@ -925,7 +937,7 @@ def test_headersUnmodified(self):
         headers = http_headers.Headers()
         self.agent._getEndpoint = lambda *args: self
         self.agent.request(
-            'GET', 'http://example.com/foo', headers)
+            b'GET', b'http://example.com/foo', headers)
 
         protocol = self.protocol
 
@@ -942,8 +954,8 @@ def test_hostValueStandardHTTP(self):
         the host name passed to it.
         """
         self.assertEqual(
-            self.agent._computeHostValue('http', 'example.com', 80),
-            'example.com')
+            self.agent._computeHostValue(b'http', b'example.com', 80),
+            b'example.com')
 
 
     def test_hostValueNonStandardHTTP(self):
@@ -953,8 +965,8 @@ def test_hostValueNonStandardHTTP(self):
         host passed to it joined together with the port number by C{":"}.
         """
         self.assertEqual(
-            self.agent._computeHostValue('http', 'example.com', 54321),
-            'example.com:54321')
+            self.agent._computeHostValue(b'http', b'example.com', 54321),
+            b'example.com:54321')
 
 
     def test_hostValueStandardHTTPS(self):
@@ -964,8 +976,8 @@ def test_hostValueStandardHTTPS(self):
         the host name passed to it.
         """
         self.assertEqual(
-            self.agent._computeHostValue('https', 'example.com', 443),
-            'example.com')
+            self.agent._computeHostValue(b'https', b'example.com', 443),
+            b'example.com')
 
 
     def test_hostValueNonStandardHTTPS(self):
@@ -975,8 +987,8 @@ def test_hostValueNonStandardHTTPS(self):
         host passed to it joined together with the port number by C{":"}.
         """
         self.assertEqual(
-            self.agent._computeHostValue('https', 'example.com', 54321),
-            'example.com:54321')
+            self.agent._computeHostValue(b'https', b'example.com', 54321),
+            b'example.com:54321')
 
 
     def test_request(self):
@@ -989,12 +1001,12 @@ def test_request(self):
         """
         self.agent._getEndpoint = lambda *args: self
 
-        headers = http_headers.Headers({'foo': ['bar']})
+        headers = http_headers.Headers({b'foo': [b'bar']})
         # Just going to check the body for identity, so it doesn't need to be
         # real.
         body = object()
         self.agent.request(
-            'GET', 'http://example.com:1234/foo?bar', headers, body)
+            b'GET', b'http://example.com:1234/foo?bar', headers, body)
 
         protocol = self.protocol
 
@@ -1002,12 +1014,12 @@ def test_request(self):
         self.assertEqual(len(protocol.requests), 1)
         req, res = protocol.requests.pop()
         self.assertIsInstance(req, Request)
-        self.assertEqual(req.method, 'GET')
-        self.assertEqual(req.uri, '/foo?bar')
+        self.assertEqual(req.method, b'GET')
+        self.assertEqual(req.uri, b'/foo?bar')
         self.assertEqual(
             req.headers,
-            http_headers.Headers({'foo': ['bar'],
-                                  'host': ['example.com:1234']}))
+            http_headers.Headers({b'foo': [b'bar'],
+                                  b'host': [b'example.com:1234']}))
         self.assertIdentical(req.bodyProducer, body)
 
 
@@ -1017,7 +1029,7 @@ def test_connectTimeout(self):
         following C{connectTCP} agent.
         """
         agent = client.Agent(self.reactor, connectTimeout=5)
-        agent.request('GET', 'http://foo/')
+        agent.request(b'GET', b'http://foo/')
         timeout = self.reactor.tcpClients.pop()[3]
         self.assertEqual(5, timeout)
 
@@ -1028,7 +1040,7 @@ def test_connectSSLTimeout(self):
         following C{connectSSL} call.
         """
         agent = client.Agent(self.reactor, self.StubPolicy(), connectTimeout=5)
-        agent.request('GET', 'https://foo/')
+        agent.request(b'GET', b'https://foo/')
         timeout = self.reactor.sslClients.pop()[4]
         self.assertEqual(5, timeout)
 
@@ -1039,7 +1051,7 @@ def test_bindAddress(self):
         following C{connectTCP} call.
         """
         agent = client.Agent(self.reactor, bindAddress='192.168.0.1')
-        agent.request('GET', 'http://foo/')
+        agent.request(b'GET', b'http://foo/')
         address = self.reactor.tcpClients.pop()[4]
         self.assertEqual('192.168.0.1', address)
 
@@ -1051,7 +1063,7 @@ def test_bindAddressSSL(self):
         """
         agent = client.Agent(self.reactor, self.StubPolicy(),
                              bindAddress='192.168.0.1')
-        agent.request('GET', 'https://foo/')
+        agent.request(b'GET', b'https://foo/')
         address = self.reactor.sslClients.pop()[5]
         self.assertEqual('192.168.0.1', address)
 
@@ -1063,7 +1075,7 @@ def test_responseIncludesRequest(self):
         """
         uri = b'http://example.com/'
         agent = self.buildAgentForWrapperTest(self.reactor)
-        d = agent.request('GET', uri)
+        d = agent.request(b'GET', uri)
 
         # The request should be issued.
         self.assertEqual(len(self.protocol.requests), 1)
@@ -1071,9 +1083,9 @@ def test_responseIncludesRequest(self):
         self.assertIsInstance(req, Request)
 
         resp = client.Response._construct(
-            ('HTTP', 1, 1),
+            (b'HTTP', 1, 1),
             200,
-            'OK',
+            b'OK',
             client.Headers({}),
             None,
             req)
@@ -1154,7 +1166,7 @@ class AgentHTTPSTests(TestCase, FakeReactorAndConnectMixin):
         skip = "SSL not present, cannot run SSL tests"
 
 
-    def makeEndpoint(self, host='example.com', port=443):
+    def makeEndpoint(self, host=b'example.com', port=443):
         """
         Create an L{Agent} with an https scheme and return its endpoint
         created according to the arguments.
@@ -1169,7 +1181,9 @@ def makeEndpoint(self, host='example.com', port=443):
         @rtype: L{SSL4ClientEndpoint}
         """
         return client.Agent(self.Reactor())._getEndpoint(
-            URI.fromBytes(b'https://%s:%s/' % (host, port)))
+            URI.fromBytes(b'https://' +
+                b':'.join([host, str(port).encode('charmap')]) +
+                b'/'))
 
 
     def test_endpointType(self):
@@ -1184,7 +1198,7 @@ def test_hostArgumentIsRespected(self):
         """
         If a host is passed, the endpoint respects it.
         """
-        expectedHost = 'example.com'
+        expectedHost = b'example.com'
         endpoint = self.makeEndpoint(host=expectedHost)
         self.assertEqual(endpoint._host, expectedHost)
 
@@ -1217,7 +1231,7 @@ def test_connectHTTPSCustomConnectionCreator(self):
         C{creatorForNetloc} method.  The resulting context object will be used
         to establish the SSL connection.
         """
-        expectedHost = 'example.org'
+        expectedHost = b'example.org'
         expectedPort = 20443
         class JustEnoughConnection(object):
             handshakeStarted = False
@@ -1275,7 +1289,10 @@ def creatorForNetloc(self, hostname, port):
         reactor = self.Reactor()
         agent = client.Agent(reactor, expectedCreatorCreator)
         endpoint = agent._getEndpoint(
-            URI.fromBytes(b'https://%s:%s/' %  (expectedHost, expectedPort)))
+            URI.fromBytes(b'https://' +
+                          b':'.join([expectedHost,
+                                     str(expectedPort).encode('charmap')]) +
+                          b'/'))
         endpoint.connect(Factory.forProtocol(Protocol))
         passedFactory = reactor.sslClients[-1][2]
         passedContextFactory = reactor.sslClients[-1][3]
@@ -1359,7 +1376,7 @@ def test_missingSSL(self):
         self.assertRaises(
             NotImplementedError,
             self.webClientContextFactory().getContext,
-            'example.com', 443,
+            b'example.com', 443,
         )
 
 
@@ -1367,7 +1384,7 @@ def test_returnsContext(self):
         """
         If SSL is present, C{getContext} returns a L{SSL.Context}.
         """
-        ctx = self.webClientContextFactory().getContext('example.com', 443)
+        ctx = self.webClientContextFactory().getContext(b'example.com', 443)
         self.assertIsInstance(ctx, ssl.SSL.Context)
 
 
@@ -1377,7 +1394,7 @@ def test_setsTrustRootOnContextToDefaultTrustRoot(self):
         roots.
         """
         ctx = self.webClientContextFactory()
-        certificateOptions = ctx._getCertificateOptions('example.com', 443)
+        certificateOptions = ctx._getCertificateOptions(b'example.com', 443)
         self.assertIsInstance(
             certificateOptions.trustRoot, ssl.OpenSSLDefaultPaths)
 
@@ -1404,18 +1421,18 @@ def test_onlyRetryIdempotentMethods(self):
         """
         pool = client.HTTPConnectionPool(None)
         connection = client._RetryingHTTP11ClientProtocol(None, pool)
-        self.assertTrue(connection._shouldRetry("GET", RequestNotSent(), None))
-        self.assertTrue(connection._shouldRetry("HEAD", RequestNotSent(), None))
+        self.assertTrue(connection._shouldRetry(b"GET", RequestNotSent(), None))
+        self.assertTrue(connection._shouldRetry(b"HEAD", RequestNotSent(), None))
         self.assertTrue(connection._shouldRetry(
-                "OPTIONS", RequestNotSent(), None))
+                b"OPTIONS", RequestNotSent(), None))
         self.assertTrue(connection._shouldRetry(
-                "TRACE", RequestNotSent(), None))
+                b"TRACE", RequestNotSent(), None))
         self.assertTrue(connection._shouldRetry(
-                "DELETE", RequestNotSent(), None))
+                b"DELETE", RequestNotSent(), None))
         self.assertFalse(connection._shouldRetry(
-                "POST", RequestNotSent(), None))
+                b"POST", RequestNotSent(), None))
         self.assertFalse(connection._shouldRetry(
-                "MYMETHOD", RequestNotSent(), None))
+                b"MYMETHOD", RequestNotSent(), None))
         # This will be covered by a different ticket, since we need support
         #for resettable body producers:
         # self.assertTrue(connection._doRetry("PUT", RequestNotSent(), None))
@@ -1428,15 +1445,15 @@ def test_onlyRetryIfNoResponseReceived(self):
         """
         pool = client.HTTPConnectionPool(None)
         connection = client._RetryingHTTP11ClientProtocol(None, pool)
-        self.assertTrue(connection._shouldRetry("GET", RequestNotSent(), None))
+        self.assertTrue(connection._shouldRetry(b"GET", RequestNotSent(), None))
         self.assertTrue(connection._shouldRetry(
-                "GET", RequestTransmissionFailed([]), None))
+                b"GET", RequestTransmissionFailed([]), None))
         self.assertTrue(connection._shouldRetry(
-                "GET", ResponseNeverReceived([]),None))
+                b"GET", ResponseNeverReceived([]),None))
         self.assertFalse(connection._shouldRetry(
-                "GET", ResponseFailed([]), None))
+                b"GET", ResponseFailed([]), None))
         self.assertFalse(connection._shouldRetry(
-                "GET", ConnectionRefusedError(), None))
+                b"GET", ConnectionRefusedError(), None))
 
 
     def test_dontRetryIfFailedDueToCancel(self):
@@ -1449,7 +1466,7 @@ def test_dontRetryIfFailedDueToCancel(self):
         connection = client._RetryingHTTP11ClientProtocol(None, pool)
         exception = ResponseNeverReceived([Failure(defer.CancelledError())])
         self.assertFalse(connection._shouldRetry(
-                "GET", exception, None))
+                b"GET", exception, None))
 
 
     def test_retryIfFailedDueToNonCancelException(self):
@@ -1461,7 +1478,7 @@ def test_retryIfFailedDueToNonCancelException(self):
         pool = client.HTTPConnectionPool(None)
         connection = client._RetryingHTTP11ClientProtocol(None, pool)
         self.assertTrue(connection._shouldRetry(
-                "GET", ResponseNeverReceived([Failure(Exception())]), None))
+                b"GET", ResponseNeverReceived([Failure(Exception())]), None))
 
 
     def test_wrappedOnPersistentReturned(self):
@@ -1514,14 +1531,14 @@ def newProtocol():
             return defer.succeed(protocol)
 
         bodyProducer = object()
-        request = client.Request("FOO", "/", client.Headers(), bodyProducer,
+        request = client.Request(b"FOO", b"/", client.Headers(), bodyProducer,
                                  persistent=True)
         newProtocol()
         protocol = protocols[0]
         retrier = client._RetryingHTTP11ClientProtocol(protocol, newProtocol)
 
         def _shouldRetry(m, e, bp):
-            self.assertEqual(m, "FOO")
+            self.assertEqual(m, b"FOO")
             self.assertIdentical(bp, bodyProducer)
             self.assertIsInstance(e, (RequestNotSent, ResponseNeverReceived))
             return willWeRetry
@@ -1573,8 +1590,8 @@ def test_onlyRetryWithoutBody(self):
         """
         pool = client.HTTPConnectionPool(None)
         connection = client._RetryingHTTP11ClientProtocol(None, pool)
-        self.assertTrue(connection._shouldRetry("GET", RequestNotSent(), None))
-        self.assertFalse(connection._shouldRetry("GET", RequestNotSent(), object()))
+        self.assertTrue(connection._shouldRetry(b"GET", RequestNotSent(), None))
+        self.assertFalse(connection._shouldRetry(b"GET", RequestNotSent(), object()))
 
 
     def test_onlyRetryOnce(self):
@@ -1663,10 +1680,10 @@ def addCookies(self, cookieJar, uri, cookies):
         """
         response = client._FakeUrllib2Response(
             client.Response(
-                ('HTTP', 1, 1),
+                (b'HTTP', 1, 1),
                 200,
-                'OK',
-                client.Headers({'Set-Cookie': cookies}),
+                b'OK',
+                client.Headers({b'Set-Cookie': cookies}),
                 None))
         request = client._FakeUrllib2Request(uri)
         cookieJar.extract_cookies(response, request)
@@ -1687,9 +1704,9 @@ def makeCookieJar(self):
         cookieJar = cookielib.CookieJar()
         reqres = self.addCookies(
             cookieJar,
-            'http://example.com:1234/foo?bar',
-            ['foo=1; cow=moo; Path=/foo; Comment=hello',
-             'bar=2; Comment=goodbye'])
+            b'http://example.com:1234/foo?bar',
+            [b'foo=1; cow=moo; Path=/foo; Comment=hello',
+             b'bar=2; Comment=goodbye'])
         return cookieJar, reqres
 
 
@@ -1701,21 +1718,21 @@ def test_extractCookies(self):
         jar = self.makeCookieJar()[0]
         cookies = dict([(c.name, c) for c in jar])
 
-        cookie = cookies['foo']
+        cookie = cookies[b'foo']
         self.assertEqual(cookie.version, 0)
-        self.assertEqual(cookie.name, 'foo')
-        self.assertEqual(cookie.value, '1')
-        self.assertEqual(cookie.path, '/foo')
-        self.assertEqual(cookie.comment, 'hello')
-        self.assertEqual(cookie.get_nonstandard_attr('cow'), 'moo')
+        self.assertEqual(cookie.name, b'foo')
+        self.assertEqual(cookie.value, b'1')
+        self.assertEqual(cookie.path, b'/foo')
+        self.assertEqual(cookie.comment, b'hello')
+        self.assertEqual(cookie.get_nonstandard_attr(b'cow'), b'moo')
 
         cookie = cookies['bar']
         self.assertEqual(cookie.version, 0)
-        self.assertEqual(cookie.name, 'bar')
-        self.assertEqual(cookie.value, '2')
-        self.assertEqual(cookie.path, '/')
-        self.assertEqual(cookie.comment, 'goodbye')
-        self.assertIdentical(cookie.get_nonstandard_attr('cow'), None)
+        self.assertEqual(cookie.name, b'bar')
+        self.assertEqual(cookie.value, b'2')
+        self.assertEqual(cookie.path, b'/')
+        self.assertEqual(cookie.comment, b'goodbye')
+        self.assertIdentical(cookie.get_nonstandard_attr(b'cow'), None)
 
 
     def test_sendCookie(self):
@@ -1726,13 +1743,13 @@ def test_sendCookie(self):
         jar, (request, response) = self.makeCookieJar()
 
         self.assertIdentical(
-            request.get_header('Cookie', None),
+            request.get_header(b'Cookie', None),
             None)
 
         jar.add_cookie_header(request)
         self.assertEqual(
-            request.get_header('Cookie', None),
-            'foo=1; bar=2')
+            request.get_header(b'Cookie', None),
+            b'foo=1; bar=2')
 
 
 
@@ -1767,24 +1784,24 @@ def test_emptyCookieJarRequest(self):
         agent = self.buildAgentForWrapperTest(self.reactor)
         cookieAgent = client.CookieAgent(agent, cookieJar)
         d = cookieAgent.request(
-            'GET', 'http://example.com:1234/foo?bar')
+            b'GET', b'http://example.com:1234/foo?bar')
 
         def _checkCookie(ignored):
             cookies = list(cookieJar)
             self.assertEqual(len(cookies), 1)
-            self.assertEqual(cookies[0].name, 'foo')
-            self.assertEqual(cookies[0].value, '1')
+            self.assertEqual(cookies[0].name, b'foo')
+            self.assertEqual(cookies[0].value, b'1')
 
         d.addCallback(_checkCookie)
 
         req, res = self.protocol.requests.pop()
-        self.assertIdentical(req.headers.getRawHeaders('cookie'), None)
+        self.assertIdentical(req.headers.getRawHeaders(b'cookie'), None)
 
         resp = client.Response(
-            ('HTTP', 1, 1),
+            (b'HTTP', 1, 1),
             200,
-            'OK',
-            client.Headers({'Set-Cookie': ['foo=1',]}),
+            b'OK',
+            client.Headers({b'Set-Cookie': [b'foo=1',]}),
             None)
         res.callback(resp)
 
@@ -1797,8 +1814,8 @@ def test_requestWithCookie(self):
         object when there is a cookie matching the request URI in the cookie
         jar.
         """
-        uri = 'http://example.com:1234/foo?bar'
-        cookie = 'foo=1'
+        uri = b'http://example.com:1234/foo?bar'
+        cookie = b'foo=1'
 
         cookieJar = cookielib.CookieJar()
         self.addCookies(cookieJar, uri, [cookie])
@@ -1806,10 +1823,10 @@ def test_requestWithCookie(self):
 
         agent = self.buildAgentForWrapperTest(self.reactor)
         cookieAgent = client.CookieAgent(agent, cookieJar)
-        cookieAgent.request('GET', uri)
+        cookieAgent.request(b'GET', uri)
 
         req, res = self.protocol.requests.pop()
-        self.assertEqual(req.headers.getRawHeaders('cookie'), [cookie])
+        self.assertEqual(req.headers.getRawHeaders(b'cookie'), [cookie])
 
 
     def test_secureCookie(self):
@@ -1817,8 +1834,8 @@ def test_secureCookie(self):
         L{CookieAgent} is able to handle secure cookies, ie cookies which
         should only be handled over https.
         """
-        uri = 'https://example.com:1234/foo?bar'
-        cookie = 'foo=1;secure'
+        uri = b'https://example.com:1234/foo?bar'
+        cookie = b'foo=1;secure'
 
         cookieJar = cookielib.CookieJar()
         self.addCookies(cookieJar, uri, [cookie])
@@ -1826,10 +1843,10 @@ def test_secureCookie(self):
 
         agent = self.buildAgentForWrapperTest(self.reactor)
         cookieAgent = client.CookieAgent(agent, cookieJar)
-        cookieAgent.request('GET', uri)
+        cookieAgent.request(b'GET', uri)
 
         req, res = self.protocol.requests.pop()
-        self.assertEqual(req.headers.getRawHeaders('cookie'), ['foo=1'])
+        self.assertEqual(req.headers.getRawHeaders(b'cookie'), [b'foo=1'])
 
 
     def test_secureCookieOnInsecureConnection(self):
@@ -1837,8 +1854,8 @@ def test_secureCookieOnInsecureConnection(self):
         If a cookie is setup as secure, it won't be sent with the request if
         it's not over HTTPS.
         """
-        uri = 'http://example.com/foo?bar'
-        cookie = 'foo=1;secure'
+        uri = b'http://example.com/foo?bar'
+        cookie = b'foo=1;secure'
 
         cookieJar = cookielib.CookieJar()
         self.addCookies(cookieJar, uri, [cookie])
@@ -1846,7 +1863,7 @@ def test_secureCookieOnInsecureConnection(self):
 
         agent = self.buildAgentForWrapperTest(self.reactor)
         cookieAgent = client.CookieAgent(agent, cookieJar)
-        cookieAgent.request('GET', uri)
+        cookieAgent.request(b'GET', uri)
 
         req, res = self.protocol.requests.pop()
         self.assertIdentical(None, req.headers.getRawHeaders('cookie'))
@@ -1857,8 +1874,8 @@ def test_portCookie(self):
         L{CookieAgent} supports cookies which enforces the port number they
         need to be transferred upon.
         """
-        uri = 'https://example.com:1234/foo?bar'
-        cookie = 'foo=1;port=1234'
+        uri = b'https://example.com:1234/foo?bar'
+        cookie = b'foo=1;port=1234'
 
         cookieJar = cookielib.CookieJar()
         self.addCookies(cookieJar, uri, [cookie])
@@ -1866,10 +1883,10 @@ def test_portCookie(self):
 
         agent = self.buildAgentForWrapperTest(self.reactor)
         cookieAgent = client.CookieAgent(agent, cookieJar)
-        cookieAgent.request('GET', uri)
+        cookieAgent.request(b'GET', uri)
 
         req, res = self.protocol.requests.pop()
-        self.assertEqual(req.headers.getRawHeaders('cookie'), ['foo=1'])
+        self.assertEqual(req.headers.getRawHeaders(b'cookie'), [b'foo=1'])
 
 
     def test_portCookieOnWrongPort(self):
@@ -1877,8 +1894,8 @@ def test_portCookieOnWrongPort(self):
         When creating a cookie with a port directive, it won't be added to the
         L{cookie.CookieJar} if the URI is on a different port.
         """
-        uri = 'https://example.com:4567/foo?bar'
-        cookie = 'foo=1;port=1234'
+        uri = b'https://example.com:4567/foo?bar'
+        cookie = b'foo=1;port=1234'
 
         cookieJar = cookielib.CookieJar()
         self.addCookies(cookieJar, uri, [cookie])
@@ -1926,16 +1943,16 @@ def test_acceptHeaders(self):
         names of the available decoder objects.
         """
         agent = client.ContentDecoderAgent(
-            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])
+            self.agent, [(b'decoder1', Decoder1), (b'decoder2', Decoder2)])
 
-        agent.request('GET', 'http://example.com/foo')
+        agent.request(b'GET', b'http://example.com/foo')
 
         protocol = self.protocol
 
         self.assertEqual(len(protocol.requests), 1)
         req, res = protocol.requests.pop()
-        self.assertEqual(req.headers.getRawHeaders('accept-encoding'),
-                          ['decoder1,decoder2'])
+        self.assertEqual(req.headers.getRawHeaders(b'accept-encoding'),
+                          [b'decoder1,decoder2'])
 
 
     def test_existingHeaders(self):
@@ -1944,21 +1961,21 @@ def test_existingHeaders(self):
         L{client.ContentDecoderAgent} creates a new field for the decoders it
         knows about.
         """
-        headers = http_headers.Headers({'foo': ['bar'],
-                                        'accept-encoding': ['fizz']})
+        headers = http_headers.Headers({b'foo': [b'bar'],
+                                        b'accept-encoding': [b'fizz']})
         agent = client.ContentDecoderAgent(
-            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])
-        agent.request('GET', 'http://example.com/foo', headers=headers)
+            self.agent, [(b'decoder1', Decoder1), (b'decoder2', Decoder2)])
+        agent.request(b'GET', b'http://example.com/foo', headers=headers)
 
         protocol = self.protocol
 
         self.assertEqual(len(protocol.requests), 1)
         req, res = protocol.requests.pop()
         self.assertEqual(
-            list(req.headers.getAllRawHeaders()),
-            [('Host', ['example.com']),
-             ('Foo', ['bar']),
-             ('Accept-Encoding', ['fizz', 'decoder1,decoder2'])])
+            sorted(list(req.headers.getAllRawHeaders())),
+            sorted([(b'Host', [b'example.com']),
+             (b'Foo', [b'bar']),
+             (b'Accept-Encoding', [b'fizz', b'decoder1,decoder2'])]))
 
 
     def test_plainEncodingResponse(self):
@@ -1967,12 +1984,12 @@ def test_plainEncodingResponse(self):
         headers, L{client.ContentDecoderAgent} simply forwards the response.
         """
         agent = client.ContentDecoderAgent(
-            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])
-        deferred = agent.request('GET', 'http://example.com/foo')
+            self.agent, [(b'decoder1', Decoder1), (b'decoder2', Decoder2)])
+        deferred = agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        response = Response(('HTTP', 1, 1), 200, 'OK', http_headers.Headers(),
+        response = Response((b'HTTP', 1, 1), 200, b'OK', http_headers.Headers(),
                             None)
         res.callback(response)
 
@@ -1985,14 +2002,14 @@ def test_unsupportedEncoding(self):
         the response is unchanged.
         """
         agent = client.ContentDecoderAgent(
-            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])
-        deferred = agent.request('GET', 'http://example.com/foo')
+            self.agent, [(b'decoder1', Decoder1), (b'decoder2', Decoder2)])
+        deferred = agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        headers = http_headers.Headers({'foo': ['bar'],
-                                        'content-encoding': ['fizz']})
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)
+        headers = http_headers.Headers({b'foo': [b'bar'],
+                                        b'content-encoding': [b'fizz']})
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, None)
         res.callback(response)
 
         return deferred.addCallback(self.assertIdentical, response)
@@ -2004,22 +2021,22 @@ def test_unknownEncoding(self):
         about, it stops decoding even if another encoding is known afterwards.
         """
         agent = client.ContentDecoderAgent(
-            self.agent, [('decoder1', Decoder1), ('decoder2', Decoder2)])
-        deferred = agent.request('GET', 'http://example.com/foo')
+            self.agent, [(b'decoder1', Decoder1), (b'decoder2', Decoder2)])
+        deferred = agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        headers = http_headers.Headers({'foo': ['bar'],
-                                        'content-encoding':
-                                        ['decoder1,fizz,decoder2']})
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)
+        headers = http_headers.Headers({b'foo': [b'bar'],
+                                        b'content-encoding':
+                                        [b'decoder1,fizz,decoder2']})
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, None)
         res.callback(response)
 
         def check(result):
             self.assertNotIdentical(response, result)
             self.assertIsInstance(result, Decoder2)
-            self.assertEqual(['decoder1,fizz'],
-                              result.headers.getRawHeaders('content-encoding'))
+            self.assertEqual([b'decoder1,fizz'],
+                              result.headers.getRawHeaders(b'content-encoding'))
 
         return deferred.addCallback(check)
 
@@ -2065,7 +2082,7 @@ def setUp(self):
         self.reactor = self.Reactor()
         agent = self.buildAgentForWrapperTest(self.reactor)
         self.agent = client.ContentDecoderAgent(
-            agent, [("gzip", client.GzipDecoder)])
+            agent, [(b"gzip", client.GzipDecoder)])
 
 
     def test_gzipEncodingResponse(self):
@@ -2074,28 +2091,28 @@ def test_gzipEncodingResponse(self):
         L{GzipDecoder} wraps the response to return uncompressed data to the
         user.
         """
-        deferred = self.agent.request('GET', 'http://example.com/foo')
+        deferred = self.agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        headers = http_headers.Headers({'foo': ['bar'],
-                                        'content-encoding': ['gzip']})
+        headers = http_headers.Headers({b'foo': [b'bar'],
+                                        b'content-encoding': [b'gzip']})
         transport = StringTransport()
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, transport)
         response.length = 12
         res.callback(response)
 
         compressor = zlib.compressobj(2, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
-        data = (compressor.compress('x' * 6) + compressor.compress('y' * 4) +
+        data = (compressor.compress(b'x' * 6) + compressor.compress(b'y' * 4) +
                 compressor.flush())
 
         def checkResponse(result):
             self.assertNotIdentical(result, response)
-            self.assertEqual(result.version, ('HTTP', 1, 1))
+            self.assertEqual(result.version, (b'HTTP', 1, 1))
             self.assertEqual(result.code, 200)
-            self.assertEqual(result.phrase, 'OK')
+            self.assertEqual(result.phrase, b'OK')
             self.assertEqual(list(result.headers.getAllRawHeaders()),
-                              [('Foo', ['bar'])])
+                              [(b'Foo', [b'bar'])])
             self.assertEqual(result.length, UNKNOWN_LENGTH)
             self.assertRaises(AttributeError, getattr, result, 'unknown')
 
@@ -2106,7 +2123,7 @@ def checkResponse(result):
             protocol = SimpleAgentProtocol()
             result.deliverBody(protocol)
 
-            self.assertEqual(protocol.received, ['x' * 6 + 'y' * 4])
+            self.assertEqual(protocol.received, [b'x' * 6 + b'y' * 4])
             return defer.gatherResults([protocol.made, protocol.finished])
 
         deferred.addCallback(checkResponse)
@@ -2119,18 +2136,18 @@ def test_brokenContent(self):
         If the data received by the L{GzipDecoder} isn't valid gzip-compressed
         data, the call to C{deliverBody} fails with a C{zlib.error}.
         """
-        deferred = self.agent.request('GET', 'http://example.com/foo')
+        deferred = self.agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        headers = http_headers.Headers({'foo': ['bar'],
-                                        'content-encoding': ['gzip']})
+        headers = http_headers.Headers({b'foo': [b'bar'],
+                                        b'content-encoding': [b'gzip']})
         transport = StringTransport()
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, transport)
         response.length = 12
         res.callback(response)
 
-        data = "not gzipped content"
+        data = b"not gzipped content"
 
         def checkResponse(result):
             response._bodyDataReceived(data)
@@ -2169,17 +2186,17 @@ def flush(self):
         zlib.decompressobj = decompressobj
         self.addCleanup(setattr, zlib, 'decompressobj', oldDecompressObj)
 
-        deferred = self.agent.request('GET', 'http://example.com/foo')
+        deferred = self.agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        headers = http_headers.Headers({'content-encoding': ['gzip']})
+        headers = http_headers.Headers({b'content-encoding': [b'gzip']})
         transport = StringTransport()
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, transport)
         res.callback(response)
 
         def checkResponse(result):
-            response._bodyDataReceived('data')
+            response._bodyDataReceived(b'data')
             response._bodyDataFinished()
 
             protocol = SimpleAgentProtocol()
@@ -2214,17 +2231,17 @@ def flush(self):
         zlib.decompressobj = decompressobj
         self.addCleanup(setattr, zlib, 'decompressobj', oldDecompressObj)
 
-        deferred = self.agent.request('GET', 'http://example.com/foo')
+        deferred = self.agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
-        headers = http_headers.Headers({'content-encoding': ['gzip']})
+        headers = http_headers.Headers({b'content-encoding': [b'gzip']})
         transport = StringTransport()
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, transport)
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, transport)
         res.callback(response)
 
         def checkResponse(result):
-            response._bodyDataReceived('data')
+            response._bodyDataReceived(b'data')
             response._bodyDataFinished()
 
             protocol = SimpleAgentProtocol()
@@ -2254,14 +2271,14 @@ def makeAgent(self):
         @return: a new L{twisted.web.client.ProxyAgent}
         """
         return client.ProxyAgent(
-            TCP4ClientEndpoint(self.reactor, "127.0.0.1", 1234),
+            TCP4ClientEndpoint(self.reactor, b"127.0.0.1", 1234),
             self.reactor)
 
 
     def setUp(self):
         self.reactor = self.Reactor()
         self.agent = client.ProxyAgent(
-            TCP4ClientEndpoint(self.reactor, "bar", 5678), self.reactor)
+            TCP4ClientEndpoint(self.reactor, b"bar", 5678), self.reactor)
         oldEndpoint = self.agent._proxyEndpoint
         self.agent._proxyEndpoint = self.StubEndpoint(oldEndpoint, self)
 
@@ -2271,15 +2288,15 @@ def test_proxyRequest(self):
         L{client.ProxyAgent} issues an HTTP request against the proxy, with the
         full URI as path, when C{request} is called.
         """
-        headers = http_headers.Headers({'foo': ['bar']})
+        headers = http_headers.Headers({b'foo': [b'bar']})
         # Just going to check the body for identity, so it doesn't need to be
         # real.
         body = object()
         self.agent.request(
-            'GET', 'http://example.com:1234/foo?bar', headers, body)
+            b'GET', b'http://example.com:1234/foo?bar', headers, body)
 
         host, port, factory = self.reactor.tcpClients.pop()[:3]
-        self.assertEqual(host, "bar")
+        self.assertEqual(host, b"bar")
         self.assertEqual(port, 5678)
 
         self.assertIsInstance(factory._wrappedFactory,
@@ -2291,12 +2308,12 @@ def test_proxyRequest(self):
         self.assertEqual(len(protocol.requests), 1)
         req, res = protocol.requests.pop()
         self.assertIsInstance(req, Request)
-        self.assertEqual(req.method, 'GET')
-        self.assertEqual(req.uri, 'http://example.com:1234/foo?bar')
+        self.assertEqual(req.method, b'GET')
+        self.assertEqual(req.uri, b'http://example.com:1234/foo?bar')
         self.assertEqual(
             req.headers,
-            http_headers.Headers({'foo': ['bar'],
-                                  'host': ['example.com:1234']}))
+            http_headers.Headers({b'foo': [b'bar'],
+                                  b'host': [b'example.com:1234']}))
         self.assertIdentical(req.bodyProducer, body)
 
 
@@ -2330,7 +2347,7 @@ def getConnection(this, key, ep):
         agent = client.ProxyAgent(endpoint, self.reactor, pool=pool)
         self.assertIdentical(pool, agent._pool)
 
-        agent.request('GET', 'http://foo/')
+        agent.request(b'GET', b'http://foo/')
         self.assertEqual(agent._pool.connected, True)
 
 
@@ -2345,12 +2362,12 @@ def test_noRedirect(self):
         L{client.RedirectAgent} behaves like L{client.Agent} if the response
         doesn't contain a redirect.
         """
-        deferred = self.agent.request('GET', 'http://example.com/foo')
+        deferred = self.agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
         headers = http_headers.Headers()
-        response = Response(('HTTP', 1, 1), 200, 'OK', headers, None)
+        response = Response((b'HTTP', 1, 1), 200, b'OK', headers, None)
         res.callback(response)
 
         self.assertEqual(0, len(self.protocol.requests))
@@ -2366,25 +2383,25 @@ def _testRedirectDefault(self, code):
 
         @param code: HTTP status code.
         """
-        self.agent.request('GET', 'http://example.com/foo')
+        self.agent.request(b'GET', b'http://example.com/foo')
 
         host, port = self.reactor.tcpClients.pop()[:2]
-        self.assertEqual("example.com", host)
+        self.assertEqual(b"example.com", host)
         self.assertEqual(80, port)
 
         req, res = self.protocol.requests.pop()
 
         headers = http_headers.Headers(
-            {'location': ['https://example.com/bar']})
-        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)
+            {b'location': [b'https://example.com/bar']})
+        response = Response((b'HTTP', 1, 1), code, b'OK', headers, None)
         res.callback(response)
 
         req2, res2 = self.protocol.requests.pop()
-        self.assertEqual('GET', req2.method)
-        self.assertEqual('/bar', req2.uri)
+        self.assertEqual(b'GET', req2.method)
+        self.assertEqual(b'/bar', req2.uri)
 
         host, port = self.reactor.sslClients.pop()[:2]
-        self.assertEqual("example.com", host)
+        self.assertEqual(b"example.com", host)
         self.assertEqual(443, port)
 
 
@@ -2418,18 +2435,18 @@ def _testRedirectToGet(self, code, method):
 
         @param method: HTTP request method.
         """
-        self.agent.request(method, 'http://example.com/foo')
+        self.agent.request(method, b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
         headers = http_headers.Headers(
-            {'location': ['http://example.com/bar']})
-        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)
+            {b'location': [b'http://example.com/bar']})
+        response = Response((b'HTTP', 1, 1), code, b'OK', headers, None)
         res.callback(response)
 
         req2, res2 = self.protocol.requests.pop()
-        self.assertEqual('GET', req2.method)
-        self.assertEqual('/bar', req2.uri)
+        self.assertEqual(b'GET', req2.method)
+        self.assertEqual(b'/bar', req2.uri)
 
 
     def test_redirect303(self):
@@ -2437,7 +2454,7 @@ def test_redirect303(self):
         L{client.RedirectAgent} changes the method to I{GET} when getting a 303
         redirect on a I{POST} request.
         """
-        self._testRedirectToGet(303, 'POST')
+        self._testRedirectToGet(303, b'POST')
 
 
     def test_noLocationField(self):
@@ -2446,17 +2463,17 @@ def test_noLocationField(self):
         L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping a
         L{error.RedirectWithNoLocation} exception.
         """
-        deferred = self.agent.request('GET', 'http://example.com/foo')
+        deferred = self.agent.request(b'GET', b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
         headers = http_headers.Headers()
-        response = Response(('HTTP', 1, 1), 301, 'OK', headers, None)
+        response = Response((b'HTTP', 1, 1), 301, b'OK', headers, None)
         res.callback(response)
 
         fail = self.failureResultOf(deferred, client.ResponseFailed)
         fail.value.reasons[0].trap(error.RedirectWithNoLocation)
-        self.assertEqual('http://example.com/foo',
+        self.assertEqual(b'http://example.com/foo',
                          fail.value.reasons[0].value.uri)
         self.assertEqual(301, fail.value.response.code)
 
@@ -2471,17 +2488,17 @@ def _testPageRedirectFailure(self, code, method):
 
         @param method: HTTP request method.
         """
-        deferred = self.agent.request(method, 'http://example.com/foo')
+        deferred = self.agent.request(method, b'http://example.com/foo')
 
         req, res = self.protocol.requests.pop()
 
         headers = http_headers.Headers()
-        response = Response(('HTTP', 1, 1), code, 'OK', headers, None)
+        response = Response((b'HTTP', 1, 1), code, b'OK', headers, None)
         res.callback(response)
 
         fail = self.failureResultOf(deferred, client.ResponseFailed)
         fail.value.reasons[0].trap(error.PageRedirect)
-        self.assertEqual('http://example.com/foo',
+        self.assertEqual(b'http://example.com/foo',
                          fail.value.reasons[0].value.location)
         self.assertEqual(code, fail.value.response.code)
 
@@ -2492,7 +2509,7 @@ def test_307OnPost(self):
         L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping
         a L{error.PageRedirect} exception.
         """
-        self._testPageRedirectFailure(307, 'POST')
+        self._testPageRedirectFailure(307, b'POST')
 
 
     def test_redirectLimit(self):
@@ -2521,7 +2538,7 @@ def test_redirectLimit(self):
         fail = self.failureResultOf(deferred, client.ResponseFailed)
 
         fail.value.reasons[0].trap(error.InfiniteRedirection)
-        self.assertEqual('http://example.com/foo',
+        self.assertEqual(b'http://example.com/foo',
                          fail.value.reasons[0].value.location)
         self.assertEqual(302, fail.value.response.code)
 
@@ -2537,17 +2554,17 @@ def _testRedirectURI(self, uri, location, finalURI):
 
         @param finalURI: Expected final URI.
         """
-        self.agent.request('GET', uri)
+        self.agent.request(b'GET', uri)
 
         req, res = self.protocol.requests.pop()
 
         headers = http_headers.Headers(
             {'location': [location]})
-        response = Response(('HTTP', 1, 1), 302, 'OK', headers, None)
+        response = Response((b'HTTP', 1, 1), 302, b'OK', headers, None)
         res.callback(response)
 
         req2, res2 = self.protocol.requests.pop()
-        self.assertEqual('GET', req2.method)
+        self.assertEqual(b'GET', req2.method)
         self.assertEqual(finalURI, req2.absoluteURI)
 
 
@@ -2557,14 +2574,14 @@ def test_relativeURI(self):
         redirects, preserving query strings.
         """
         self._testRedirectURI(
-            'http://example.com/foo/bar', 'baz',
-            'http://example.com/foo/baz')
+            b'http://example.com/foo/bar', b'baz',
+            b'http://example.com/foo/baz')
         self._testRedirectURI(
-            'http://example.com/foo/bar', '/baz',
-            'http://example.com/baz')
+            b'http://example.com/foo/bar', b'/baz',
+            b'http://example.com/baz')
         self._testRedirectURI(
-            'http://example.com/foo/bar', '/baz?a',
-            'http://example.com/baz?a')
+            b'http://example.com/foo/bar', b'/baz?a',
+            b'http://example.com/baz?a')
 
 
     def test_relativeURIPreserveFragments(self):
@@ -2576,11 +2593,11 @@ def test_relativeURIPreserveFragments(self):
         @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}
         """
         self._testRedirectURI(
-            'http://example.com/foo/bar#frag', '/baz?a',
-            'http://example.com/baz?a#frag')
+            b'http://example.com/foo/bar#frag', b'/baz?a',
+            b'http://example.com/baz?a#frag')
         self._testRedirectURI(
-            'http://example.com/foo/bar', '/baz?a#frag2',
-            'http://example.com/baz?a#frag2')
+            b'http://example.com/foo/bar', b'/baz?a#frag2',
+            b'http://example.com/baz?a#frag2')
 
 
     def test_relativeURISchemeRelative(self):
@@ -2589,11 +2606,11 @@ def test_relativeURISchemeRelative(self):
         redirects, replacing the hostname and port when required.
         """
         self._testRedirectURI(
-            'http://example.com/foo/bar', '//foo.com/baz',
-            'http://foo.com/baz')
+            b'http://example.com/foo/bar', b'//foo.com/baz',
+            b'http://foo.com/baz')
         self._testRedirectURI(
-            'http://example.com/foo/bar', '//foo.com:81/baz',
-            'http://foo.com:81/baz')
+            b'http://example.com/foo/bar', b'//foo.com:81/baz',
+            b'http://foo.com:81/baz')
 
 
     def test_responseHistory(self):
@@ -2648,7 +2665,7 @@ def test_301OnPost(self):
         L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping
         a L{error.PageRedirect} exception.
         """
-        self._testPageRedirectFailure(301, 'POST')
+        self._testPageRedirectFailure(301, b'POST')
 
 
     def test_302OnPost(self):
@@ -2657,7 +2674,7 @@ def test_302OnPost(self):
         L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping
         a L{error.PageRedirect} exception.
         """
-        self._testPageRedirectFailure(302, 'POST')
+        self._testPageRedirectFailure(302, b'POST')
 
 
 
@@ -2686,7 +2703,7 @@ def test_redirectToGet301(self):
         L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when
         getting a 302 redirect on a I{POST} request.
         """
-        self._testRedirectToGet(301, 'POST')
+        self._testRedirectToGet(301, b'POST')
 
 
     def test_redirectToGet302(self):
@@ -2694,7 +2711,7 @@ def test_redirectToGet302(self):
         L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when
         getting a 302 redirect on a I{POST} request.
         """
-        self._testRedirectToGet(302, 'POST')
+        self._testRedirectToGet(302, b'POST')
 
 
 
@@ -2708,7 +2725,7 @@ class DummyResponse(object):
     """
 
     code = 200
-    phrase = "OK"
+    phrase = b"OK"
 
     def __init__(self, headers=None):
         """
@@ -2741,10 +2758,10 @@ def test_success(self):
         """
         response = DummyResponse()
         d = client.readBody(response)
-        response.protocol.dataReceived("first")
-        response.protocol.dataReceived("second")
+        response.protocol.dataReceived(b"first")
+        response.protocol.dataReceived(b"second")
         response.protocol.connectionLost(Failure(ResponseDone()))
-        self.assertEqual(self.successResultOf(d), "firstsecond")
+        self.assertEqual(self.successResultOf(d), b"firstsecond")
 
 
     def test_withPotentialDataLoss(self):
@@ -2756,8 +2773,8 @@ def test_withPotentialDataLoss(self):
         """
         response = DummyResponse()
         d = client.readBody(response)
-        response.protocol.dataReceived("first")
-        response.protocol.dataReceived("second")
+        response.protocol.dataReceived(b"first")
+        response.protocol.dataReceived(b"second")
         response.protocol.connectionLost(Failure(PotentialDataLoss()))
         failure = self.failureResultOf(d)
         failure.trap(client.PartialDownloadError)
@@ -2767,8 +2784,8 @@ def test_withPotentialDataLoss(self):
                 "body": failure.value.response,
                 }, {
                 "status": 200,
-                "message": "OK",
-                "body": "firstsecond",
+                "message": b"OK",
+                "body": b"firstsecond",
                 })
 
 
@@ -2780,7 +2797,7 @@ def test_otherErrors(self):
         """
         response = DummyResponse()
         d = client.readBody(response)
-        response.protocol.dataReceived("first")
+        response.protocol.dataReceived(b"first")
         response.protocol.connectionLost(
             Failure(ConnectionLost("mystery problem")))
         reason = self.failureResultOf(d)
-- 
1.9.3
