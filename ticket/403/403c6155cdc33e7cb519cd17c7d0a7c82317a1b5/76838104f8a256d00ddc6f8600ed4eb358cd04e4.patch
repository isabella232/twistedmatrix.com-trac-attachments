Index: twisted/test/test_protocols.py
===================================================================
--- twisted/test/test_protocols.py	(Revision 29614)
+++ twisted/test/test_protocols.py	(Arbeitskopie)
@@ -35,12 +35,14 @@
         """
         self.clock = clock
 
+
     def connectionMade(self):
         """
         Create/clean data received on connection.
         """
         self.received = []
 
+
     def lineReceived(self, line):
         """
         Receive line and make some action for some tokens: pause, rawpause,
@@ -66,6 +68,7 @@
         elif line.startswith('unproduce'):
             self.transport.unregisterProducer()
 
+
     def rawDataReceived(self, data):
         """
         Read raw data, until the quantity specified by a previous 'len' line is
@@ -77,6 +80,7 @@
         if self.length == 0:
             self.setLineMode(rest)
 
+
     def lineLengthExceeded(self, line):
         """
         Adjust line mode when long lines received.
@@ -85,6 +89,7 @@
             self.setLineMode(line[self.MAX_LENGTH + 1:])
 
 
+
 class LineOnlyTester(basic.LineOnlyReceiver):
     """
     A buffering line only receiver.
@@ -98,16 +103,20 @@
         """
         self.received = []
 
+
     def lineReceived(self, line):
         """
         Save received data.
         """
         self.received.append(line)
 
+
+
 class WireTestCase(unittest.TestCase):
     """
     Test wire protocols.
     """
+
     def test_echo(self):
         """
         Test wire.Echo protocol: send some data and check it send it back.
@@ -206,6 +215,7 @@
     pause_output1 = ['twiddle1', 'twiddle2', 'pause']
     pause_output2 = pause_output1+['twiddle3']
 
+
     def test_pausing(self):
         """
         Test pause inside data receiving. It uses fake clock to see if
@@ -229,6 +239,7 @@
     rawpause_output2 = ['twiddle1', 'twiddle2', 'len 5', 'rawpause', '12345',
                         'twiddle3']
 
+
     def test_rawPausing(self):
         """
         Test pause inside raw date receiving.
@@ -249,6 +260,7 @@
 
     stop_output = ['twiddle1', 'twiddle2', 'stop']
 
+
     def test_stopProducing(self):
         """
         Test stop inside producing.
@@ -319,6 +331,7 @@
             a.dataReceived(c)
         self.assertEquals(a.received, self.buffer.split('\n')[:-1])
 
+
     def test_lineTooLong(self):
         """
         Test sending a line too long: it should close the connection.
@@ -336,16 +349,19 @@
     def connectionMade(self):
         self.received = []
 
+
     def stringReceived(self, s):
         self.received.append(s)
 
     MAX_LENGTH = 50
     closed = 0
 
+
     def connectionLost(self, reason):
         self.closed = 1
 
 
+
 class TestNetstring(TestMixin, basic.NetstringReceiver):
 
     def stringReceived(self, s):
@@ -353,11 +369,13 @@
         self.transport.write(s)
 
 
+
 class LPTestCaseMixin:
 
     illegalStrings = []
     protocol = None
 
+
     def getProtocol(self):
         """
         Return a new instance of C{self.protocol} connected to a new instance
@@ -380,6 +398,7 @@
             self.assertTrue(r.transport.disconnecting)
 
 
+
 class NetstringReceiverTestCase(unittest.TestCase, LPTestCaseMixin):
 
     strings = ['hello', 'world', 'how', 'are', 'you123', ':today', "a"*515]
@@ -395,10 +414,10 @@
         self.netstringReceiver = TestNetstring()
         self.netstringReceiver.makeConnection(self.transport)
 
+
     def test_buffer(self):
         """
-        Test that when strings are received in chunks of different lengths,
-        they are still parsed correctly.
+        Strings can be received in chunks of different lengths.
         """
         for packet_size in range(1, 10):
             t = proto_helpers.StringTransport()
@@ -414,6 +433,7 @@
                     a.dataReceived(s)
             self.assertEquals(a.received, self.strings)
 
+
     def test_sendNonStrings(self):
         """
         L{basic.NetstringReceiver.sendString} will send objects that are not
@@ -445,73 +465,147 @@
             warnings[0]['category'],
             DeprecationWarning)
 
+
     def test_receiveEmptyNetstring(self):
+        """
+        Empty netstrings (with length '0') can be received.
+        """
         self.netstringReceiver.dataReceived("0:,")
-        self.assertEquals(self.transport.value(), "")
+        self.assertEquals(self.netstringReceiver.received, [""])
 
+
     def test_receiveOneCharacter(self):
+        """
+        One-character netstrings can be received.
+        """
         self.netstringReceiver.dataReceived("1:a,")
-        self.assertEquals(self.transport.value(), "a")
+        self.assertEquals(self.netstringReceiver.received, ["a"])
 
+
     def test_receiveTwoCharacters(self):
+        """
+        Two-character netstrings can be received.
+        """
         self.netstringReceiver.dataReceived("2:ab,")
-        self.assertEquals(self.transport.value(), "ab")
+        self.assertEquals(self.netstringReceiver.received, ["ab"])
 
+
     def test_receiveNestedNetstring(self):
+        """
+        Netstrings with embedded netstrings. This test makes sure that
+        the parser does not become confused about the ',' and ':'
+        characters appearing inside the data portion of the netstring.
+        """
         self.netstringReceiver.dataReceived("4:1:a,,")
-        self.assertEquals(self.transport.value(), "1:a,")
+        self.assertEquals(self.netstringReceiver.received, ["1:a,"])
 
+
     def test_moreDataThanSpecified(self):
+        """
+        Netstrings containing more data than expected are refused.
+        """
         self.netstringReceiver.dataReceived("2:aaa,")
         self.assertTrue(self.transport.disconnecting)
 
+
     def test_moreDataThanSpecifiedBorderCase(self):
+        """
+        Netstrings that should be empty according to their length
+        specification are refused if they contain data.
+        """
         self.netstringReceiver.dataReceived("0:a,")
         self.assertTrue(self.transport.disconnecting)
 
+
     def test_missingNumber(self):
+        """
+        Netstrings without leading digits that specify the length
+        are refused.
+        """
         self.netstringReceiver.dataReceived(":aaa,")
         self.assertTrue(self.transport.disconnecting)
 
+
     def test_missingColon(self):
+        """
+        Netstrings without a colon between length specification and
+        data are refused.
+        """
         self.netstringReceiver.dataReceived("3aaa,")
         self.assertTrue(self.transport.disconnecting)
 
+
     def test_missingNumberAndColon(self):
+        """
+        Netstrings that have no leading digits nor a colon are
+        refused.
+        """
         self.netstringReceiver.dataReceived("aaa,")
         self.assertTrue(self.transport.disconnecting)
 
+
     def test_OnlyData(self):
+        """
+        Netstrings consisting only of data are refused.
+        """
         self.netstringReceiver.dataReceived("aaa")
         self.assertTrue(self.transport.disconnecting)
 
+
     def test_receiveNetstringPortions_1(self):
+        """
+        Netstrings can be received in two portions.
+        """
         self.netstringReceiver.dataReceived("4:aa")
         self.netstringReceiver.dataReceived("aa,")
-        self.assertEquals(self.transport.value(), "aaaa")
+        self.assertEquals(self.netstringReceiver.received, ["aaaa"])
+        self.failUnless(self.netstringReceiver._payloadComplete())
+
         
     def test_receiveNetstringPortions_2(self):
+        """
+        Netstrings can be received in more than two portions, even if
+        the length specification is split across two portions.
+        """
         for part in ["1", "0:01234", "56789", ","]:
             self.netstringReceiver.dataReceived(part)
-        self.assertEquals(self.transport.value(), "0123456789")
+        self.assertEquals(self.netstringReceiver.received, ["0123456789"])
 
+
     def test_receiveNetstringPortions_3(self):
-        for part in "2:ab,": # Send one character at a time
+        """
+        Netstrings can be received one character at a time.
+        """
+        for part in "2:ab,":
             self.netstringReceiver.dataReceived(part)
-        self.assertEquals(self.transport.value(), "ab")
+        self.assertEquals(self.netstringReceiver.received, ["ab"])
 
+
     def test_receiveTwoNetstrings(self):
+        """
+        A stream of two netstrings can be received in two portions,
+        where the first portion contains the complete first netstring
+        and the length specification of the second netstring.
+        """
         self.netstringReceiver.dataReceived("1:a,1")
-        self.assertEquals(self.transport.value(), "a")
+        self.failUnless(self.netstringReceiver._payloadComplete())
+        self.assertEquals(self.netstringReceiver.received, ["a"])
         self.netstringReceiver.dataReceived(":b,")
-        self.assertEquals(self.transport.value(), "ab")
+        self.assertEquals(self.netstringReceiver.received, ["a", "b"])
 
+
     def test_maxReceiveLimit(self):
-        too_long = self.netstringReceiver.MAX_LENGTH + 1
-        self.netstringReceiver.dataReceived("%s:%s" % (too_long, "a" * too_long))
+        """
+        Netstrings with a length specification exceeding the specified
+        MAX_LENGTH are refused.
+        """
+        tooLong = self.netstringReceiver.MAX_LENGTH + 1
+        self.netstringReceiver.dataReceived("%s:%s" %
+                                            (tooLong, "a" * tooLong))
         self.assertTrue(self.transport.disconnecting)
 
 
+
 class IntNTestCaseMixin(LPTestCaseMixin):
     """
     TestCase mixin for int-prefixed protocols.
@@ -532,6 +626,7 @@
                 r.dataReceived(c)
         self.assertEquals(r.received, self.strings)
 
+
     def test_partial(self):
         """
         Send partial data, nothing should be definitely received.
@@ -542,6 +637,7 @@
                 r.dataReceived(c)
             self.assertEquals(r.received, [])
 
+
     def test_send(self):
         """
         Test sending data over protocol.
@@ -588,6 +684,7 @@
     """
 
 
+
 class Int32TestCase(unittest.TestCase, IntNTestCaseMixin):
     """
     Test case for int32-prefixed protocol
@@ -608,6 +705,7 @@
         self.assertEquals(r.received, ["ubar"])
 
 
+
 class TestInt16(TestMixin, basic.Int16StringReceiver):
     """
     A L{basic.Int16StringReceiver} storing received strings in an array.
@@ -616,6 +714,7 @@
     """
 
 
+
 class Int16TestCase(unittest.TestCase, IntNTestCaseMixin):
     """
     Test case for int16-prefixed protocol
@@ -635,6 +734,7 @@
         r.dataReceived("\x00\x04ubar")
         self.assertEquals(r.received, ["ubar"])
 
+
     def test_tooLongSend(self):
         """
         Send too much data: that should cause an error.
@@ -644,6 +744,7 @@
         self.assertRaises(AssertionError, r.sendString, tooSend)
 
 
+
 class TestInt8(TestMixin, basic.Int8StringReceiver):
     """
     A L{basic.Int8StringReceiver} storing received strings in an array.
@@ -652,6 +753,7 @@
     """
 
 
+
 class Int8TestCase(unittest.TestCase, IntNTestCaseMixin):
     """
     Test case for int8-prefixed protocol
@@ -661,6 +763,7 @@
     illegalStrings = ["\x00\x00aaaaaa"]
     partialStrings = ["\x08", "dzadz", ""]
 
+
     def test_data(self):
         """
         Test specific behavior of the 8-bits length.
@@ -671,6 +774,7 @@
         r.dataReceived("\x04ubar")
         self.assertEquals(r.received, ["ubar"])
 
+
     def test_tooLongSend(self):
         """
         Send too much data: that should cause an error.
@@ -680,6 +784,7 @@
         self.assertRaises(AssertionError, r.sendString, tooSend)
 
 
+
 class OnlyProducerTransport(object):
     # Transport which isn't really a transport, just looks like one to
     # someone not looking very hard.
@@ -690,16 +795,20 @@
     def __init__(self):
         self.data = []
 
+
     def pauseProducing(self):
         self.paused = True
 
+
     def resumeProducing(self):
         self.paused = False
 
+
     def write(self, bytes):
         self.data.append(bytes)
 
 
+
 class ConsumingProtocol(basic.LineReceiver):
     # Protocol that really, really doesn't want any more bytes.
 
@@ -708,7 +817,9 @@
         self.pauseProducing()
 
 
+
 class ProducerTestCase(unittest.TestCase):
+
     def testPauseResume(self):
         p = ConsumingProtocol()
         t = OnlyProducerTransport()
@@ -818,7 +929,8 @@
         except AttributeError:
             pass
         try:
-            self.proxyServerFactory.clientFactoryInstance.protoInstance.transport.loseConnection()
+            pi = self.proxyServerFactory.clientFactoryInstance.protoInstance
+            pi.transport.loseConnection()
         except AttributeError:
             pass
         try:
@@ -851,15 +963,18 @@
         nBytes = 1000
         received = []
         d = defer.Deferred()
+
         def testDataReceived(data):
             received.extend(data)
             if len(received) >= nBytes:
                 self.assertEquals(''.join(received), 'x' * nBytes)
                 d.callback(None)
+
         self.clientProtocol.dataReceived = testDataReceived
 
         def testConnectionMade():
             self.clientProtocol.transport.write('x' * nBytes)
+
         self.clientProtocol.connectionMade = testConnectionMade
 
         clientFactory = protocol.ClientFactory()
Index: twisted/protocols/basic.py
===================================================================
--- twisted/protocols/basic.py	(Revision 29614)
+++ twisted/protocols/basic.py	(Arbeitskopie)
@@ -14,6 +14,7 @@
 import struct
 import warnings
 import cStringIO
+import math
 
 from zope.interface import implements
 
@@ -21,46 +22,44 @@
 from twisted.internet import protocol, defer, interfaces, error
 from twisted.python import log
 
-# See http://cr.yp.to/proto/netstrings.txt for a specification of netstrings.
-# Every netstring starts with digits that specify the length of the data;
-# extra zeros are not allowed. The length specification is separated from
-# the data by a colon (":").
-NETSTRING_LENGTH = re.compile('(\d+)(:)')
-
-# The following pattern describes all valid partial netstring length
-# specifications. It is used to check the netstring validity when the
-# length specification is received in several chunks.
-NETSTRING_LENGTH_PREFIX = re.compile('(\d+)$')
 DEBUG = 0
 
-# Some error information for NetstringParseError instances.
-NETSTRING_MISSING_LENGTH = ("The received netstring does not start with a "
-                            "length specification.")
-NETSTRING_OVERFLOW = ("The length specification of the received netstring "
-                      "cannot be represented in Python - it causes an "
-                      "OverflowError!")
-NETSTRING_TOO_LONG = ("The received netstring is longer than the maximum %s "
-                      "specified by self.MAX_LENGTH")
-NETSTRING_MISSING_COMMA = "The received netstring is not terminated by a comma."
-DATA_SUPPORT_DEPRECATED = ("Data passed to sendString() must be a string. "
-                           "Non-string support is deprecated since "
-                           "Twisted 10.0")
+LENGTH, DATA, COMMA = range(3)
+NUMBER = re.compile('(\d*)(:?)')
 
 # The following constants are used for determining if the NetstringReceiver
 # is parsing the length portion of a netstring, or the payload.
 PARSING_LENGTH, PARSING_PAYLOAD = range(2)
 
 class NetstringParseError(ValueError):
-    """The incoming data is not in valid Netstring format."""
+    """
+    The incoming data is not in valid Netstring format.
+    """
 
+
+
 class IncompleteNetstring(Exception):
-    """Not enough data to complete a netstring."""
+    """
+    Not enough data to complete a netstring.
+    """
 
+
+
+class IncompleteNetstring(Exception):
+    """
+    Not enough data to complete a netstring.
+    """
+
+
+
 class NetstringReceiver(protocol.Protocol):
-    """A protocol that sends and receives netstrings.
+    """
+    A protocol that sends and receives netstrings.
 
     See U{http://cr.yp.to/proto/netstrings.txt} for the specification of
-    netstrings.
+    netstrings. Every netstring starts with digits that specify the length
+    of the data. This length specification is separated from the data by
+    a colon. The data is terminated with a comma.
 
     Override L{stringReceived} to handle received netstrings. This
     method is called with the netstring payload as a single argument
@@ -75,6 +74,9 @@
     @ivar MAX_LENGTH: Defines the maximum length of netstrings that can be
         received
     @type MAX_LENGTH: C{int}
+    @ivar MAX_LENGTH_SIZE: Defines the number of digits necessary to represent
+        C{MAX_LENGTH} as a string.
+    @type MAX_LENGTH: C{float}
     @ivar brokenPeer: Indicates if the connection is still functional
     @type brokenPeer: C{int}
     @ivar state: Indicates if the protocol is consuming the length portion
@@ -89,17 +91,42 @@
     @type expectedLength: C{int}
     """
     MAX_LENGTH = 99999
+    MAX_LENGTH_SIZE = math.ceil(math.log10(MAX_LENGTH)) + 1
 
-    def __init__(self):
+    _LENGTH = re.compile('(0)(:)|([1-9]\d*)(:)')
+
+    # The following pattern describes all valid partial netstring length
+    # specifications. It is used to check the netstring validity when the
+    # length specification is received in several chunks.
+    _LENGTH_PREFIX = re.compile('(\d+)$')
+
+    # Some error information for NetstringParseError instances.
+    _MISSING_LENGTH = ("The received netstring does not start with a "
+                                "length specification.")
+    _OVERFLOW = ("The length specification of the received netstring "
+                          "cannot be represented in Python - it causes an "
+                          "OverflowError!")
+    _TOO_LONG = ("The received netstring is longer than the maximum %s "
+                          "specified by self.MAX_LENGTH")
+    _MISSING_COMMA = "The received netstring is not terminated by a comma."
+    _DATA_SUPPORT_DEPRECATED = ("Data passed to sendString() must be a string. "
+                               "Non-string support is deprecated since "
+                               "Twisted 10.0")
+
+    def makeConnection(self, transport):
         """
         Initializes the protocol.
         """
-        self.currentData = ""
-        self.payload = cStringIO.StringIO()
+
+        protocol.Protocol.makeConnection(self, transport)
+        self._currentData = ""
+        self._currentDataSize = 0
+        self._payload = cStringIO.StringIO()
+        self._state = PARSING_LENGTH
+        self._expectedLength = 0
         self.brokenPeer = 0
-        self.state = PARSING_LENGTH
-        self.expectedLength = 0
 
+
     def sendString(self, payload):
         """
         Sends a netstring.
@@ -111,10 +138,11 @@
         @type payload: C{str}
         """
         if not isinstance(payload, str):
-            warnings.warn(DATA_SUPPORT_DEPRECATED, DeprecationWarning, 2)
+            warnings.warn(self._DATA_SUPPORT_DEPRECATED, DeprecationWarning, 2)
             payload = str(payload)
         self.transport.write('%d:%s,' % (len(payload), payload))
 
+
     def dataReceived(self, data):
         """
         Receives some characters of a netstring.
@@ -126,16 +154,17 @@
             netstring
         @type data: C{str}
         """
-        self.currentData += data
-        while self.currentData:
+        self._currentData += data
+        while self._currentData:
             try:
                 self._consumeData()
             except IncompleteNetstring:
                 break
-            except NetstringParseError:
+            except NetstringParseError, ex:
                 self._handleParseError()
                 break
 
+
     def stringReceived(self, payload):
         """
         Processes the data portion of a netstring. Override this.
@@ -145,62 +174,69 @@
         @param payload: The payload portion of a netstring
         @type payload: C{str}
         """
-        raise NotImplementedError
+        raise NotImplementedError()
 
+
     def _consumeData(self):
         """
-        Consumes the content of C{self.currentData}.
+        Consumes the content of C{self._currentData}.
 
-        @raise IncompleteNetstring: if C{self.currentData} does not
+        @raise IncompleteNetstring: if C{self._currentData} does not
             contain enough data to complete the current netstring.
         @raise NetstringParseError: if the received data do not
             form a valid netstring.
         """
-        if self.state == PARSING_LENGTH:
+        if self._state == PARSING_LENGTH:
             self._consumeLength()
             self._prepareForPayloadConsumption()
-        if self.state == PARSING_PAYLOAD:
+        if self._state == PARSING_PAYLOAD:
             self._consumePayload()
 
+
     def _consumeLength(self):
         """
-        Consumes the length portion of C{self.currentData}.
+        Consumes the length portion of C{self._currentData}.
 
-        @raise IncompleteNetstring: if C{self.currentData} contains
+        @raise IncompleteNetstring: if C{self._currentData} contains
             a partial length specification (digits without trailing
             comma).
         @raise NetstringParseError: if the received data do not form a valid
             netstring.
         """
-        lengthMatch = NETSTRING_LENGTH.match(self.currentData)
+        lengthMatch = self._LENGTH.match(self._currentData)
         if not lengthMatch:
             self._checkPartialLengthSpecification()
-            raise IncompleteNetstring
+            raise IncompleteNetstring()
         self._processLength(lengthMatch)
 
+        if length > self.MAX_LENGTH:
+            raise NetstringParseError(NETSTRING_TOO_LONG % (self.MAX_LENGTH,))
+        return length
+
     def _checkPartialLengthSpecification(self):
         """
         Makes sure that the received data represents a valid number.
 
-        Checks if C{self.currentData} represents a number smaller or
+        Checks if C{self._currentData} represents a number smaller or
         equal to C{self.MAX_LENGTH}.
 
-        @raise NetstringParseError: if C{self.currentData} is no
+        @raise NetstringParseError: if C{self._currentData} is no
             number or is too big (checked by L{extractLength}).
         """
-        partialLengthMatch = NETSTRING_LENGTH_PREFIX.match(self.currentData)
+        partialLengthMatch = self._LENGTH_PREFIX.match(self._currentData)
         if not partialLengthMatch:
-            raise NetstringParseError(NETSTRING_MISSING_LENGTH)
-        self._extractLength(partialLengthMatch.group(1))
+            raise NetstringParseError(self._MISSING_LENGTH)
+        lengthSpecification = (partialLengthMatch.group(1))
+        self._extractLength(lengthSpecification)
 
     def _processLength(self, lengthMatch):
         """
         Processes the length definition of a netstring.
 
-        Extracts and stores in C{self.expectedLength} the number
+        Extracts and stores in C{self._expectedLength} the number
         representing the netstring size.  Removes the prefix
         representing the length specification from
-        C{self.currentData}.
+        C{self._currentData}.
 
         @raise NetstringParseError: if the received netstring does not
             start with a number or the number is bigger than
@@ -209,45 +245,67 @@
             a netstring length specification
         @type lengthMatch: C{re.Match}
         """
-        endOfNumber = lengthMatch.end(1)
-        startOfData = lengthMatch.end(2)
-        lengthString = self.currentData[:endOfNumber]
+        endOfNumber = (lengthMatch.end(1) if lengthMatch.group(1) else
+                       lengthMatch.end(3))
+        startOfData = (lengthMatch.end(2) if lengthMatch.group(2) else
+                       lengthMatch.end(4))
+        lengthString = self._currentData[:endOfNumber]
         # Expect payload plus trailing comma:
-        self.expectedLength = self._extractLength(lengthString) + 1
-        self.currentData = self.currentData[startOfData:]
+        self._expectedLength = self._extractLength(lengthString) + 1
+        self._currentData = self._currentData[startOfData:]
 
-    def _extractLength(self, data):
+
+    def _extractLength(self, lengthAsString):
         """
         Attempts to extract the length information of a netstring.
 
-        @raise NetstringParseError: if the number can't be converted
-            to an integer due to an OverflowError, or if the number is
-            bigger than C{self.MAX_LENGTH}.
-        @param data: A chunk of data starting with a length specification
-        @type data: C{str}
+        @raise NetstringParseError: if the number is bigger than
+            C{self.MAX_LENGTH}.
+        @param lengthAsString: A chunk of data starting with a length
+            specification
+        @type lengthAsString: C{str}
         @return: The length of the netstring
         @rtype: C{int}
         """
-        try:
-            length = int(data)
-        except OverflowError:
-            raise NetstringParseError(NETSTRING_OVERFLOW)
+        self._checkStringSize(lengthAsString)
+        length = int(lengthAsString)
         if length > self.MAX_LENGTH:
-            raise NetstringParseError(NETSTRING_TOO_LONG % (self.MAX_LENGTH,))
+            raise NetstringParseError(self._TOO_LONG % (self.MAX_LENGTH,))
         return length
 
+
+    def _checkStringSize(self, lengthAsString):
+        """
+        Checks the sanity of lengthAsString.
+        
+        Checks if the size of the length specification exceeds the
+        size of the string representing self.MAX_LENGTH. If this is
+        not the case, the number represented by lengthAsString is
+        certainly bigger than self.MAX_LENGTH, and a
+        NetstringParseError can be raised.
+
+        This method should make sure that netstrings with extremely
+        long length specifications are refused before even attempting
+        to convert them to an integer (which might trigger a
+        MemoryError).
+        """
+        if len(lengthAsString) > self.MAX_LENGTH_SIZE:
+            raise NetstringParseError(self._TOO_LONG % (self.MAX_LENGTH,))
+
+
     def _prepareForPayloadConsumption(self):
         """
         Sets up variables necessary for consuming the payload of a netstring.
         """
-        self.state = PARSING_PAYLOAD
-        self.currentDataSize = 0
-        self.payload.seek(0)
-        self.payload.truncate()
+        self._state = PARSING_PAYLOAD
+        self._currentDataSize = 0
+        self._payload.seek(0)
+        self._payload.truncate()
 
+
     def _consumePayload(self):
         """
-        Consumes the payload portion of C{self.currentData}.
+        Consumes the payload portion of C{self._currentData}.
 
         If the payload is complete, checks for the trailing comma and
         processes the payload. If not, raises an L{IncompleteNetstring}
@@ -259,66 +317,69 @@
         comma.
         """
         self._extractPayload()
-        if self.currentDataSize < self.expectedLength:
-            raise IncompleteNetstring
+        if self._currentDataSize < self._expectedLength:
+            raise IncompleteNetstring()
         self._checkForTrailingComma()
-        self.state = PARSING_LENGTH
+        self._state = PARSING_LENGTH
         self._processPayload()
 
+
     def _extractPayload(self):
         """
-        Extracts payload information from C{self.currentData}.
+        Extracts payload information from C{self._currentData}.
 
-        Splits C{self.currentData} at the end of the netstring.  The
-        first part becomes C{self.payload}, the second part is stored
-        in C{self.currentData}.
+        Splits C{self._currentData} at the end of the netstring.  The
+        first part becomes C{self._payload}, the second part is stored
+        in C{self._currentData}.
 
         If the netstring is not yet complete, the whole content of
-        C{self.currentData} is moved to C{self.payload}.
+        C{self._currentData} is moved to C{self._payload}.
         """
         if self._payloadComplete():
-            remainingPayloadSize = self.expectedLength - self.currentDataSize
-            self.payload.write(self.currentData[:remainingPayloadSize])
-            self.currentData = self.currentData[remainingPayloadSize:]
-            self.currentDataSize = self.expectedLength
+            remainingPayloadSize = self._expectedLength - self._currentDataSize
+            self._payload.write(self._currentData[:remainingPayloadSize])
+            self._currentData = self._currentData[remainingPayloadSize:]
+            self._currentDataSize = self._expectedLength
         else:
-            self.payload.write(self.currentData)
-            self.currentDataSize += len(self.currentData)
-            self.currentData = ""
+            self._payload.write(self._currentData)
+            self._currentDataSize += len(self._currentData)
+            self._currentData = ""
 
+
     def _payloadComplete(self):
         """
         Checks if enough data have been received to complete the netstring.
 
         @return: C{True} iff the received data contain at least as many
-        characters as specified in the length section of the
-        netstring
+            characters as specified in the length section of the
+            netstring
         @rtype: C{bool}
         """
-        return (len(self.currentData) + self.currentDataSize >
-                self.expectedLength)
+        return (len(self._currentData) + self._currentDataSize >=
+                self._expectedLength)
 
+
     def _processPayload(self):
         """
         Processes the actual payload with L{stringReceived}.
 
-        Strips C{self.payload} of the trailing comma and calls
+        Strips C{self._payload} of the trailing comma and calls
         L{stringReceived} with the result.
         """
-        self.stringReceived(self.payload.getvalue()[:-1])
+        self.stringReceived(self._payload.getvalue()[:-1])
 
+
     def _checkForTrailingComma(self):
         """
         Checks if the netstring has a trailing comma at the expected position.
 
-        Checks if the last character of C{self.payload} is a comma.
-
         @raise NetstringParseError: if the last payload character is
             anything but a comma.
         """
-        if self.payload.getvalue()[-1] != ",":
-            raise NetstringParseError(NETSTRING_MISSING_COMMA)
+        if self._payload.getvalue()[-1] != ",":
+            raise NetstringParseError(self._MISSING_COMMA)
 
+
     def _handleParseError(self):
         """
         Terminates the connection and sets the flag C{self.brokenPeer}.
@@ -327,13 +388,17 @@
         self.brokenPeer = 1
 
 
+
 class SafeNetstringReceiver(NetstringReceiver):
-    """This class is deprecated, use NetstringReceiver instead.
     """
+    This class is deprecated, use NetstringReceiver instead.
+    """
 
 
+
 class LineOnlyReceiver(protocol.Protocol):
-    """A protocol that receives only lines.
+    """
+    A protocol that receives only lines.
 
     This is purely a speed optimisation over LineReceiver, for the
     cases that raw mode is known to be unnecessary.
@@ -349,7 +414,9 @@
     MAX_LENGTH = 16384
 
     def dataReceived(self, data):
-        """Translates bytes into lines, and calls lineReceived."""
+        """
+        Translates bytes into lines, and calls lineReceived.
+        """
         lines  = (self._buffer+data).split(self.delimiter)
         self._buffer = lines.pop(-1)
         for line in lines:
@@ -366,18 +433,21 @@
         if len(self._buffer) > self.MAX_LENGTH:
             return self.lineLengthExceeded(self._buffer)
 
+
     def lineReceived(self, line):
         """
         Override this for when each line is received.
         """
         raise NotImplementedError
 
+
     def sendLine(self, line):
         """
         Sends a line to the other end of the connection.
         """
         return self.transport.writeSequence((line,self.delimiter))
 
+
     def lineLengthExceeded(self, line):
         """
         Called when the maximum line length has been reached.
@@ -386,6 +456,7 @@
         return error.ConnectionLost('Line length exceeded')
 
 
+
 class _PauseableMixin:
     paused = False
 
@@ -393,18 +464,22 @@
         self.paused = True
         self.transport.pauseProducing()
 
+
     def resumeProducing(self):
         self.paused = False
         self.transport.resumeProducing()
         self.dataReceived('')
 
+
     def stopProducing(self):
         self.paused = True
         self.transport.stopProducing()
 
 
+
 class LineReceiver(protocol.Protocol, _PauseableMixin):
-    """A protocol that receives lines and/or raw data, depending on mode.
+    """
+    A protocol that receives lines and/or raw data, depending on mode.
 
     In line mode, each line that's received becomes a callback to
     L{lineReceived}.  In raw data mode, each chunk of raw data becomes a
@@ -435,8 +510,10 @@
         self.__buffer = ""
         return b
 
+
     def dataReceived(self, data):
-        """Protocol.dataReceived.
+        """
+        Protocol.dataReceived.
         Translates bytes into lines, and calls lineReceived (or
         rawDataReceived, depending on mode.)
         """
@@ -465,8 +542,10 @@
                 if data:
                     return self.rawDataReceived(data)
 
+
     def setLineMode(self, extra=''):
-        """Sets the line-mode of this receiver.
+        """
+        Sets the line-mode of this receiver.
 
         If you are calling this from a rawDataReceived callback,
         you can pass in extra unhandled data, and that data will
@@ -480,30 +559,40 @@
         if extra:
             return self.dataReceived(extra)
 
+
     def setRawMode(self):
-        """Sets the raw mode of this receiver.
+        """
+        Sets the raw mode of this receiver.
         Further data received will be sent to rawDataReceived rather
         than lineReceived.
         """
         self.line_mode = 0
 
+
     def rawDataReceived(self, data):
-        """Override this for when raw data is received.
         """
+        Override this for when raw data is received.
+        """
         raise NotImplementedError
 
+
     def lineReceived(self, line):
-        """Override this for when each line is received.
         """
+        Override this for when each line is received.
+        """
         raise NotImplementedError
 
+
     def sendLine(self, line):
-        """Sends a line to the other end of the connection.
         """
+        Sends a line to the other end of the connection.
+        """
         return self.transport.write(line + self.delimiter)
 
+
     def lineLengthExceeded(self, line):
-        """Called when the maximum line length has been reached.
+        """
+        Called when the maximum line length has been reached.
         Override if it needs to be dealt with in some special way.
 
         The argument 'line' contains the remainder of the buffer, starting
@@ -514,6 +603,7 @@
         return self.transport.loseConnection()
 
 
+
 class StringTooLongError(AssertionError):
     """
     Raised when trying to send a string too long for a length prefixed
@@ -521,6 +611,7 @@
     """
 
 
+
 class IntNStringReceiver(protocol.Protocol, _PauseableMixin):
     """
     Generic class for length prefixed protocols.
@@ -575,6 +666,7 @@
             self.recvd = self.recvd[length + self.prefixLength:]
             self.stringReceived(packet)
 
+
     def sendString(self, data):
         """
         Send an prefixed string to the other end of the connection.
@@ -588,6 +680,7 @@
         self.transport.write(struct.pack(self.structFormat, len(data)) + data)
 
 
+
 class Int32StringReceiver(IntNStringReceiver):
     """
     A receiver for int32-prefixed strings.
@@ -601,6 +694,7 @@
     prefixLength = struct.calcsize(structFormat)
 
 
+
 class Int16StringReceiver(IntNStringReceiver):
     """
     A receiver for int16-prefixed strings.
@@ -614,6 +708,7 @@
     prefixLength = struct.calcsize(structFormat)
 
 
+
 class Int8StringReceiver(IntNStringReceiver):
     """
     A receiver for int8-prefixed strings.
@@ -627,6 +722,7 @@
     prefixLength = struct.calcsize(structFormat)
 
 
+
 class StatefulStringProtocol:
     """
     A stateful string protocol.
@@ -642,7 +738,8 @@
     state = 'init'
 
     def stringReceived(self,string):
-        """Choose a protocol phase function and call it.
+        """
+        Choose a protocol phase function and call it.
 
         Call back to the appropriate protocol phase; this begins with
         the function proto_init and moves on to proto_* depending on
@@ -660,8 +757,11 @@
             if self.state == 'done':
                 self.transport.loseConnection()
 
+
+
 class FileSender:
-    """A producer that sends the contents of a file to a consumer.
+    """
+    A producer that sends the contents of a file to a consumer.
 
     This is a helper for protocols that, at some point, will take a
     file-like object, read its contents, and write them out to the network,
@@ -675,7 +775,8 @@
     deferred = None
 
     def beginFileTransfer(self, file, consumer, transform = None):
-        """Begin transferring a file
+        """
+        Begin transferring a file
 
         @type file: Any file-like object
         @param file: The file object to read data from
@@ -688,9 +789,9 @@
         being written to the consumer.
 
         @rtype: C{Deferred}
-        @return: A deferred whose callback will be invoked when the file has been
-        completely written to the consumer.  The last byte written to the consumer
-        is passed to the callback.
+        @return: A deferred whose callback will be invoked when the file has
+        been completely written to the consumer. The last byte written to the
+        consumer is passed to the callback.
         """
         self.file = file
         self.consumer = consumer
@@ -700,6 +801,7 @@
         self.consumer.registerProducer(self, False)
         return deferred
 
+
     def resumeProducing(self):
         chunk = ''
         if self.file:
@@ -717,10 +819,13 @@
         self.consumer.write(chunk)
         self.lastSent = chunk[-1]
 
+
     def pauseProducing(self):
         pass
 
+
     def stopProducing(self):
         if self.deferred:
-            self.deferred.errback(Exception("Consumer asked us to stop producing"))
+            self.deferred.errback(
+                Exception("Consumer asked us to stop producing"))
             self.deferred = None
Index: twisted/topfiles/4378.bugfix
===================================================================
--- twisted/topfiles/4378.bugfix	(Revision 0)
+++ twisted/topfiles/4378.bugfix	(Revision 0)
@@ -0,0 +1,3 @@
+twisted.protocols.basic.NetstringReceiver raises NetstringParseErrors for 
+invalid netstrings now. It handles empty netstrings ("0:,") correctly, and 
+the performance for receiving netstrings has been improved.
Index: doc/core/benchmarks/netstringreceiver.py
===================================================================
--- doc/core/benchmarks/netstringreceiver.py	(Revision 0)
+++ doc/core/benchmarks/netstringreceiver.py	(Revision 0)
@@ -0,0 +1,244 @@
+# Copyright (c) 2010 Twisted Matrix Laboratories.
+# See LICENSE for details.
+
+from twisted.test import proto_helpers, test_protocols
+import math
+import time
+import sys
+import os
+import gc
+
+NETSTRING_PREFIX_TEMPLATE ="%d:"
+NETSTRING_POSTFIX = ","
+USAGE = """\
+Usage: %s <number> <filename>
+
+This script creates up to 2 ** <number> chunks with up to 2 **
+<number> characters and sends them to the NetstringReceiver. The
+sorted performance data for all combination is written to <filename>
+afterwards.
+
+You might want to start with a small number, maybe 10 or 12, and slowly
+increase it. Stop when the performance starts to deteriorate ;-).
+"""
+
+class PerformanceTester(object):
+    """
+    A class for testing the performance of some
+    """
+
+    headers = []
+    lineFormat = ""
+    performanceData = {}
+
+    def __init__(self, filename):
+        """
+        Initializes C{self.filename}.
+
+        If a file with this name already exists, asks if it should be
+        overwritten. Terminates with exit status 1, if the user does
+        not accept.
+        """
+        if os.path.isfile(filename):
+            response = raw_input(("A file named %s exists. "
+                                 "Overwrite it (y/n)? ") % filename)
+            if response.lower() != "y":
+                print "Performance test cancelled."
+                sys.exit(1)
+        self.filename = filename
+
+
+    def testPerformance(self, number):
+        """
+        Drives the execution of C{performTest} with arguments between
+        0 and C{number - 1}.
+
+        @param number: Defines the number of test runs to be performed.
+        @type number: C{int}
+        """
+        for iteration in xrange(number):
+            self.performTest(iteration)
+
+
+    def performTest(self, iteration):
+        """
+        Performs one test iteration. Overwrite this.
+
+        @param iteration: The iteration number. Can be used to configure
+            the test.
+        @type iteration: C{int}
+        @raise NotImplementedError: because this method has to be implemented
+            by the subclass.
+        """
+        raise NotImplementedError
+
+
+    def createReport(self):
+        """
+        Creates a file and writes a table with performance data.
+
+        The performance data are ordered by the total size of the netstrings.
+        In addition they show the chunk size, the number of chunks and the
+        time (in seconds) that elapsed while the C{NetstringReceiver}
+        received the netstring.
+
+        @param filename: The name of the report file that will be written.
+        @type filename: C{str}
+        """
+        self.outputFile = open(self.filename, "w")
+        self.writeHeader()
+        self.writePerformanceData()
+        self.writeLineSeparator()
+        print "The report was written to %s." % self.filename
+
+
+    def writeHeader(self):
+        """
+        Writes the table header for the report.
+        """
+        self.writeLineSeparator()
+        self.outputFile.write("| %s |\n" % (" | ".join(self.headers),))
+        self.writeLineSeparator()
+
+
+    def writeLineSeparator(self):
+        """
+        Writes a 'line separator' made from '+' and '-' characters.
+        """
+        dashes = ("-" * (len(header) + 2) for header in self.headers)
+        self.outputFile.write("+%s+\n" % "+".join(dashes))
+
+
+    def writePerformanceData(self):
+        """
+        Writes one line for each item in C{self.performanceData}.
+        """
+        for combination, elapsed in sorted(self.performanceData.iteritems()):
+            totalSize, chunkSize, numberOfChunks = combination
+            self.outputFile.write(self.lineFormat %
+                                  (totalSize, chunkSize, numberOfChunks,
+                                   elapsed))
+
+
+
+class NetstringPerformanceTester(PerformanceTester):
+    """
+    A class for determining the C{NetstringReceiver.dataReceived} performance.
+
+    Instantiates a C{NetstringReceiver} and calls its
+    C{dataReceived()} method with different chunks sizes and numbers
+    of chunks.  Presents a table showing the relation between input
+    data and time to process them.
+    """
+
+    headers = ["Chunk size", "Number of chunks", "Total size",
+               "Time to receive" ]
+    lineFormat = ("| %%%dd | %%%dd | %%%dd | %%%d.4f |\n" %
+                  tuple([len(header) for header in headers]))
+
+    def __init__(self, filename):
+        """
+        Sets up the output file and the netstring receiver that will be
+        used for receiving data.
+
+        @param filename: The name of the file for storing the report.
+        @type filename: C{str}
+        """
+        PerformanceTester.__init__(self, filename)
+        transport = proto_helpers.StringTransport()
+        self.netstringReceiver = test_protocols.TestNetstring()
+        self.netstringReceiver.makeConnection(transport)
+
+
+    def performTest(self, number):
+        """
+        Tests the performance of C{NetstringReceiver.dataReceived}.
+
+        Feeds netstrings of various sizes in different chunk sizes
+        to a C{NetstringReceiver} and stores the elapsed time in
+        C{self.performanceData}.
+
+        @param number: The maximal chunks size / number of
+            chunks to be checked.
+        @type number: C{int}
+        """
+        chunkSize = 2 ** number
+        numberOfChunks = chunkSize
+        while numberOfChunks:
+            self.testCombination(chunkSize, numberOfChunks)
+            numberOfChunks = numberOfChunks // 2
+
+
+    def testCombination(self, chunkSize, numberOfChunks):
+        """
+        Tests one combination of chunk size and number of chunks.
+
+        @param chunkSize: The size of one chunk to be sent to the
+            C{NetstringReceiver}.
+        @type chunkSize: C{int}
+        @param numberOfChunks: The number of C{chunkSize}-sized chunks to
+            be sent to the C{NetstringReceiver}.
+        @type numberOfChunks: C{int}
+        """
+        chunk, dataSize = self.configureCombination(chunkSize, numberOfChunks)
+        elapsed = self.receiveData(chunk, numberOfChunks, dataSize)
+        key = (chunkSize, numberOfChunks, dataSize)
+        self.performanceData[key] = elapsed
+
+
+    def configureCombination(self, chunkSize, numberOfChunks):
+        """
+        Updates C{MAX_LENGTH} and C{MAX_LENGTH_SIZE} for
+        {self.netstringReceiver} (to avoid C{NetstringParseErrors}
+        that might be raised if the size exceeds the default
+        C{MAX_LENGTH}).
+
+        Calculates and returns one 'chunk' of data and the total size
+        of the netstring.
+
+        @param chunkSize: The size of chunks that will be received.
+        @type chunkSize: C{int}
+        @param numberOfChunks: The number of C{chunkSize}-sized chunks
+            that will be received.
+        @type numberOfChunks: C{int}
+
+        @return: A tuple consisting of string of C{chunkSize} 'a'
+        characters and the size of the netstring data portion.
+        """
+        chunk = "a" * chunkSize
+        dataSize = chunkSize * numberOfChunks
+        self.netstringReceiver.MAX_LENGTH = dataSize
+        numberOfDigits = math.ceil(math.log10(dataSize)) + 1
+        self.netstringReceiver.MAX_LENGTH_SIZE = numberOfDigits
+        return chunk, dataSize
+
+
+    def receiveData(self, chunk, numberOfChunks, dataSize):
+        dr = self.netstringReceiver.dataReceived
+        now = time.time()
+        dr(NETSTRING_PREFIX_TEMPLATE % (dataSize,))
+        for idx in xrange(numberOfChunks):
+            dr(chunk)
+        dr(NETSTRING_POSTFIX)
+        elapsed = time.time() - now
+        assert self.netstringReceiver.received, "Didn't receive string!"
+        return elapsed
+
+
+def disableGarbageCollector():
+    gc.disable()
+    print 'Disabled Garbage Collector.'
+
+
+def main(number, filename):
+    disableGarbageCollector()
+    npt = NetstringPerformanceTester(filename)
+    npt.testPerformance(int(number))
+    npt.createReport()
+
+
+if __name__ == "__main__":
+    if len(sys.argv) < 3:
+        print USAGE % sys.argv[0]
+        sys.exit(1)
+    main(*sys.argv[1:3])
